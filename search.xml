<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL题目与解析</title>
      <link href="/2020/02/26/SQL%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/26/SQL%E9%A2%98%E7%9B%AE%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL练习题与解析"><a href="#SQL练习题与解析" class="headerlink" title="SQL练习题与解析"></a>SQL练习题与解析</h1><p>author：Yuhao Wang</p><p>last_update_time：2020-02-25</p><h2 id="一、练习说明"><a href="#一、练习说明" class="headerlink" title="一、练习说明"></a>一、练习说明</h2><p>对于大多数小伙伴来说， 最主要的是查询语句的使用。想要真正的掌握SQL，最好的方法就是不断的刷题，逐步强化锻炼你对于SQL的<strong>结构化思维</strong>，这一点非常重要。</p><p>刷题的方式有两种：</p><p>第一种：在数据库中建好数据表并导入数据，然后在查询环境中书写SQL提交查询。这种方式更适合初学者，因为每次提交SQL语句后，编译器都会对你的SQL进行解析，如果书写错误会及时提示，告诉你错在什么地方以便于你进一步调试。</p><p>第二种：直接看表结构，然后直接在本子上或者编辑工具中写SQL，在你确认无误后直接对照答案检查。这种方式直接跳过了机器检验，更考验你对SQL的熟悉程度。当你有一定的基础后，我更推荐这种方式。</p><p>最后提两点大家在书写SQL时的小建议，养成良好的习惯也至关重要：</p><ul><li><strong>写注释</strong>：对于初学者而言，写注释可以帮你<strong>理清思路</strong>；对于有一定基础的小伙伴而言，注释可以快速帮你理解复杂SQL的作用，极大提升工作效率</li><li><strong>注意缩进</strong>：对于复杂SQL来说，好的缩进层次可以<strong>极大的提升阅读体验</strong>，也可以令SQL看起来简洁有序。</li></ul><h2 id="二、在线练习网站推荐"><a href="#二、在线练习网站推荐" class="headerlink" title="二、在线练习网站推荐"></a>二、在线练习网站推荐</h2><p>这里推荐几个在线SQL学习网站(排名不分先后，点击名称即可跳转)：</p><ol><li><a href="https://sqlzoo.net/" target="_blank" rel="noopener">sqlzoo</a>：这个网站包括了SQL学习的教程和参考资料，支持多种SQL搜索引擎且支持多过语言， 题目由易到难。</li><li><a href="https://sqlbolt.com/" target="_blank" rel="noopener">SQLBolt</a>： SQLBolt 是一个适合小白学习 SQL 的网站，这里由浅及深的介绍了 SQL 的知识，每一个章节是一组相关的 SQL 知识点，且配备着相应的练习，唯一的缺点是英文的。</li><li><a href="http://xuesql.cn" target="_blank" rel="noopener">xuesql.cn</a>：相当于 SQLBolt 的中文版，包含视频、手册、在线练习。 </li><li><a href="https://leetcode-cn.com" target="_blank" rel="noopener">leetcode</a>：不仅可用于刷算法题，也有关于SQL的题目，提交答案后在线测评，也会让你很直观的看到自己所写的 SQL 的运行速度等。设有讨论区，可以去借鉴别人优化好的 SQL</li><li><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>：与leetcode相似，可以在线提交与测评。</li></ol><h2 id="三、练习数据准备"><a href="#三、练习数据准备" class="headerlink" title="三、练习数据准备"></a>三、练习数据准备</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>本文题目大部分出牛客网<a href="https://www.nowcoder.com/ta/sql?page=0" target="_blank" rel="noopener">数据库专题</a>，大家可以进入网站自行练习，也可以在自己的电脑上<strong>导入数据集</strong>，这里需安装<code>MySQL</code>客户端与<code>Navicat</code>(非必须)。牛客网的搜索引擎为<code>SQLite</code>，少部分语法与<code>MySQL</code>不兼容，个人更倾向于离线本地学习，这样可以顺便对SQL中的建表也有一定的了解。测试数据集我放在<a href="https://pan.baidu.com/s/16Lnl1D4y4ITlaohNdePZGw" target="_blank" rel="noopener">网盘</a>，提取码：0gad，大家自取。导入数据的方式可以通过在<code>Navicate</code>中<code>右击数据库名</code>后点击<code>运行SQL文件</code>，可以以直接运行脚本内的SQL，在此不再赘述，另外本文的题目主要是查询类题目，如果大家想了解对于数据库、数据表、数据列的操作，可以看我的另外一篇文章。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这里简要给大家列举一下会用到的数据库表结构，方便大家做题的时候对照查看。</p><h4 id="employees-员工表"><a href="#employees-员工表" class="headerlink" title="employees 员工表"></a><code>employees</code> 员工表</h4><p>该表存放员工的基本信息</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID，主键</td></tr><tr><td><code>birth_date</code></td><td>date</td><td>否</td><td>生日</td></tr><tr><td><code>first_name</code></td><td>varchar(14)</td><td>否</td><td>姓</td></tr><tr><td><code>last_name</code></td><td>varchar(16)</td><td>否</td><td>名</td></tr><tr><td><code>gender</code></td><td>char(1)</td><td>否</td><td>性别</td></tr><tr><td><code>hire_date</code></td><td>date</td><td>否</td><td>雇佣日期</td></tr></tbody></table><h4 id="dept-manager-部门领导表"><a href="#dept-manager-部门领导表" class="headerlink" title="dept_manager 部门领导表"></a><code>dept_manager</code> 部门领导表</h4><p>该表存放每个部门的领导信息，使用<code>dept_no</code>与<code>emp_no</code>作为复合主键</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>dept_no</code></td><td>char(4)</td><td>否</td><td>部门ID</td></tr><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID</td></tr><tr><td><code>from_date</code></td><td>date</td><td>否</td><td>开始日期</td></tr><tr><td><code>to_date</code></td><td>date</td><td>否</td><td>结束日期</td></tr></tbody></table><p><strong>提问</strong>：为何要使用使用<code>dept_no</code>与<code>emp_no</code>作为复合主键？</p><p>举例说明：雇员A在2016年至2018年为部门A的领导，在2018-2019年为部门B的领导，2020年至今为部门C的领导，则雇员A在<code>dept_manager</code> 中存在3条记录，且最后一条记录(2020年至今)的<code>to_date</code>为’9999-01-01’，因此要使用复合主键才能唯一确定一条记录。</p><p><strong>扩展</strong>：这种数据模型在数据仓库的设计过程中被称为<a href="https://blog.csdn.net/saqin6255/article/details/80362248" target="_blank" rel="noopener">拉链表</a>。既能满足反应数据的历史状态， 又可以最大程度的节省存储 </p><h4 id="salaries-薪水表"><a href="#salaries-薪水表" class="headerlink" title="salaries 薪水表"></a><code>salaries</code> 薪水表</h4><p>该表存放所有雇员的薪水信息。使用<code>emp_no</code>与<code>from_date</code>作为复合主键，原因与上表相同</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID</td></tr><tr><td><code>salary</code></td><td>int(11)</td><td>否</td><td>薪水</td></tr><tr><td><code>from_date</code></td><td>date</td><td>否</td><td>开始日期</td></tr><tr><td><code>to_date</code></td><td>date</td><td>否</td><td>结束日期</td></tr></tbody></table><h4 id="dept-emp-部门员工表"><a href="#dept-emp-部门员工表" class="headerlink" title="dept_emp 部门员工表"></a><code>dept_emp</code> 部门员工表</h4><p>该表存放部门与雇员的对应信息。使用<code>emp_no</code>与<code>dept_no</code>作为复合主键</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID</td></tr><tr><td><code>dept_no</code></td><td>char(4)</td><td>否</td><td>部门ID</td></tr><tr><td><code>from_date</code></td><td>date</td><td>否</td><td>开始日期</td></tr><tr><td><code>to_date</code></td><td>date</td><td>否</td><td>结束日期</td></tr></tbody></table><h4 id="titles-职称表"><a href="#titles-职称表" class="headerlink" title="titles 职称表"></a><code>titles</code> 职称表</h4><p>该表存放雇员与职称的对应信息。使用<code>emp_no</code>与<code>from_date</code>作为复合主键</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID</td></tr><tr><td><code>title</code></td><td>varchar(50)</td><td>否</td><td>职称</td></tr><tr><td><code>from_date</code></td><td>date</td><td>否</td><td>开始日期</td></tr><tr><td><code>to_date</code></td><td>date</td><td>否</td><td>结束日期</td></tr></tbody></table><h4 id="emp-bonus-奖金表"><a href="#emp-bonus-奖金表" class="headerlink" title="emp_bonus 奖金表"></a><code>emp_bonus</code> 奖金表</h4><p>该表存放雇员与对应的奖金信息。</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>emp_no</code></td><td>int(11)</td><td>否</td><td>员工ID</td></tr><tr><td><code>recevied</code></td><td>datetime</td><td>否</td><td>发放时间</td></tr><tr><td><code>btype</code></td><td>smallint</td><td>否</td><td>奖金类型（1、2、3）</td></tr></tbody></table><h4 id="departments-部门表"><a href="#departments-部门表" class="headerlink" title="departments 部门表"></a><code>departments</code> 部门表</h4><p>该表存放部门的信息。</p><table><thead><tr><th>列名</th><th>字段类型</th><th>是否为空</th><th>含义</th></tr></thead><tbody><tr><td><code>dept_no</code></td><td>char(4)</td><td>否</td><td>部门ID，主键</td></tr><tr><td><code>dept_name</code></td><td>varchar(40)</td><td>否</td><td>部门名称</td></tr></tbody></table><h2 id="四、题目"><a href="#四、题目" class="headerlink" title="四、题目"></a>四、题目</h2><p>建议小伙伴们在做题的时候先把解题思路遮住，自己思考并尝试自己写，最后再与答案对照。另外很多题目<strong>解题方式不唯一</strong>，答案与解题思路仅供参考。</p><h3 id="1-入职最晚的员工"><a href="#1-入职最晚的员工" class="headerlink" title="1 入职最晚的员工"></a>1 入职最晚的员工</h3><p><strong>题目描述</strong>： 在员工表中查找最晚入职员工的所有信息</p><p><strong>解题思路</strong>：</p><p>先找出所有入职时间里最大(最晚)的时间，在使用子查询的方式查找入职时间等于最晚时间的员工的所有信息，这样可以确保多条最晚入职的员工信息都可以被查询出来。 </p><pre class=" language-mysql"><code class="language-mysql">-- 第一种方式SELECT * FROM employeesWHERE hire_date = (SELECT MAX(hire_date)                    FROM employees                  );-- 第二种方式SELECT * FROM employeesWHERE hire_date = (SELECT hire_date                    FROM employees                   ORDER BY hire_date DESC                   LIMIT 1                  );</code></pre><p><strong>注意：</strong>很多小伙伴可能会想到先对<code>hire_date</code>进行排序，然后使用<code>LIMIT=1</code>限制条数，但是使用<code>ORDER BY</code>按由大到小排序后选取第一条的方法仅限于当最晚入职数据只有一条时才正确，不能保证有多条同一最晚时间时的准确性。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employeesORDER BY hire_date DESCLIMIT 1; </code></pre><h3 id="2-入职时间排名倒数第三的员工"><a href="#2-入职时间排名倒数第三的员工" class="headerlink" title="2 入职时间排名倒数第三的员工"></a>2 入职时间排名倒数第三的员工</h3><p><strong>题目描述</strong>： 在员工表中查找入职员工时间排名倒数第三的员工所有信息</p><p><strong>解题思路</strong>：</p><p> 同样使用子查询方法找到排名倒数第三的<code>hire_date</code>。在子查询中关键是要<strong>用</strong><code>DISTINCT</code><strong>去重</strong>，去重后相同入职日期只会保留一个，此时使用<code>ORDER BY</code>进行排序，然后使用<code>LIMIT</code>选择排名倒数第三的<code>hire_date</code>。  </p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employeesWHERE hire_date = (                    SELECT DISTINCT hire_date                     FROM employees                    ORDER BY hire_date DESC                     LIMIT 2,1                  );</code></pre><h3 id="3-领导的薪水"><a href="#3-领导的薪水" class="headerlink" title="3 领导的薪水"></a>3 领导的薪水</h3><p><strong>题目描述</strong>： <strong>查找各个部门当前领导<em>(to_date=’9999-01-01’)</em>当前薪水详情以及其对应部门编号<code>dept_no</code></strong> </p><p><strong>解题思路</strong>：</p><p> 通过<code>dept_manager</code>的<code>emp_no</code>=<code>salaries</code>的<code>emp_no</code>为联结条件联结两表，同时限制两表的<em>to_date = ‘9999-01-01’</em>筛选数据</p><pre class=" language-mysql"><code class="language-mysql">SELECT s.*,d.dept_noFROM salaries s JOIN dept_manager d ON s.emp_no = d.emp_noWHERE d.to_date = '9999-01-01'   AND s.to_date = '9999-01-01';</code></pre><h3 id="4-所有员工的姓名与部门"><a href="#4-所有员工的姓名与部门" class="headerlink" title="4 所有员工的姓名与部门"></a>4 所有员工的姓名与部门</h3><p><strong>题目描述</strong>： 查找所有员工的<code>last_name</code>和<code>first_name</code>以及对应部门编号<code>dept_no</code>，也包括展示没有分配具体部门的员工</p><p><strong>解题思路</strong>：</p><p> 使用<code>employees</code>作为主表，使用左联结，比较简单。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT e.last_name,e.first_name,d.dept_noFROM employees e LEFT JOIN dept_emp d ON e.emp_no = d.emp_no;</code></pre><h3 id="5-已经分配部门的员工"><a href="#5-已经分配部门的员工" class="headerlink" title="5 已经分配部门的员工"></a>5 已经分配部门的员工</h3><p><strong>题目描述</strong>：  查找所有已经分配部门的员工的<code>last_name</code>和<code>first_name</code> </p><p><strong>解题思路</strong>：</p><p>这里考察<code>LEFT JOIN</code>的原理。使用<code>employees</code>作为主表<strong>左联结</strong><code>dept_emp</code>，题目要查找所有已经分配部门的员工，意味着联结后必须要带有<code>dept_no</code>，没有<code>dept_no</code>的就是还未分配部门的，因此加上筛选条件<code>dept_no</code>为空即可求得。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT e.last_name,e.first_nameFROM employees e LEFT JOIN dept_emp d ON e.emp_no = d.emp_noWHERE d.dept_no is not null;</code></pre><h3 id="6-员工入职时的薪水"><a href="#6-员工入职时的薪水" class="headerlink" title="6 员工入职时的薪水"></a>6 员工入职时的薪水</h3><p><strong>题目描述</strong>： 查找所有员工入职时候的薪水情况，给出<code>emp_no</code>以及<code>salary</code>， 并按照<code>emp_no</code>进行逆序</p><p><strong>解题思路</strong>：</p><p>使用左联结(内联结)，此题最关键的是<code>salaries</code>表的<code>from_date</code> 和 <code>employees</code>表的<code>hire_date</code> 的值应该要相等，因此有限制条件<code>e.hire_date = s.from_date</code>，两个<code>date</code>都是刚入职的时间。</p><p>再强调一下，<code>salaries</code>表中有多个相同<code>emp_no</code>的<code>salary</code>，即<code>emp_no</code>在<code>salaries</code>表中不唯一，因为同一员工在不同时间的工资不同，即涨薪或降薪。</p><pre class=" language-mysql"><code class="language-mysql">SELECT e.emp_no,s.salaryFROM salaries s LEFT JOIN employees e ON s.emp_no = e.emp_noWHERE e.hire_date = s.from_dateORDER BY s.emp_no DESC;</code></pre><h3 id="7-员工当前薪水"><a href="#7-员工当前薪水" class="headerlink" title="7 员工当前薪水"></a>7 员工当前薪水</h3><p><strong>题目描述</strong>： 找出所有员工当前<em>(to_date=’9999-01-01’)</em>具体的薪水<code>salary</code>情况，最后只显示<code>salary</code>这一列，对于相同的薪水只显示一次,并按照逆序显示</p><p><strong>解题思路</strong>：</p><p>关键理解对于<strong>相同的薪水只显示一次</strong>，使用分组方法对<code>salary</code>进行分组求得，也可以使用<code>DISTINCT</code>去重的方法，但是一般数据较多时使用<code>DISTINCT</code>效率相比<code>GROUP BY</code> 要慢，所以从性能角度考虑，应该尽量使用<code>GROUP BY</code>。 </p><pre class=" language-mysql"><code class="language-mysql">-- 第一种方式 使用DISTINCTSELECT DISTINCT salaryFROM salariesWHERE to_date='9999-01-01'ORDER BY salary DESC;-- 第二种方式SELECT salaryFROM salariesWHERE to_date='9999-01-01'GROUP BY salaryORDER BY salary DESC;</code></pre><h3 id="8-领导当前薪水"><a href="#8-领导当前薪水" class="headerlink" title="8 领导当前薪水"></a>8 领导当前薪水</h3><p><strong>题目描述</strong>：  获取所有部门当前<code>manager</code>的当前薪水情况(<em>to_date=’9999-01-01’</em>)，给出<code>dept_no</code>, <code>emp_no</code>以及<code>salary</code></p><p><strong>解题思路</strong>：</p><p>注意理解题目，键点是有两个“当前”。因此<code>dept_manager</code>表的<code>to_date</code>和<code>salaries</code>表的<code>to_date</code>都要等于’9999-01-01’，<code>s.to_date = &#39;9999-01-01&#39;</code>容易理解，限定当前时间当前工资，<code>d.to_date = &#39;9999-01-01&#39;</code>则限定在职经理。</p><pre class=" language-mysql"><code class="language-mysql">SELECT d.dept_no,d.emp_no,s.salaryFROM salaries s LEFT JOIN dept_manager d ON d.emp_no = s.emp_noWHERE d.to_date = '9999-01-01' AND s.to_date = '9999-01-01';</code></pre><h3 id="9-不是领导的员工"><a href="#9-不是领导的员工" class="headerlink" title="9 不是领导的员工"></a>9 不是领导的员工</h3><p><strong>题目描述</strong>：  获取所有非<code>manager</code>员工的<code>emp_no</code></p><p><strong>解题思路</strong>：</p><p> 使用<code>employees</code>作为主表，使用左联结，限定条件为<code>d.dept_no</code>为空，选出在<code>employees</code>中但不在<code>dept_manager</code>中的<code>emp_no</code>记录。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT e.emp_noFROM employees e LEFT JOIN dept_manager d ON e.emp_no = d.emp_noWHERE d.dept_no is null;</code></pre><h3 id="10-员工当前的领导"><a href="#10-员工当前的领导" class="headerlink" title="10 员工当前的领导"></a>10 员工当前的领导</h3><p><strong>题目描述</strong>：  获取所有员工的当前的<code>emp_no</code>与对应经理的<code>manager_no</code>，如果当前的<code>manager</code>是自己的话结果不显示，当前表示<code>to_date=&#39;9999-01-01&#39;</code>。</p><p><strong>解题思路</strong>：</p><p>重点要理解两表之间的逻辑关系和题目要求。有三个关键点：</p><ol><li><p>每个部门都有一个<code>manager</code>，每个人都有自己所在的部门。所以用部门号<code>dept_no</code>作为联结条件，左联结和内联结都可以；</p></li><li><p>如果员工当前的<code>manager</code>是自己的话结果不显示，这就要求<code>dept_emp</code>表的员工编号<code>emp_no</code>和<code>dept_manager</code>的员工编号不相等；</p></li><li><p>题目要求当前的<code>manager</code>，所以最后的经理表<code>dept_manager</code>的时间为<em>to_date=’9999-01-01’</em>，严谨起见，员工表<code>dept_emp</code>的时间也应该是<em>to_date=’9999-01-01’</em>。</p></li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT  de.emp_no,  dm.emp_no AS manager_no FROM  dept_emp deLEFT JOIN dept_manager dm ON de.dept_no = dm.dept_no WHERE  de.to_date = '9999-01-01'AND dm.to_date = '9999-01-01'AND de.emp_no <> dm.emp_no</code></pre><h3 id="11-部门最高的员工薪水"><a href="#11-部门最高的员工薪水" class="headerlink" title="11 部门最高的员工薪水"></a>11 部门最高的员工薪水</h3><p><strong>题目描述</strong>： 获取所有部门中当前员工<strong>薪水最高</strong>的相关信息，给出<code>dept_no</code>, <code>emp_no</code>以及其对应的<code>salary</code></p><p><strong>解题思路</strong>：</p><p>STEP1：先用内联结或左联结连接两张表，限制条件是两张表的<code>emp_no</code>相同，即<code>d.emp_no = s.emp_no</code></p><p>STEP2：选取每个员工当前的工资水平，用<code>d.to_date = &#39;9999-01-01&#39; AND s.to_date = &#39;9999-01-01&#39;</code>作条件限制； </p><p>STEP3：用<code>GROUP BY</code>将每个部门分为一组，用<code>MAX()</code>函数选取每组中工资最高者； </p><p>STEP4：将<code>salaries</code>用s代替，<code>dept_emp</code>用d代替，最后将<code>MAX(s.salary)</code>用<code>salary</code>代替后输出。</p><pre class=" language-mysql"><code class="language-mysql">SELECT  d.dept_no,  s.emp_no,  MAX(s.salary) AS salary FROM salaries sLEFT JOIN dept_emp d ON s.emp_no = d.emp_no WHERE s.to_date = '9999-01-01'  AND d.to_date = '9999-01-01'GROUP BY d.dept_no;</code></pre><p><strong>扩展：</strong> 如果某部门薪水最大的员工有多人怎么办？ </p><p>STEP1：利用子查询首先创建两张表，一张为<code>MAXsalary</code>，用于存放当前每个部门薪水的最大值；另一张为<code>currentsalary</code>，用于存放当前每个部门所有员工的编号和薪水； </p><p>STEP2：限定条件为两张表的 <code>dept_no</code> 和 <code>salary</code> 相等，这样就可以找出当前每个部门所有薪水等于最大值的员工的相关信息； </p><p>STEP3：以下代码虽然稍长，仔细一看都是基于上面的基础解法变化而来的，中心思想就是绕开 <code>MAX()</code> 的特性限制，运用比较的方法选出多个相同的最大值。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT currentsalary.dept_no,       currentsalary.emp_no,       currentsalary.salary AS salaryFROM -- 创建MAXsalary表用于存放当前每个部门薪水的最大值    (    SELECT d.dept_no, MAX(s.salary) AS salary    FROM salaries AS s     INNER JOIN dept_emp As d    ON d.emp_no = s.emp_no     WHERE d.to_date = '9999-01-01'       AND s.to_date = '9999-01-01'    GROUP BY d.dept_no    ) AS MAXsalary, -- 创建currentsalary表用于存放当前每个部门所有员工的编号和薪水    (    SELECT d.dept_no, s.emp_no, s.salary     FROM salaries AS s INNER JOIN dept_emp As d    ON d.emp_no = s.emp_no     WHERE d.to_date = '9999-01-01'       AND s.to_date = '9999-01-01'    ) AS currentsalary-- 限定条件为两表的dept_no和salary均相等WHERE currentsalary.dept_no = MAXsalary.dept_no  AND currentsalary.salary = MAXsalary.salary</code></pre><h3 id="12-职称的数目"><a href="#12-职称的数目" class="headerlink" title="12 职称的数目"></a>12 职称的数目</h3><p><strong>题目描述</strong>：从<code>titles</code>表获取按照<code>title</code>进行分组，找到每组个数大于等于2的<code>title</code>，给出<code>title</code>以及对应的数目<code>t</code> </p><p><strong>解题思路</strong>：</p><p>使用<code>GROUP BY</code>将<code>title</code>分组，再用<code>HAVING</code>子句找出大于等于2的组，<code>HAVING</code>必须在<code>GROUP BY</code>之后，并且有<code>GROUP BY</code>才能使用<code>HAVING</code>，聚合参数也可以是<code>COUNT(*)</code> 和<code>COUNT(emp_no)</code> ，还要注意 &gt;= 号之间不能有空格，否则会出错。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT title,COUNT(*) FROM titles GROUP BY title HAVING COUNT(*) >= 2</code></pre><p><strong>拓展：</strong> 员工在不同阶段，可能担任了相同的职务，因此在每个<code>title</code>下，<code>emp_no</code>重复的员工需要忽略不计。要对这种情况如何查询？</p><p><strong>解题思路</strong>：</p><p> 先用<code>GROUP BY</code>将表格以<code>title</code>分组，再用<code>COUNT(DISTINCT emp_no)</code>可以统计同一<code>title</code>值且不包含重复<code>emp_no</code>值的记录条数 </p><pre class=" language-mysql"><code class="language-mysql">SELECT title, COUNT(DISTINCT emp_no) AS t FROM titlesGROUP BY title HAVING t >= 2</code></pre><h3 id="13-特定的员工信息"><a href="#13-特定的员工信息" class="headerlink" title="13 特定的员工信息"></a>13 特定的员工信息</h3><p><strong>题目描述</strong>：查找<code>employees</code>表所有<code>emp_no</code>为奇数，且<code>last_name</code>不为Mary的员工信息，并按照<code>hire_date</code>逆序排列</p><p><strong>解题思路</strong>：</p><p> 员工号为奇数，则<code>emp_no</code><strong>取余应为1</strong>，<code>last_name</code>不为Mary，用<code>!=</code>表示，另外注意字符串要用单括号括起来，逆序用<code>DESC</code>。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees WHERE emp_no % 2 = 1  AND last_name != 'Mary'ORDER BY hire_date DESC;</code></pre><h3 id="14-职称的平均工资"><a href="#14-职称的平均工资" class="headerlink" title="14 职称的平均工资"></a>14 职称的平均工资</h3><p><strong>题目描述</strong>： 统计出当前各个<code>title</code>类型对应的员工当前<em>(to_date=’9999-01-01’)</em>薪水对应的平均工资。结果给出<code>title</code>以及平均工资。</p><p><strong>解题思路</strong>：</p><p>使用<code>GROUP BY</code> 对<code>title</code>进行分组，当前用两表<em>to_date=’9999-01-01’</em>进行限定，平均工资用聚合函数avg。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT t.title,avg(salary) AS avgFROM salaries sINNER JOIN titles t ON s.emp_no = t.emp_no WHERE s.to_date = '9999-01-01'  AND t.to_date = '9999-01-01'GROUP BY t.title;</code></pre><h3 id="15-薪水第二多的员工信息"><a href="#15-薪水第二多的员工信息" class="headerlink" title="15 薪水第二多的员工信息"></a>15 薪水第二多的员工信息</h3><p><strong>题目描述</strong>：获取当前<em>(to_date=’9999-01-01’)</em>薪水第二多的员工的<code>emp_no</code>以及其对应的薪水<code>salary</code></p><p><strong>解题思路</strong>：</p><p>STEP1：先在工资表里找出最多工资，再以工资小于最大工资为限定条件，即<code>salary &lt; (SELECT MAX(salary)</code>可以得到排名第二的工资。</p><p>STEP2：再使用<code>MAX(salary)</code>在除去排名第一工资的表里找最大的工资，即找到排名第二的工资。</p><p>STEP3：使用这种这个查询方法，不管工资第一多的员工有多少个都能查到工资第二多的员工，且当工资第二多的员工有多个时也都能查询出来。</p><pre class=" language-mysql"><code class="language-mysql">SELECT emp_no, salary FROM salaries WHERE salary =     (    SELECT MAX(salary)     FROM salaries     WHERE to_date = '9999-01-01'         AND salary <             (            SELECT MAX(salary)             FROM salaries             WHERE to_date = '9999-01-01'             )     );</code></pre><p>更简单一点的写法，使用<code>DISTINCT</code>和<code>LIMIT</code></p><pre class=" language-mysql"><code class="language-mysql">SELECT emp_no,salary FROM salariesWHERE to_date = '9999-01-01'    AND salary = (                  SELECT DISTINCT salary                 FROM salaries                   WHERE to_date = '9999-01-01'                 ORDER BY salary DESC                 LIMIT 1,1                  )</code></pre><h3 id="16-薪水第二多的员工信息-禁用排序"><a href="#16-薪水第二多的员工信息-禁用排序" class="headerlink" title="16 薪水第二多的员工信息(禁用排序)"></a>16 薪水第二多的员工信息(禁用排序)</h3><p><strong>题目描述</strong>：查找当前薪水<em>(to_date=’9999-01-01’)</em>排名第二多的员工编号<code>emp_no</code>、薪水<code>salary</code>、<code>last_name</code>以及<code>first_name</code>，不准使用<code>ORDER BY</code> </p><p><strong>解题思路</strong>：</p><p>本题只需要在上一题的基础上增加一个内联结(左联结)即可将薪水<code>salary</code>、<code>last_name</code>以及<code>first_name</code>查询出来。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT e.emp_no,s.salary,e.last_name,e.first_name FROM employees eINNER JOIN salaries s ON e.emp_no = s.emp_no WHERE  salary =   (    SELECT MAX(salary)     FROM salaries     WHERE to_date = '9999-01-01'         AND salary <             (            SELECT MAX(salary)             FROM salaries             WHERE to_date = '9999-01-01'            )     );</code></pre><p><strong>拓展</strong>：如果将第二高改为第三高，第四高呢？使用<code>MAX</code>函数嵌套的方式过于低效，能否写一种通用的方式来获取第N高的员工信息？</p><p><strong>解题思路</strong>：薪水第二多的意思就是只有一个人比他多，这样只要用<code>salary</code>表自连接，再分组，分组条件为<code>s1.salary &lt; s2.salary</code>。组内条数等于1的那条记录，就正好是第二多。如果要找第三多，那就让<code>HAVING COUNT(*)=1</code>就可以了如果有两个人比那个人多，这两个人的薪水值相同的话，还要用一下<code>DISTINCT</code>关键字去重。</p><pre class=" language-mysql"><code class="language-mysql">SELECT e.emp_no,s.salary,e.last_name,e.first_nameFROM employees eJOIN salaries s ON e.emp_no=s.emp_no     AND s.to_date='9999-01-01'    AND s.salary =         (         SELECT s1.salary         FROM salaries s1         JOIN salaries s2 ON s1.salary < s2.salary          WHERE s1.to_date='9999-01-01'            AND s2.to_date='9999-01-01'         GROUP BY s1.salary         HAVING COUNT(DISTINCT s2.salary) = 1-- 这里写第几高         )</code></pre><h3 id="17-员工对应的部门"><a href="#17-员工对应的部门" class="headerlink" title="17 员工对应的部门"></a>17 员工对应的部门</h3><p><strong>题目描述</strong>：查找所有员工的<code>last_name</code>和<code>first_name</code>以及对应的<code>dept_name</code>，也包括暂时没有分配部门的员工</p><p><strong>解题思路</strong>：</p><p>本题关键在于理清三表之间关联关系。需要使用两次左联结。:</p><p>STEP1：题目要求包括暂时没有分配部门的员工，所以将<code>employees</code>作为主表，使用左联结将其和<code>dept_emp</code>表联结，联结条件为员工编号<code>emp_no</code>，得出所有员工所在部门，并将结果命名为<code>a</code>。</p><p>STEP2：将查询结果<code>a</code>与<code>departments</code>左联结，联结条件为部门编号<code>dept_no</code>，求出部门名字<code>dept_name</code>。</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name, first_name, dept_name FROM  (    SELECT e.last_name, e.first_name, de.dept_no     FROM employees e    LEFT JOIN dept_emp de ON e.emp_no = de.emp_no   ) aLEFT JOIN departments dp ON a.dept_no = dp.dept_no;</code></pre><h3 id="18-薪水涨幅"><a href="#18-薪水涨幅" class="headerlink" title="18 薪水涨幅"></a>18 薪水涨幅</h3><p><strong>题目描述</strong>：查找员工编号<code>emp_no</code>为10001其自入职以来的薪水<code>salary</code>涨幅值<code>growth</code></p><p><strong>解题思路</strong>：</p><p> 对“入职以来的薪水salary涨幅值growth”有两种理解：</p><ul><li><p>员工入职以来工资最大值减去工资最小值。</p></li><li><p>最新一次工资减去入职时的工资，即为涨幅值<code>growth</code>，此种方式更严谨。 </p></li></ul><pre class=" language-mysql"><code class="language-mysql">-- 方法一SELECT MAX(salary) - min(salary) AS growth FROM salaries WHERE emp_no = '10001';-- 方法二SELECT( SELECT salary  FROM salaries  WHERE emp_no = '10001'  ORDER BY to_date DESC  LIMIT 1 ) - (  SELECT salary  FROM salaries  WHERE emp_no = '10001'  ORDER BY to_date ASC  LIMIT 1 ) AS growth;FROM salaries;</code></pre><h3 id="19-所有员工的薪水涨幅"><a href="#19-所有员工的薪水涨幅" class="headerlink" title="19 所有员工的薪水涨幅"></a>19 所有员工的薪水涨幅</h3><p><strong>题目描述</strong>：查找所有员工自入职以来的薪水涨幅情况，给出员工编号<code>emp_no</code>以及其对应的薪水涨幅<code>growth</code>，并按照<code>growth</code>进行升序</p><p><strong>解题思路</strong>：</p><p>STEP1： 先创建两个子查询，分别找出所有员工当前的薪水(子查询a)和所有员工入职时的薪水(如子查询b) </p><p>STEP2： a，b子查询运用的方法都是一样的，联结<code>employees</code>表和<code>salaries</code>表，左联结内联结都可以，子查询a限定条件直接为当前时间’9999-01-01’，子查询b限定条件为入职时间，每个员工入职时间不一样，所以要使用谓词 <code>in</code> 找出在工资表里所有员工对应的最小时间。最后a，b子查询都要对员工编号进行分组。 </p><p>STEP3： 最后将这两个子查询联结，联结条件为<code>a.emp_no = b.emp_no</code>，再按照题目要求对薪水涨幅进行升序排序。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT  a.emp_no,  (a.salary - b.salary) AS growthFROM  (    SELECT e.emp_no,s.salary    FROM employees e    LEFT JOIN salaries s ON e.emp_no = s.emp_no    WHERE s.to_date = '9999-01-01'    GROUP BY s.emp_no  ) a,  (    SELECT e.emp_no,s.salary    FROM employees e    LEFT JOIN salaries s ON e.emp_no = s.emp_no    WHERE s.to_date IN     (        SELECT min(to_date)        FROM salaries s        GROUP BY s.emp_no    )    GROUP BY s.emp_no  ) bWHERE a.emp_no = b.emp_noORDER BY growth ASC;</code></pre><h3 id="20-各部门的工资记录"><a href="#20-各部门的工资记录" class="headerlink" title="20 各部门的工资记录"></a>20 各部门的工资记录</h3><p><strong>题目描述</strong>：统计各个部门的工资记录数，给出部门编码<code>dept_no</code>、部门名称<code>dept_name</code>以及次数SUM</p><p><strong>解题思路</strong>：</p><p> <code>将departments</code>和<code>dept_emp</code>联结(左联结内联结都可以)，得到员工对应的部门编号和部门名称后，再联结<code>salaries</code>表，通过对部门分组，得到每组工资数。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT a.dept_no, a.dept_name, COUNT(*) AS SUMFROM  (    SELECT d.dept_no,de.emp_no,d.dept_name    FROM dept_emp de    LEFT JOIN departments d ON de.dept_no = d.dept_no  ) aINNER JOIN salaries s ON a.emp_no = s.emp_noGROUP BY a.dept_no;</code></pre><h3 id="21-工资排名"><a href="#21-工资排名" class="headerlink" title="21 工资排名"></a>21 工资排名</h3><p><strong>题目描述</strong>：对所有员工的当前<em>(to_date=’9999-01-01’)</em>薪水按照<code>salary</code>进行按照1-N的排名，相同<code>salary</code>并列且按照<code>emp_no</code>升序排列</p><p><strong>解题思路</strong>：</p><p> 经典的排名问题。解决方式分为两种，一种使用开窗函数，另一种不使用。</p><p><strong>开窗函数版本：</strong></p><p>使用窗口函数<code>DENSE_RANK() OVER()</code>函数即可将实现薪水按照<code>salary</code>进行按照1-N的排名，相同<code>salary</code>并列。这里需要注意的是开窗函数在各种SQL查询引擎中都有广泛的使用，但是<strong>MySQL8.0以上的版本才支持开窗函数</strong></p><blockquote><p>窗口函数：&lt;窗口函数&gt; OVER ([PARITITION BY &lt;列清单&gt;] ORDER BY &lt;排序用列清单&gt;) [PARITITION BY &lt;列清单&gt;]可以省略。</p></blockquote><p>在开窗函数中，有3个与排序相关的函数，分别问<code>RANK()、DENSE_RANK()、ROW_NUMBER()</code>：</p><ul><li><p><code>RANK() OVER (ORDER BY &lt;列名&gt;)</code>：计算排序，如果存在相同位次的记录，则会跳过之后的位次。如1,1,1,4</p></li><li><p><code>DENSE_RANK () OVER (ORDER BY &lt;列名&gt;)</code>：计算排序，即使存在相同位次的记录，也不会跳过之后的位次。如1,1,1,2</p></li><li><p><code>ROW_NUMBER () OVER (ORDER BY &lt;列名&gt;)</code>：计算排序，赋予唯一的连续位次。如：1,2,3,4</p></li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT emp_no,salary,       dense_rank() over (ORDER BY salary DESC) AS 'rank'FROM salariesWHERE to_date = '9999-01-01'ORDER BY salary DESC,emp_no ASC;</code></pre><p><strong>普通版本：</strong></p><p>SETP1：利用自联结，复用两张<code>salaries</code>进行比较排名，联结两表条件为to_date = ‘9999-01-01’。</p><p>SETP2：此外重点在于限定条件<code>s1.salary &lt;= s2.salary</code>，在输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary，即计数<code>COUNT(DISTINCT s2.salary)</code>，并以计数结果作为排序结果。</p><p>SETP3：由于两表联结，同样 <code>salary</code> 算作一样的排名，所以需要去重处理<code>COUNT(DISTINCT s2.salary)</code>。</p><p>SETP4：因为使用了合计函数，<code>COUNT</code>只返回一个值，所以必须进行分组查询，最后使用<code>ORDER BY</code>排序。</p><pre class=" language-mysql"><code class="language-mysql">SELECT s1.emp_no,s1.salary,COUNT(DISTINCT s2.salary) AS 'rank'FROM salaries AS s1INNER JOIN salaries AS s2 ON s1.to_date = '9999-01-01'  AND s2.to_date = '9999-01-01'WHERE s1.salary <= s2.salaryGROUP BY s1.emp_noORDER BY s1.salary DESC,s1.emp_no ASC</code></pre><h3 id="22-普通员工的薪水"><a href="#22-普通员工的薪水" class="headerlink" title="22 普通员工的薪水"></a>22 普通员工的薪水</h3><p><strong>题目描述</strong>：获取所有非<code>manager</code>员工当前的薪水情况，给出<code>dept_no</code>、<code>emp_no</code>以及<code>salary</code> ，当前表示<em>to_date=’9999-01-01’</em></p><p><strong>解题思路</strong>：</p><p>先联结员工表和工资表找出所有人的员工编号和工资，再联结部门员工表找出所有员工的编号，最后使用<code>not in</code>找出非<code>manager</code> 的员工。最后记得限定工资表salaries和员工表<code>dept_emp</code>的时间都为<em>to_date=’9999-01-01’</em>。</p><pre class=" language-mysql"><code class="language-mysql">SELECT de.dept_no,e.emp_no,s.salaryFROM employees eINNER JOIN salaries s ON e.emp_no = s.emp_noAND s.to_date = '9999-01-01'INNER JOIN dept_emp de ON e.emp_no = de.emp_noWHERE de.to_date = '9999-01-01'  AND de.emp_no NOT IN (                        SELECT emp_no FROM dept_manager                        );</code></pre><h3 id="23-比领导薪水还高的员工"><a href="#23-比领导薪水还高的员工" class="headerlink" title="23 比领导薪水还高的员工"></a>23 比领导薪水还高的员工</h3><p><strong>题目描述</strong>：获取员工其当前的薪水比其<code>manager</code>当前薪水还高的相关信息，当前表示<em>to_date=’9999-01-01’</em>，查询出 员工的<code>emp_no</code>， 其<code>manager</code>的<code>manager_no</code>， 该员工当前的薪水<code>emp_salary</code>，该员工对应的<code>manager</code>当前的薪水<code>manager_salary</code></p><p><strong>解题思路</strong>：</p><p> 将题目分解为三部分，做好链接即可：</p><ul><li>显示员工以及其<code>Manager</code></li><li>显示员工的薪水以及<code>Manager</code>的薪水</li><li>筛选员工薪酬比<code>Manager</code>高的部分人员，包括经理自己 </li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT de.emp_no,dm.emp_no manager_no,      sa.salary emp_salary,sal.salary manager_salaryFROM dept_emp de,salaries sa,dept_manager dm,salaries salWHERE de.emp_no=sa.emp_no  AND dm.emp_no=sal.emp_no  AND de.dept_no=dm.dept_no  AND de.to_date='9999-01-01'  AND sa.to_date='9999-01-01'  AND dm.to_date='9999-01-01'  AND sal.to_date='9999-01-01'  AND sa.salary>sal.salary</code></pre><h3 id="24-各部门的职称数量"><a href="#24-各部门的职称数量" class="headerlink" title="24 各部门的职称数量"></a>24 各部门的职称数量</h3><p><strong>题目描述</strong>：汇总各个部门当前员工的<code>title</code>类型的分配数目，结果给出部门编号<code>dept_no</code>、<code>dept_name</code>、其当前员工所有的<code>title</code>以及该类型title对应的数目<code>COUNT</code></p><p><strong>解题思路</strong>：</p><p> 重点理解各个部门下各个<code>title</code>类型的汇总。</p><p>先以员工编号为联结条件联结<code>titles</code>表和<code>dept_emp</code>表，得到员工部门编号和员工对应的<code>title</code>类型，再以部门编号为联结条件联结<code>departments</code>表，得到部门名称，最后记得限定<code>titles</code>表和<code>dept_emp</code>表的时间为当前<em>to_date =’9999-01-01’</em>。汇总的是各个部门下各个<code>title</code>类型，所以要先将部门编号进行一次汇总，再将<code>tltle</code>类型进行汇总，聚合函数<code>COUNT</code>的参数为<code>title</code>。</p><pre class=" language-mysql"><code class="language-mysql">SELECT de.dept_no,dp.dept_name,       t.title,COUNT(t.title) AS COUNTFROM titles tLEFT JOIN dept_emp de ON t.emp_no = de.emp_no  AND t.to_date = '9999-01-01'  AND de.to_date = '9999-01-01'INNER JOIN departments dp ON de.dept_no = dp.dept_noGROUP BY de.dept_no, t.title</code></pre><h3 id="25-查看姓名"><a href="#25-查看姓名" class="headerlink" title="25 查看姓名"></a>25 查看姓名</h3><p><strong>题目描述</strong>： 将<code>employees</code>表中的所有员工的<code>last_name</code>和<code>first_name</code>通过(<code>-</code>)连接起来。</p><p><strong>解题思路</strong>：</p><p> 考察字符串拼接函数<code>CONCAT(&lt;列1&gt;,&lt;列2&gt;…)</code>，多个列或字符串之间用个逗号隔开，这里last_name和first_name通过(<code>-</code>)连接，符号<code>-</code>要用双引号括起来。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(last_name,"-",first_name) AS nameFROM employees;</code></pre><h3 id="26-查看字符出现的次数"><a href="#26-查看字符出现的次数" class="headerlink" title="26 查看字符出现的次数"></a>26 查看字符出现的次数</h3><p><strong>题目描述</strong>：  查找字符串<code>&#39;10,A,B&#39;</code> 中逗号<code>&#39;,&#39;</code>出现的次数<code>cnt</code></p><p><strong>解题思路</strong>：</p><p>STEP1：巧用<code>length</code>函数和<code>replace</code>，<code>length</code>函数计算字符串的长度，<code>length(&quot;10,A,B&quot;)</code>算出整个字符串的长度。</p><p>STEP2：使用<code>replace</code>将 ,逗号替换为空，那么整个字符串减少的长度等于逗号的长度，两者相减就是 , 出现的次数。</p><pre class=" language-mysql"><code class="language-mysql">SELECT (length("10,A,B") - length(replace("10,A,B", ",", ""))) as cnt;</code></pre><h3 id="27-平均工资-排除最大与最小值"><a href="#27-平均工资-排除最大与最小值" class="headerlink" title="27 平均工资(排除最大与最小值)"></a>27 平均工资(排除最大与最小值)</h3><p><strong>题目描述</strong>：   查找排除当前最大、最小<code>salary</code>之后的员工的平均工资 </p><p><strong>解题思路</strong>：</p><p> 用两个子查询找出最大工资和最小工资，再用<code>not in</code>去除最大工资和最小工资，最后记得限定时间为当前。</p><pre class=" language-mysql"><code class="language-mysql">SELECT AVG(salary) AS avg_salaryFROM salariesWHERE salary NOT IN    (SELECT MAX(salary) FROM salaries WHERE to_date = '9999-01-01')AND salary NOT IN    (SELECT MAX(salary) FROM salaries WHERE to_date = '9999-01-01')AND to_date = '9999-01-01';</code></pre><h3 id="28-员工的奖金"><a href="#28-员工的奖金" class="headerlink" title="28 员工的奖金"></a>28 员工的奖金</h3><p><strong>题目描述</strong>：  获取有奖金的员工相关信息，查询出<code>emp_no</code>、<code>first_name</code>、<code>last_name</code>、奖金类型<code>btype</code>、对应的当前薪水情况<code>salary</code>以及奖金金额<code>bonus</code>。</p><p><code>bonus</code>类型<code>btype</code>为<code>1</code>则其奖金为薪水<code>salary</code>的<code>10%</code>，<code>btype</code>为<code>2</code>其奖金为薪水的<code>20%</code>，其他类型均为薪水的<code>30%</code>。当前薪水表示*to_date=’9999-01-01’ *</p><p><strong>解题思路</strong>：</p><p>STEP1：使用<code>CASE WHEN</code>表达式对奖金进行行列转换，这里使用的是<code>CASE WHEN &lt;列名&gt; then …</code>的搜索<code>case</code>表达式，最后要记得使用<code>end</code>结束case，并将结果重命名为BONUS。</p><p>STEP2：使用员工编号为限定条件将三表联结查询，还有限定时间为当前。</p><pre class=" language-mysql"><code class="language-mysql">SELECT eb.emp_no,e.first_name,       e.last_name,eb.btype,s.salary,       (CASE WHEN eb.btype = 1 then s.salary * 0.1             when eb.btype = 2 then s.salary * 0.2             else s.salary * 0.3 end       ) as bonusFROM salaries s,emp_bonus eb,employees eWHERE eb.emp_no = s.emp_no AND eb.emp_no = e.emp_no AND s.to_date = '9999-01-01';</code></pre><h3 id="29-薪水的累计"><a href="#29-薪水的累计" class="headerlink" title="29 薪水的累计"></a>29 薪水的累计</h3><p><strong>题目描述</strong>：按照<code>salary</code>的累计和<code>running_total</code>，其中<code>running_total</code>为前两个员工的<code>salary</code>累计和，其他以此类推。 具体结果如下表展示。 </p><table><thead><tr><th align="left">emp_no</th><th align="left">salary</th><th align="left">running_total</th></tr></thead><tbody><tr><td align="left">10001</td><td align="left">88958</td><td align="left">88958</td></tr><tr><td align="left">10002</td><td align="left">72527</td><td align="left">161485</td></tr><tr><td align="left">10003</td><td align="left">43311</td><td align="left">204796</td></tr><tr><td align="left">10004</td><td align="left">74057</td><td align="left">278853</td></tr><tr><td align="left">10005</td><td align="left">94692</td><td align="left">373545</td></tr><tr><td align="left">10006</td><td align="left">43311</td><td align="left">416856</td></tr><tr><td align="left">10007</td><td align="left">88070</td><td align="left">504926</td></tr><tr><td align="left">10009</td><td align="left">95409</td><td align="left">600335</td></tr><tr><td align="left">10010</td><td align="left">94409</td><td align="left">694744</td></tr><tr><td align="left">10011</td><td align="left">25828</td><td align="left">720572</td></tr></tbody></table><p><strong>窗口函数版本解题思路：</strong></p><p>STEP1：本题关键在于把<code>SUM</code>聚合函数作为窗口函数使用，所有聚合函数都能用做窗口函数，其语法和专用窗口函数完全相同。</p><p><code>SUM(&lt;汇总列&gt;) over(&lt;排序列&gt;) as 别名</code>；</p><p>STEP2：光看题目“前两个员工的<code>salary</code>累计和”不是很好理解，结合输出格式可以理解为<code>running_total</code>列是逐个员工的工资的累计和，每一行的工资都是前面所有行的工资总计。</p><p>STEP3：这有一个小bug，题目没有限定时间为当前，而按照输出格式来看和通过情况来看，只有限定时间为当前’9999-01-01’才能符合输出格式，才能通过，一开始考虑用员工分组，但是员工分组得到的结果并非题目本意，必须限定时间为当前。</p><pre class=" language-mysql"><code class="language-mysql">SELECT emp_no,salary,sum(salary) over(ORDER BY emp_no) as running_totalFROM salariesWHERE to_date= '9999-01-01';</code></pre><p><strong>普通查询版本解题思路：</strong></p><p>利用复表查询，以及<code>running_total</code>等于逐个员工的工资的累计和，即找出在表2中小于等于表1员工编号的所有员工工资进行求和，最后记得限定时间为当前，且要按照<code>emp_no</code>升序排序。</p><pre class=" language-mysql"><code class="language-mysql">SELECT s1.emp_no, s1.salary,(SELECT sum(s2.salary)  FROM salaries s2 WHERE s2.emp_no <= s1.emp_no    AND s2.to_date = '9999-01-01') as running_totalFROM salaries s1 WHERE s1.to_date = '9999-01-01' ORDER BY s1.emp_no;</code></pre><h3 id="30-奇数行的员工姓名"><a href="#30-奇数行的员工姓名" class="headerlink" title="30 奇数行的员工姓名"></a>30 奇数行的员工姓名</h3><p><strong>题目描述</strong>：对于<code>employees</code>表中，给出奇数行的<code>first_name</code> </p><p><strong>解题思路</strong>：</p><p> STEP1：窗口函数<code>row_number</code>的作用是赋予唯一的连续位次。巧用窗口函数<code>row_number</code>对数据进行行排序，对<code>first_name</code>进行排序，将得到的位次命名为row_num。</p><p>STEP2：用求余函数找出奇数行。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT a.first_nameFROM (SELECT emp_no, first_name,              row_number() over(ORDER BY first_name) as row_num      FROM employees) aWHERE row_num % 2 = 1ORDER BY emp_no;</code></pre><h2 id="五、进阶题目"><a href="#五、进阶题目" class="headerlink" title="五、进阶题目"></a>五、进阶题目</h2><p>本节题目只提供表结构且有一定难度,其中部分题目与四中类似，做不出来的小伙伴也不要灰心呦。可以先写下自己的思考过程再对照答案，会更有收获。</p><h3 id="1、连续出现的数字-查连续出现N次的数据"><a href="#1、连续出现的数字-查连续出现N次的数据" class="headerlink" title="1、连续出现的数字(查连续出现N次的数据)"></a>1、连续出现的数字(查连续出现N次的数据)</h3><h4 id="1-1、题目描述"><a href="#1-1、题目描述" class="headerlink" title="1.1、题目描述"></a>1.1、题目描述</h4><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><table><thead><tr><th>Id</th><th>Num</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>2</td></tr><tr><td>5</td><td>1</td></tr><tr><td>6</td><td>2</td></tr><tr><td>7</td><td>2</td></tr></tbody></table><p>例如，给定上面的 <code>Logs</code> 表， <code>1</code>是唯一连续出现至少三次的数字。</p><table><thead><tr><th>ConsecutiveNums</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table><h4 id="1-2、解题方法"><a href="#1-2、解题方法" class="headerlink" title="1.2、解题方法"></a>1.2、解题方法</h4><p> 连续出现的意味着相同数字的 Id 是连着的，由于这题问的是至少连续出现 3 次，我们使用 <code>Logs</code>并检查是否有 3 个连续的相同数字。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT *FROM    Logs l1,    Logs l2,    Logs l3WHERE    l1.Id = l2.Id - 1    AND l2.Id = l3.Id - 1    AND l1.Num = l2.Num    AND l2.Num = l3.Num;</code></pre><table><thead><tr><th>Id</th><th>Num</th><th>Id</th><th>Num</th><th>Id</th><th>Num</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>1</td><td>3</td><td>1</td></tr></tbody></table><p> 注意：前两列来自 l1 ，接下来两列来自 l2 ，最后两列来自 l3 。 </p><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT    l1.Num AS ConsecutiveNumsFROM    Logs l1,    Logs l2,    Logs l3WHERE    l1.Id = l2.Id - 1    AND l2.Id = l3.Id - 1    AND l1.Num = l2.Num    AND l2.Num = l3.Num</code></pre><p><strong>思考一下，如果是将连续重复的数字的整条记录查询出来应该怎么做呢？</strong></p><h3 id="2、部门工资前三高的所有员工-分组求前N个"><a href="#2、部门工资前三高的所有员工-分组求前N个" class="headerlink" title="2、部门工资前三高的所有员工(分组求前N个)"></a>2、部门工资前三高的所有员工(分组求前N个)</h3><h4 id="2-1、题目描述"><a href="#2-1、题目描述" class="headerlink" title="2.1、题目描述"></a>2.1、题目描述</h4><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的工号 <code>Id</code>，姓名 <code>Name</code>，工资 <code>Salary</code> 和部门编号 <code>DepartmentId</code> 。</p><table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>DepartmentId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>85000</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td></tr><tr><td>5</td><td>Janet</td><td>69000</td><td>1</td></tr><tr><td>6</td><td>Randy</td><td>85000</td><td>1</td></tr><tr><td>7</td><td>Will</td><td>70000</td><td>1</td></tr></tbody></table><p><code>Department</code> 表包含公司所有部门的信息。</p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>IT</td></tr><tr><td>2</td><td>Sales</td></tr></tbody></table><p>编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：</p><table><thead><tr><th>Department</th><th>Employee</th><th>Salary</th></tr></thead><tbody><tr><td>IT</td><td>Max</td><td>90000</td></tr><tr><td>IT</td><td>Randy</td><td>85000</td></tr><tr><td>IT</td><td>Joe</td><td>85000</td></tr><tr><td>IT</td><td>Will</td><td>70000</td></tr><tr><td>Sales</td><td>Henry</td><td>80000</td></tr><tr><td>Sales</td><td>Sam</td><td>60000</td></tr></tbody></table><p>解释：</p><p>IT 部门中，Max 获得了最高的工资，RANDy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门(Sales)只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p><h4 id="2-2、解题方法"><a href="#2-2、解题方法" class="headerlink" title="2.2、解题方法"></a>2.2、解题方法</h4><p>1、我们先找出公司里前 3 高的薪水，意思是不超过三个值比这些值大</p><pre class=" language-mysql"><code class="language-mysql">SELECT e1.Salary FROM Employee AS e1WHERE 3 >         (SELECT COUNT(DISTINCT e2.Salary)          FROM    Employee AS e2           WHERE    e1.Salary < e2.Salary     AND e1.DepartmentId = e2.DepartmentId) ;</code></pre><p>2、再把表 <code>Department</code> 和表 <code>Employee</code> 连接，获得各个部门工资前三高的员工。 </p><p>举例说明：<br>当 e1 = e2 = [50,100,150,200,250]</p><p>e1.Salary = 50，e2.Salary 可以取值 [100,150,200,250]，COUNT(DISTINCT e2.Salary) = 4</p><p>e1.Salary = 100，e2.Salary 可以取值 [150,200,250]，COUNT(DISTINCT e2.Salary) = 3</p><p>e1.Salary = 150，e2.Salary 可以取值 [200,250]，COUNT(DISTINCT e2.Salary) = 2</p><p>e1.Salary = 200，e2.Salary 可以取值 [250]，COUNT(DISTINCT e2.Salary) = 1</p><p>e1.Salary = 250，e2.Salary 可以取值 []，COUNT(DISTINCT e2.Salary) = 0</p><p>最后 3 &gt; COUNT(DISTINCT e2.Salary)，所以 e1.Salary 可取值为 [150,200,250]，即集合前 3 高的薪水</p><p>再把表 Department 和表 Employee 连接，获得各个部门工资前三高的员工。</p><pre class=" language-mysql"><code class="language-mysql">SELECT    Department.NAME AS Department,    e1.NAME AS Employee,    e1.Salary AS Salary FROM    Employee AS e1,Department WHERE    e1.DepartmentId = Department.Id     AND 3 > (SELECT  COUNT( DISTINCT e2.Salary )              FROM    Employee AS e2              WHERE    e1.Salary < e2.Salary     AND e1.DepartmentId = e2.DepartmentId     ) ORDER BY Department.NAME,Salary DESC;</code></pre><h3 id="3、汇总成绩"><a href="#3、汇总成绩" class="headerlink" title="3、汇总成绩"></a>3、汇总成绩</h3><h4 id="3-1、题目描述"><a href="#3-1、题目描述" class="headerlink" title="3.1、题目描述"></a>3.1、题目描述</h4><p>已知<code>score</code>表结构为下方所示:</p><table><thead><tr><th>name</th><th>subject</th><th>score</th></tr></thead><tbody><tr><td>张三</td><td>语文</td><td>80</td></tr><tr><td>李四</td><td>语文</td><td>90</td></tr><tr><td>张三</td><td>数学</td><td>80</td></tr><tr><td>李四</td><td>数学</td><td>70</td></tr><tr><td>张三</td><td>英语</td><td>90</td></tr><tr><td>李四</td><td>英语</td><td>50</td></tr></tbody></table><p>要求查询结果为：</p><table><thead><tr><th>name</th><th>chinese</th><th>math</th><th>english</th><th>score</th></tr></thead><tbody><tr><td>张三</td><td>80</td><td>80</td><td>90</td><td>250</td></tr><tr><td>李四</td><td>90</td><td>70</td><td>50</td><td>210</td></tr></tbody></table><h4 id="3-2、解题方法"><a href="#3-2、解题方法" class="headerlink" title="3.2、解题方法"></a>3.2、解题方法</h4><ol><li>SUM-CASE方法</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT name    ,SUM(CASE subject WHEN '语文' THEN score ELSE 0 END) AS chinese    ,SUM(CASE subject WHEN '数学' THEN score ELSE 0 end) as math    ,SUM(CASE subject WHEN '英语' THEN score ELSE 0 end) as english    ,SUM(socre)as score  FROM score GROUP BY name</code></pre><ol start="2"><li>IF方法</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT name ,    sum(if(subject='语文',score,0)) as chinese,    sum(if(subject='数学',score,0))as math,     sum(if(subject='英语',score,0))as english,    SUM(score) as 总分FROM score GROUP BY name     </code></pre><h3 id="4、换座位"><a href="#4、换座位" class="headerlink" title="4、换座位"></a>4、换座位</h3><h4 id="4-1、题目描述"><a href="#4-1、题目描述" class="headerlink" title="4.1、题目描述"></a>4.1、题目描述</h4><p>小美是一所中学的信息科技老师，她有一张 <code>seat</code> 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 <code>id</code> 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><p> 示例：</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Abbot</td></tr><tr><td>2</td><td>Doris</td></tr><tr><td>3</td><td>Emerson</td></tr><tr><td>4</td><td>Green</td></tr><tr><td>5</td><td>Jeames</td></tr></tbody></table><p>假如数据输入的是上表，则输出结果如下：</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Doris</td></tr><tr><td>2</td><td>Abbot</td></tr><tr><td>3</td><td>Green</td></tr><tr><td>4</td><td>Emerson</td></tr><tr><td>5</td><td>Jeames</td></tr></tbody></table><blockquote><p>注意：如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><p>题目来源：<a href="https://leetcode-cn.com/problems/exchange-seats" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="4-2、解题方法"><a href="#4-2、解题方法" class="headerlink" title="4.2、解题方法"></a>4.2、解题方法</h4><ol><li>case关键字解法(最容易理解)</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT (CASEWHEN MOD(id,2) = 1 AND id = (SELECT COUNT(*) FROM seat) THEN idWHEN MOD(id,2) = 1 THEN id|1ElSE id-1END) AS id, studentFROM seatORDER BY id;</code></pre><ol start="2"><li>左连接</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT a.id,ifnull(b.student,a.student) as student FROM seat as a LEFT JOIN seat as b ON (a.id%2=1 && a.id=b.id-1) || (a.id%2=0 && a.id=b.id|1) ORDER BY a.id;</code></pre><ol start="3"><li>对id排序</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT if(id%2=0,id-1,if(id=cnt,id,id|1)) as id,student FROM (       SELECT COUNT(*) as cnt FROM seat)as a,seat ORDER BY id;</code></pre><ol start="4"><li><p>异或</p><p>0^1=1 , 1^1=0 ,2^1=3 ,3^1=2  </p></li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT b.id,a.student FROM seat as a,seat as b,(SELECT COUNT(*) as cnt FROM seat) as c WHERE b.id=1^(a.id-1)|1 || (c.cnt%2 && b.id=c.cnt && a.id=c.cnt);</code></pre><h3 id="5、体育馆的人流量-与第一题类似"><a href="#5、体育馆的人流量-与第一题类似" class="headerlink" title="5、体育馆的人流量(与第一题类似)"></a>5、体育馆的人流量(与第一题类似)</h3><h4 id="5-1、题目描述"><a href="#5-1、题目描述" class="headerlink" title="5.1、题目描述"></a>5.1、题目描述</h4><p>X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：<code>序号 (id)</code>、<code>日期 (visit_date)</code>、 <code>人流量 (people)</code>。</p><p>请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。</p><p>例如，表 <code>stadium</code>：</p><table><thead><tr><th>id</th><th>visit_date</th><th>people</th></tr></thead><tbody><tr><td>1</td><td>2017-01-01</td><td>10</td></tr><tr><td>2</td><td>2017-01-02</td><td>109</td></tr><tr><td>3</td><td>2017-01-03</td><td>150</td></tr><tr><td>4</td><td>2017-01-04</td><td>99</td></tr><tr><td>5</td><td>2017-01-05</td><td>145</td></tr><tr><td>6</td><td>2017-01-06</td><td>1455</td></tr><tr><td>7</td><td>2017-01-07</td><td>199</td></tr><tr><td>8</td><td>2017-01-08</td><td>188</td></tr></tbody></table><p>对于上面的示例数据，输出为：</p><table><thead><tr><th>id</th><th>visit_date</th><th>people</th></tr></thead><tbody><tr><td>5</td><td>2017-01-05</td><td>145</td></tr><tr><td>6</td><td>2017-01-06</td><td>1455</td></tr><tr><td>7</td><td>2017-01-07</td><td>199</td></tr><tr><td>8</td><td>2017-01-08</td><td>188</td></tr></tbody></table><blockquote><p>提示：每天只有一行记录，日期随着 id 的增加而增加。</p><p>来源：<a href="https://leetcode-cn.com/problems/human-traffic-of-stadium" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="5-2、解题方法"><a href="#5-2、解题方法" class="headerlink" title="5.2、解题方法"></a>5.2、解题方法</h4><p>与第一题相似，查找连续的三天，以下是最直观的思考：</p><pre class=" language-mysql"><code class="language-mysql">SELECT a.*FROM stadium as a,stadium as b,stadium as cWHERE (a.id = b.id-1 AND b.id|1 = c.id)   AND (a.people>=100 AND b.people>=100 AND c.people>=100);</code></pre><p>但是这样输出会有问题，比如 5,6,7,8 号人流量不少于100，但是只输出了 5,6号，根本原因在于，我们将 a 的 id 设为三个连续值中最小值，所以只返回了每 3 个连续值中最小的一个，同理可想到，我们再将 a 的 id 设为三个连续值中中间值和最大值，可以得到全部的连续 3 个值</p><pre class=" language-mysql"><code class="language-mysql">SELECT a.*FROM stadium as a,stadium as b,stadium as cWHERE ((a.id = b.id-1 AND b.id|1 = c.id) or       (a.id-1 = b.id AND a.id|1 = c.id) or       (a.id-1 = c.id AND c.id-1 = b.id))  AND (a.people>=100 AND b.people>=100 AND c.people>=100);</code></pre><p>但是这样还有个问题，比如 5,6,7,8，6 既是 5,6,7 的中间值也是 6,7,8 的最小值，所以还要去重，也许 id 不按序排列，再排序 id，最终得到答案</p><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT a.*FROM stadium as a,stadium as b,stadium as cWHERE ((a.id = b.id-1 AND b.id|1 = c.id) or       (a.id-1 = b.id AND a.id|1 = c.id) or       (a.id-1 = c.id AND c.id-1 = b.id))  AND (a.people>=100 AND b.people>=100 AND c.people>=100)ORDER BY a.id;</code></pre><h3 id="6、第N高的薪水"><a href="#6、第N高的薪水" class="headerlink" title="6、第N高的薪水"></a>6、第N高的薪水</h3><h4 id="6-1、题目描述"><a href="#6-1、题目描述" class="headerlink" title="6.1、题目描述"></a>6.1、题目描述</h4><p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水(Salary)。</p><table><thead><tr><th>Id</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>5000</td></tr><tr><td>2</td><td>7000</td></tr><tr><td>3</td><td>7000</td></tr><tr><td>4</td><td>9000</td></tr><tr><td>5</td><td>9000</td></tr></tbody></table><p>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 7000。</p><table><thead><tr><th align="left">getNthHighestSalary(2)</th></tr></thead><tbody><tr><td align="left">7000</td></tr></tbody></table><h4 id="6-2、解题方法"><a href="#6-2、解题方法" class="headerlink" title="6.2、解题方法"></a>6.2、解题方法</h4><ol><li>对薪水排序后直接查第N个</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT salary FROM EmployeeWHERE  salary = (SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1,1)</code></pre><ol start="2"><li>依次将最高的薪水排除</li></ol><pre class=" language-mysql"><code class="language-mysql">-- 以N=2为例SELECT MAX(salary) FROM Employee  WHERE salary<>(SELECT MAX(salary) FROM Employee)</code></pre><ol start="3"><li>稍微难理解一点的写法</li></ol><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT Salary FROM Employee e     WHERE N = (        SELECT COUNT(DISTINCT Salary)             FROM Employee                 WHERE Salary >= e.Salary )</code></pre><p>解释：用表Employee的所有不重复的Salary值A 依次与该表的所有不重复的Salary值B 进行比对，找到符合A&gt;=B条件的记录数量为N的A值。</p><h3 id="7、交换性别-一条语句交换两个值"><a href="#7、交换性别-一条语句交换两个值" class="headerlink" title="7、交换性别(一条语句交换两个值)"></a>7、交换性别(一条语句交换两个值)</h3><h4 id="7-1、题目描述"><a href="#7-1、题目描述" class="headerlink" title="7.1、题目描述"></a>7.1、题目描述</h4><p>给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求只使用一个更新(Update)语句，并且没有中间的临时表。</p><p>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。</p><p>例如：</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>m</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>f</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>m</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>f</td><td>500</td></tr></tbody></table><p>运行你所编写的更新语句之后，将会得到以下表:</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>f</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>m</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>f</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>m</td><td>500</td></tr></tbody></table><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/swap-salary" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="7-2、解题方法"><a href="#7-2、解题方法" class="headerlink" title="7.2、解题方法"></a>7.2、解题方法</h4><ol><li>CASE WHEN</li></ol><pre class=" language-mysql"><code class="language-mysql">UPDATE salarySETsex = CASE sexWHEN 'm' THEN 'f'ELSE 'm'END;</code></pre><ol start="2"><li>if</li></ol><pre class=" language-mysql"><code class="language-mysql">update salary set sex=if(sex = 'f', 'm','f');</code></pre><ol start="3"><li>ASCII码转换</li></ol><pre class=" language-mysql"><code class="language-mysql">update salary set sex = char(ascii('m') + ascii('f') - ascii(sex));</code></pre><h3 id="8、行程和用户"><a href="#8、行程和用户" class="headerlink" title="8、行程和用户"></a>8、行程和用户</h3><h4 id="8-1、题目描述"><a href="#8-1、题目描述" class="headerlink" title="8.1、题目描述"></a>8.1、题目描述</h4><p><code>Trips</code> 表中存所有出租车的行程信息。每段行程有唯一键 <code>Id</code>，<code>Client_Id</code> 和 <code>Driver_Id</code> 是 <code>Users</code> 表中 <code>Users_Id</code> 的外键。<code>Status</code> 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。</p><table><thead><tr><th>Id</th><th>Client_Id</th><th>Driver_Id</th><th>City_Id</th><th>Status</th><th>Request_at</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>10</td><td>1</td><td>completed</td><td>2013-10-01</td></tr><tr><td>2</td><td>2</td><td>11</td><td>1</td><td>cancelled_by_driver</td><td>2013-10-01</td></tr><tr><td>3</td><td>3</td><td>12</td><td>6</td><td>completed</td><td>2013-10-01</td></tr><tr><td>4</td><td>4</td><td>13</td><td>6</td><td>cancelled_by_client</td><td>2013-10-01</td></tr><tr><td>5</td><td>1</td><td>10</td><td>1</td><td>completed</td><td>2013-10-02</td></tr><tr><td>6</td><td>2</td><td>11</td><td>6</td><td>completed</td><td>2013-10-02</td></tr><tr><td>7</td><td>3</td><td>12</td><td>6</td><td>completed</td><td>2013-10-02</td></tr><tr><td>8</td><td>2</td><td>12</td><td>12</td><td>completed</td><td>2013-10-03</td></tr><tr><td>9</td><td>3</td><td>10</td><td>12</td><td>completed</td><td>2013-10-03</td></tr><tr><td>10</td><td>4</td><td>13</td><td>12</td><td>cancelled_by_driver</td><td>2013-10-03</td></tr></tbody></table><p><code>Users</code> 表存所有用户。每个用户有唯一键 <code>Users_Id</code>。<code>Banned</code> 表示这个用户是否被禁止，<code>Role</code> 则是一个表示(‘client’, ‘driver’, ‘partner’)的枚举类型。</p><table><thead><tr><th>Users_Id</th><th>Banned</th><th>Role</th></tr></thead><tbody><tr><td>1</td><td>No</td><td>client</td></tr><tr><td>2</td><td>Yes</td><td>client</td></tr><tr><td>3</td><td>No</td><td>client</td></tr><tr><td>4</td><td>No</td><td>client</td></tr><tr><td>10</td><td>No</td><td>driver</td></tr><tr><td>11</td><td>No</td><td>driver</td></tr><tr><td>12</td><td>No</td><td>driver</td></tr><tr><td>13</td><td>No</td><td>driver</td></tr></tbody></table><p>写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率(Cancellation Rate)保留两位小数。</p><p>取消率的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)</p><table><thead><tr><th>Day</th><th>Cancellation Rate</th></tr></thead><tbody><tr><td>2013-10-01</td><td>0.33</td></tr><tr><td>2013-10-02</td><td>0.00</td></tr><tr><td>2013-10-03</td><td>0.50</td></tr></tbody></table><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/trips-AND-users" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="8-2、解题方法"><a href="#8-2、解题方法" class="headerlink" title="8.2、解题方法"></a>8.2、解题方法</h4><pre class=" language-mysql"><code class="language-mysql">SELECT a.Request_at as Day,round(sum(case status when 'completed' then 0 else 1 end)/COUNT(*),2) as 'CancellatiON Rate'  FROM Trips a         LEFT JOIN Users b ON a.Client_Id  =b.Users_Id          LEFT JOIN Users c ON a.Driver_Id  =c.Users_Id              WHERE a.Request_at between '2013-10-01' AND '2013-10-03'                AND b.Banned ='No' AND c.Banned ='No'                    GROUP BY a.Request_at</code></pre><h3 id="9、上升的温度"><a href="#9、上升的温度" class="headerlink" title="9、上升的温度"></a>9、上升的温度</h3><h4 id="9-1、题目描述"><a href="#9-1、题目描述" class="headerlink" title="9.1、题目描述"></a>9.1、题目描述</h4><p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前(昨天的)日期相比温度更高的所有日期的 <code>Id</code>。</p><table><thead><tr><th>Id(INT)</th><th>RecordDate(DATE)</th><th>Temperature(INT)</th></tr></thead><tbody><tr><td>1</td><td>2015-01-01</td><td>10</td></tr><tr><td>2</td><td>2015-01-02</td><td>25</td></tr><tr><td>3</td><td>2015-01-03</td><td>20</td></tr><tr><td>4</td><td>2015-01-04</td><td>30</td></tr></tbody></table><p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p><table><thead><tr><th>Id</th></tr></thead><tbody><tr><td>2</td></tr><tr><td>4</td></tr></tbody></table><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/rising-temperature" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="9-2、解题方法"><a href="#9-2、解题方法" class="headerlink" title="9.2、解题方法"></a>9.2、解题方法</h4><p>1、直接使用日期加减然后关联</p><pre class=" language-mysql"><code class="language-mysql">SELECT w1.IdFROM Weather w1 JOIN Weather w2ON w1.RecordDate = w2.RecordDate+1WHERE w1.Temperature > w2.Temperature</code></pre><p>2、使用<code>datediff</code>函数</p><pre class=" language-mysql"><code class="language-mysql">SELECTweather.id AS 'Id'FROMweatherJOINweather w ON DATEDIFF(weather.date, w.date) = 1AND weather.Temperature > w.Temperature</code></pre><h3 id="10、分数排名-经典的排名问题"><a href="#10、分数排名-经典的排名问题" class="headerlink" title="10、分数排名(经典的排名问题)"></a>10、分数排名(经典的排名问题)</h3><h4 id="10-1、题目描述"><a href="#10-1、题目描述" class="headerlink" title="10.1、题目描述"></a>10.1、题目描述</h4><p>编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名(<code>Rank</code>)相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p><table><thead><tr><th>Id</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>3.50</td></tr><tr><td>2</td><td>3.65</td></tr><tr><td>3</td><td>4.00</td></tr><tr><td>4</td><td>3.85</td></tr><tr><td>5</td><td>4.00</td></tr><tr><td>6</td><td>3.65</td></tr></tbody></table><p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回(按分数从高到低排列)：</p><table><thead><tr><th>Score</th><th>Rank</th></tr></thead><tbody><tr><td>4.00</td><td>1</td></tr><tr><td>4.00</td><td>1</td></tr><tr><td>3.85</td><td>2</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.50</td><td>4</td></tr></tbody></table><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/rank-scores" target="_blank" rel="noopener">力扣(LeetCode)</a></p></blockquote><h4 id="10-2、解题方法"><a href="#10-2、解题方法" class="headerlink" title="10.2、解题方法"></a>10.2、解题方法</h4><p>1、直接使用SQL书写</p><pre class=" language-mysql"><code class="language-mysql">SELECT a.Score as Score,(SELECT COUNT(DISTINCT b.Score) FROM Scores b WHERE b.Score >= a.Score) as RankFROM Scores aORDER BY a.Score DESC</code></pre><p>2、使用开窗函数</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年理财记录</title>
      <link href="/2020/02/14/2020%E5%B9%B4%E6%8A%95%E8%B5%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/02/14/2020%E5%B9%B4%E6%8A%95%E8%B5%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年投资历程"><a href="#2020年投资历程" class="headerlink" title="2020年投资历程"></a>2020年投资历程</h1><p>之前的懒得整理了，就从2月14号开始记录吧。</p><h2 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h2><h3 id="2-14-第一次记录"><a href="#2-14-第一次记录" class="headerlink" title="2.14 第一次记录"></a>2.14 第一次记录</h3><p>第一天记录，多写一点</p><p>今天周五，A股的行情从开盘的极度悲观到第二天的超跌反弹，进入了一个相对平静的阶段。疫情对于盘面的影响逐渐开始减弱，因为疫情导致的对口罩、防疫、云办公等后面一系列上下游产业公司的炒作也基本告一段落，但是还没有明显的主流板块做行情的领头羊。</p><p>创业板已经让人看不懂了，大部分科技股估计也难以复现节前的疯狂，防疫概念肯定是不能碰了，云办公的一系列公司也已经出现了超买现象，在接下来的一段时间，A股可能会根据业绩、估值、热点题材等方面去选一个方向发展，或者是轮动，只横不涨。 </p><p>短期来看，现在没有趋势性下跌的风险，估计会横盘或者震荡式调整，因为8连阳是需要时间去消化的，调整是为了以后更好的上升，关注的几个做超短的公众号也空仓然后买入了国债逆回购，这些长期在涨停板上搏杀的人对市场的嗅觉都异常敏锐，因此在这种速度切换，板块轮动的过程中，做好防守就ok了；从长期上看，中国股市目前仍然处于估值的相对低位，具备长期投资价值，选一些质地优良的股票，耐得住寂寞，才能守得住繁华。</p><p>下面说一下2020年我看好的几个方向：==TMT==、新能源产业链(特斯拉)、光伏。这几个方向我都会专门写文章来说明我的思路。</p><p>在此说一下我的投资逻辑，现在这个阶段我不想花太多的时间放在理财上，我觉得在我这个年纪最重要的是先投资自己。另外就是现在尚处于财富的原始积累阶段，尽量的开源节流。对于理财，我大致把钱分成了一下几块：</p><ol><li>余额宝留少量钱的钱足够日常生活</li><li>大概百分之20%存到了京东金融(年化4.5%左右)，作为日常储蓄</li><li>超过百分之60%的钱用来买基金，让专业的人做专业的事</li><li>剩下的钱用来炒股</li></ol><p>另外我的投资风格非常的保守，总体来说最主要就是两个字：便宜。我比较喜欢选一些质地优良且相对便宜的公司或者很有潜力的行业，买入股票或者基金，等待业绩反转。虽然这种方式可能总体的收益不高，但是让我亏钱也不大可能。</p><p>最后说下自己目前的持仓与逻辑：</p><p>基金部分：在之前的就不说了，从今年一月开始我逐步买入了<strong>基建、水泥、钢铁、煤炭、地产、科技</strong>。</p><p>其中基建、水泥、钢铁、煤炭这几个方面的逻辑都相同，就是之前说的，便宜！这些行业现在也没啥人关注，估值个个趴在地板上，所有的负面信息也都已经展现。另外就是这几个行业都属于强周期行行业，随着经济逐步触底复苏，在未来非常有希望迎来估值修复和业绩增长带来的双击行情。另外再说到这次的疫情，这次疫情可以说对国内的实体经济造成了一定的影响，估计上半年的GDP都要报废了，国家肯定会出台相关的政策来刺激经济，最新的政治局会议也提出了，就看具体怎么实施。那么刺激经济还是要看地产与基建这些，5G的建设估计也是重头戏。所以这次疫情反而有可能提前催化我布局的这些行业，现在买我感觉就是在捡钱。</p><p>地产是1月底下旬买了一少部分，一是因为每年的春节前后会有一波业绩兑现行情，二是在那段时间一直在回调，买的少的原因是因为前期已经有了不错的涨幅，也就博个反弹。</p><p>科技，这个不用多说了，这年头必须要配置的。</p><p>唯一不足的地方就是我节前用力过猛，把大部分钱都加进去了，以至于年前开盘没钱补仓(基金)，目前基金账户还浮亏一点，但是我一点都不担心。</p><p>股票部分：现在投在股市里的钱不多，当时我认为最好的买点在春节开盘第二天，但是我第一天就进了一大部分，第二天也只给了短暂的上车机会。持仓如下：</p><p>000671阳光城：这只从开年到现在一直在操作，平均成本6.5左右，现价7.68，浮赢18%左右。这只是地产股我关注了很长时间，业绩还不错，这段时间砸的也很厉害，安全边际可以说很高了。</p><p>002079苏州固锝：芯片股，一个公众号推荐的，自己感觉形态还不错，就小仓位买了点，悲催的是之前挂单没成交到，后面追高进去的(对我这种胆小的来说红盘三个点就算追高了)。买入价格12.37，当前价格14.95，浮赢20%左右。今天板没封住，但是感觉形态还没走坏，可以周一再看看。</p><p>600741华域汽车：这只应该会长期持有，这里贴一句抄过来的话： 华域是国内业务规模最大、产品品种最多、客户覆盖最广、应用开发能力最强的综合性汽车零部件上市公司。这家也算是新能源车产业链的细分龙头，也为特斯拉提供零部件。但是好像华域没有涉及到新能源核心技术(电池、控制、导航等)，所以市场对它的炒作也不多(没啥故事可讲)，现在估值也不高，具备长期投资价值。买入价格26.67，当前价格26.94，浮亏1%</p><p>另外最近开始打新债了，之前一直都知道这个能赚点小钱但一直也没申购过，没想到第一次申购就中了，072812恩捷发债，应该能赚顿饭钱，哈哈。</p><h3 id="2-17-市场继续强势"><a href="#2-17-市场继续强势" class="headerlink" title="2.17 市场继续强势"></a>2.17 市场继续强势</h3><p>昨天说要做好防守，今天市场就来打我的脸了，也太TM的强了。 今天领头的板块，一是蝗虫概念，二是军工，三是小米（氮化镓+wifi 6），四是5G。 个人认为前三个板块都不是可以持续的板块， 蝗虫是纯事件驱动型，题材炒作为主，氮化镓这个技术其实也早已经运用在很多的充电器中， 现在大盘2900多点，真正向上还是要看主线板块。这些板块的活跃并<strong>不影响主线板块的趋势，反而容易导致主线板块的低吸机会</strong>。 另外短期机会看好超跌的旅游与消费板块！</p><p>我认为的主线板块：</p><blockquote><p>稳健的：银行、保险、基建；</p><p>弹性的：新能源汽车（锂电池），消费电子，5G，云服务（云计算），游戏，券商，物联网（车联网），精装产业链。</p></blockquote><p>可以考虑逢低买点券商ETF了。</p><p>今天把苏州固锝卖掉了，早上绿盘时候卖的，成交价14.64，但是感觉还有向上的空间。</p><p>8.21小仓位追高买入了601519大智慧，也是从公众号关注的推荐中选的，下午也封板了。最近的操作还比较顺，但是要注意潜在的风险，渐进式止盈。另外还是长期看好中国股市， 志在高远者，不退！ </p><h3 id="2-18-大智慧止盈"><a href="#2-18-大智慧止盈" class="headerlink" title="2.18 大智慧止盈"></a>2.18 大智慧止盈</h3><p>大智慧止盈，盈利8个点。</p><p>37买入姚记科技，应该是游资做的，感觉有起来的迹象。</p><h3 id="2-19-姚记亏损出局"><a href="#2-19-姚记亏损出局" class="headerlink" title="2.19 姚记亏损出局"></a>2.19 姚记亏损出局</h3><p>今天上午挺忙没来的及看，姚记科技一大早的走势就不对，明显是要凉。看到的时候已经在跌停上趴着了，挂了34最后也成交了，亏9个点出局。</p><h3 id="2-20-3000点上的一点思考"><a href="#2-20-3000点上的一点思考" class="headerlink" title="2.20 3000点上的一点思考"></a>2.20 3000点上的一点思考</h3><p>上两天说考虑逢低买点券商ETF，今天大金融带领沪市重回3000点。大霄老师又开始了…</p><p>其实我一直很看好很看好科技股，我的自选列表里大部分都是科技，因为科技虽然涨得猛，但我仍然认为它是仍然是今年的主旋律，至于为什么没买，稍后再说。</p><p>今天平安发布了年报，继续牛逼，这种好公司应该长期持有。在这里说下我心中的10倍牛股：中国平安、中国国旅、恒瑞医药、中国建筑。除了中国建筑，剩下的三只我在去年的时候和很多朋友说过，如果去年建仓拿到今年收益也很可观。</p><p>今天买了中国建筑，成本5.34。大盘涨得我害怕了，客观的网友认为昨天和今天上午已经盘整结束，但我认为可能还没开始，今天的交易量已经有了牛市的样子，但仔细看看牛市的标志券商板块，涨停的大多都为中小券商，感觉是游资拉的。3000点是个坎，必定存在着激烈的多空博弈，所以我认为在这种风险较大的时候基建龙头的中国建筑相反会有好的表现。</p><h3 id="2-26-科技股遭重挫"><a href="#2-26-科技股遭重挫" class="headerlink" title="2.26 科技股遭重挫"></a>2.26 科技股遭重挫</h3><p>上两天拖延症犯了又没写，也不想补了，就只写今天的吧。</p><p>先说说疫情吧，直观的感觉就是国外的疫情已经开始<strong>呈失控状态</strong>，日本韩国都是典型的反面教材。纵观全球，新冠肺炎疫情非常不容客观，<strong>外围股市频频下挫</strong>， 看看道琼斯指数和标普500指数就能发现华尔街对新冠疫情在美国蔓延的趋势表示悲观。网传东京奥运会或将取消，现在又被辟谣说会如期举行。我觉得人总要对这种“惩罚”抱有<strong>敬畏之心</strong>，就像敬畏自然、敬畏市场一样，不敬畏必然会付出惨痛的代价。</p><p>说回中国股市，上次记录的时候我就说科技股涨得让我害怕，今天科技集体跌停。其实主要原因就是涨多了，然后受到全球股市集体暴跌冲击。 这波科技股从去年年中就开始上涨，大部分个股早已经透支了未来的业绩，出现明显的泡沫。仔细观察就能发现今天的调整主要就集中在近期涨幅较大的个股和行业上，大多数的股票或行业走的很正常。那么，涨幅较大的个股和行业，难道不应该出现调整么？ </p><p>市场分化的信号再明显不过了，市场会在震荡或调整中寻找新的方向。<strong>热点的形成是一部分群体，在某个方面形成了共识，热点的转换就是这个共识出现了分歧，然后再产生下一个共识的过程。</strong> </p><p>不过这里要说一下，即使在科技股中，分化依然存在。公司质地优良，确定性高的好股票可能调整的时间并不会很长，但是80%以上的科技小票（尤其是芯片股）估计要调整一阵子了。从长远来说，虽然我一直说某些科技股的估值过高，但是科技股的逻辑和白马股不一样，<strong>产业趋势大过市盈率，行业景气度和周期反转才是关键因素</strong>，而非某个阶段的收入或利润。 除了目前部分出现泡沫的芯片股，其他<strong>5G、新能源、消费电子、云计算和工业互联网</strong>等，并未出现估值泡沫，依然可以持有，每次回调都是绝佳的上车机会。 </p><p><strong>行情永远在绝望中产生，在犹豫中发展，在高潮中加速，在疯狂中结束</strong>。现在刚到第二阶段，个别芯片股到了第三阶段，离落幕还远得很，不用太害怕，但是要注意短期风险。</p><p>对于中长线的投资者来说这两天的波动完全可以忽略掉，因为成交量在，整体的趋势未变，对于绝大多数投资者来说，要注意科技股的短期风险，保住利润，调仓到业绩确定的板块，渐进式止盈，同时购买一些用于对冲风险的品种。</p><p>今天涨停的板块主要是<strong>建筑、水泥、房地产</strong>。其实特别好理解，因为国家放大招了。从央行的动作到政治局会议上传递来的信息可以看出国家挽救经济的决心，因此基建是重中之重，另外叠加复产复工，这几个板块上涨不难理解。</p><p>今天我买的基金基本都涨了不少，股票部分因为这几天上班太忙也没管，昨天上午大跌的时候发了个信息让我妈抄底我最近关注的几只股票，她也没操作。鄂武商已经基本跌倒了我的成本位置，其他的几支目前的收益都还可以，暂时也没空动了。</p><p>另外说说我最近关注的几只股票吧，实在没钱买了，现在看啥都想买，就是没钱！</p><p>白马股：中国平安，上海机场 平安到了80以下，上海机场到了70以下，安全且确定性高。不过市场的热点也不会切换到这种蓝筹上来，对于这种长线股票，涨得快慢并不重要，重要的是基本面的长期趋势</p><p>光伏：逻辑之前说过了，最近主要关注中环股份和晶盛机电，今天双双跌停，如果明天继续砸，中环我认为可以上车</p><p>钴：因为特斯拉的五钴电池最近整个板块都暴跌，我找了支洛阳钼业，因为他跌得多，弹的估计也凶</p><p>另外近期关注的滞涨的沪电股份、东山精密最近都分分起飞，亿纬锂能今天跌停，明天如果继续，绝对也可以买了。</p><p>关注的股票太多了，就不一一说了，就再说一个价值投资的长线牛股吧，永辉超市。永辉我也看了快一年了，有机会写篇文章，也是我心目中的十年十倍之一。</p><p>总结一下，跌多了就会涨，涨多了就会跌，正常调整而已。大趋势未变，耐得住寂寞才能收的住繁华。适当的调整会使得市场更加平衡，调整之后市场还会再上的，我仍然坚定看好未来的中国股市，但是短期还是要注意风险，尤其是外围股市对中国造成的影响，应该配置均衡配置，对冲风险。 </p><h3 id="3-1-外围止跌"><a href="#3-1-外围止跌" class="headerlink" title="3.1 外围止跌"></a>3.1 外围止跌</h3><p>上周整周都太忙了，加之我太懒，因此一没有操作股票，也没有及时更新博客，就把上两天的一起写了吧。</p><p>周五又迎来了除2.3号开市以来的最大跌幅，就是一个字，惨！外围股市跌的太惨了，美股这周跌掉了去年一年的涨幅。全球防疫会使得世界经济停滞，另外科技股再次暴跌。前面的文章我也说过，除了业绩确定性高的个股，我不建议大家在短期内碰这个版块。周五尾盘我加了一点基金，我判断下周一会低开，如果跌的凶的话我会再补一部分，基金还是那几只，增加了一个券商，因为在牛市中，每一次大盘发力都必定有券商的身影，券商会反复活跃，因此值得定投。周六看了一眼美股，尾盘拉升，已经止跌,估计周一会低开高走，准备抄底。</p><p>抄底的标的：鄂武商、中国建筑、中环股份….其实有挺多想买的，奈何囊中羞涩</p><h3 id="3-2-高开高走-基建爆发"><a href="#3-2-高开高走-基建爆发" class="headerlink" title="3.2 高开高走 基建爆发"></a>3.2 高开高走 基建爆发</h3><p>还等着今天抄底呢，直接高开了一个多点，还抄啥？</p><p>今天早盘高开之后单边上行，根本不给上车的机会，<strong>水泥、建筑、5G、券商</strong>领涨。之前我说过基建水泥的逻辑，今天的大涨已经显示了疫情过后拉动经济的政策布局，<strong>基建是最主动的一个经济政策</strong>，通过基础设施建设来拉动和盘活经济与就业，相比于其他被动政策，不仅简单粗暴而且效果显著。此次基建的行情我觉得短时间不会结束，应该会反复活跃一阵子，奈何我的基建基金还在亏损，实在是操作上的大失误。今天盘中传出科技基金暂缓申报后又被辟谣，但是我还是要说现在<strong>玩科技股如火中取栗</strong>，当然这里排除业绩确定性高的5G基建类股票。</p><p>对于基建，细分其实包括<strong>传统基建</strong>和<strong>数字新基建</strong>，传统基建大家都了解，数字新基建实际上就是5G。对于5G产业链，直接受益的就是最<strong>上游的设备商</strong>，接下来是<strong>流量基础设施</strong>，最后是<strong>终端与创新应用</strong>。这个链条其实也决定了炒作的先后顺序。从业绩释放上看，设备端最早，比如中兴通讯、沪电股份、深南电路。与此同时，流量基础设施将会伴随5G网络同步建设，业绩释放的顺序是光纤网络、交换机、路由器、IDC机房、云计算软件与云存储。这里面我主要关注的就是中际旭创、宝信软件、光环新网、浪潮信息、用友网络、广联达等</p><p>还有两个板块确定性也很高，之前也都说过，<strong>新能源/特斯拉产业链</strong>和<strong>消费电子</strong>。</p><p>对于未来的一到两个月份，我觉得还是震荡上行的概率比较大，但是虽然上周五暴跌，但是感觉风险并没有释放完，因此最近还是小心点好，坚决不能满仓。5G和基建应该会是近期的热点，可以关注一下，择机低吸。</p><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>今天市场缩量了，昨天美联储降息50个基点，美股却大跌，说白了现在降息对市场的已经不大了，想要涨还得是真金白银，但是大A走出了独立行情。</p><p>今天基建、地产、券商表现的还不错，上几篇文章我就说过，基建的行情还会持续一段时间，不会这么快就结束。另外我上两天也说过关于风格切换的这个事情，在这波行情中，创业板的涨幅远远大过上证指数，因此我判断在接下来的一段时间中沪指也会渡过震荡阶段开始走趋势行情，可以适当多关注一些白马。很多蓝筹都处在低位，因此将目光从涨幅过大的科技转向估值偏低的白马可能是很多资金的选择。</p><p>最近还是比较看好这几个板块：基建、券商、地产、家居、食品、消费。</p>]]></content>
      
      
      <categories>
          
          <category> 理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理财 </tag>
            
            <tag> 基金 </tag>
            
            <tag> 股票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年阅读书单</title>
      <link href="/2020/02/14/2020%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
      <url>/2020/02/14/2020%E5%B9%B4%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年阅读书单"><a href="#2020年阅读书单" class="headerlink" title="2020年阅读书单"></a>2020年阅读书单</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><table><thead><tr><th>书籍名称</th><th>目的</th><th>时间</th></tr></thead><tbody><tr><td>Presto技术内幕</td><td>公司使用presto为数据分析等工作提供即席查询服务，想了解一下</td><td></td></tr><tr><td>SQL核心优化思想</td><td>作为一个“人肉取数机”，SQL优化还是有必要看的，之前看的都是零散的公众号文章，现在找本系统的书籍来看看</td><td></td></tr><tr><td>数据驱动：从方法到实践</td><td>神策的老大写的，我司也已经在开始使用了，神策在国内目前做的算比较好的了</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="非技术"><a href="#非技术" class="headerlink" title="非技术"></a>非技术</h2><table><thead><tr><th align="center">书籍名称</th><th align="center">类  型</th><th>目的</th><th>时间</th></tr></thead><tbody><tr><td align="center">富爸爸穷爸爸</td><td align="center">理财</td><td>早就听说了这本书的大名，一直没有空拜读，在过年的时候看了看，里面的很多理念很值得当代的年轻人学习</td><td>20200217</td></tr><tr><td align="center">国富论</td><td align="center">经济学</td><td>近代经济学的奠基之作，刚上大学的时候看过一点时间，没坚持下去</td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Presto基础知识总结</title>
      <link href="/2020/02/14/Presto%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/14/Presto%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Presto基础知识总结"><a href="#Presto基础知识总结" class="headerlink" title="Presto基础知识总结"></a>Presto基础知识总结</h1><p>公司使用Presto为数据分析师们进行即席查询服务，网上的知识太过碎片化，因此看了《Presto技术内幕》，大体了解一下Presto的知识。国内的<a href="http://prestodb.jd.com" target="_blank" rel="noopener">Presto社区</a>由JD维护(ps:基本也不咋维护，github上最新的提交时间是5年前)，《Presto技术内幕》也出自京东，Presto在国内的很多互联网公司都有应用，在此表示感谢。</p><p>本篇文章一方面摘录《Presto技术内幕》的一些片段，另一方面也加入了一些自己的见解(从数据分析角度)，有兴趣的小伙伴可以看看。</p><h2 id="一-、Presto简介"><a href="#一-、Presto简介" class="headerlink" title="一 、Presto简介"></a>一 、Presto简介</h2><h3 id="1-1-Presto的背景与概念"><a href="#1-1-Presto的背景与概念" class="headerlink" title="1.1 Presto的背景与概念"></a>1.1 Presto的背景与概念</h3><p>随着经济和科技快速发展，各大企业和公司每天需要处理的数据飞速增加，因此这几年大数据相关的技术突然兴起并且迅速变得火热，大数据开发的岗位需求量也十分巨大。在大数据技术中，无论如何都绕不开Hadoop。<strong>Hadoop提供了大数据存储和计算的一整套方案，可以说是非常完美的解决了大数据的存储与计算问题</strong>，也是现在所有大数据开发绕不开的技术。但是世界上没有绝对完美的东西，Hadoop提供的大数据解决方案是Google提出的Map-Reduce框架，这种框架<strong>适合用于大数据的离线与批量处理</strong>，侧重于高吞吐率而非计算效率，因此<strong>不能满足大数据快速试试查询的需求</strong>。</p><p>在这里要说一下Hive， 大家都知道<strong>Hive是基于<a href="https://baike.baidu.com/item/Hadoop/3526507" target="_blank" rel="noopener">Hadoop</a>的一个<a href="https://baike.baidu.com/item/数据仓库/381916" target="_blank" rel="noopener">数据仓库</a>工具</strong>，用来进行<strong>数据提取、转化、加载</strong>，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive数据仓库工具能将结构化的数据文件映射为一张数据库表，<strong>并提供<a href="https://baike.baidu.com/item/SQL/86007" target="_blank" rel="noopener">SQL</a>查询功能</strong>，<strong>能将SQL语句转变成<a href="https://baike.baidu.com/item/MapReduce/133425" target="_blank" rel="noopener">MapReduce</a>任务来执行</strong>。十分<strong>适合数据仓库的统计分析</strong>，那Presto相比与Hive有哪些优点？请看1.5节。 </p><p>Presto是一个使用<strong>Java开发</strong>的、部署在Linux系统中开源的<strong>分布式SQL查询引擎</strong>，适用于交互式分析查询，数据量支持GB到PB字节。<br>按照官方论坛的说法，Presto终结了数据分析的两难选择，即要么使用速度快的昂贵的商业方案，要么使用消耗大量硬件的慢速的“免费”方案。因此Presto的设计和编写完全是为了解决像Facebook这样规模的商业数据仓库的交互式分析和<strong>处理速度的问题</strong>。<br>注意：虽然Presto可以解析SQL，但它不是一个标准的数据库。不是MySQL、Oracle的代替品，也不能用来处理在线事务（OLTP）。</p><h3 id="1-2-Presto应用场景"><a href="#1-2-Presto应用场景" class="headerlink" title="1.2 Presto应用场景"></a>1.2 Presto应用场景</h3><p>Presto是一种<strong>基于内存</strong>的分布式实时计算框架，经过京东改造过后提供了多种类型的Connector，可以访问包括<em>Hive、MySQL、Cassandra、PostgreSQL、Kafka</em>等多种数据源。作为开发者，可以通过实现Presto标准的SPI接口来定制自己的Connector来达到访问特定数据源的需求。一条Presto查询可以<strong>将多个数据源的数据进行合并</strong>，可以跨越整个组织进行分析。</p><p>应用场景大体有一下几个方面：</p><p><strong>ETL</strong></p><p>由于Prsto可以方便的支持各种数据源并且支持数据源的混合计算，因此我们是可以用SQL将一个数据源中的数据导入到另一个数据源。例如可以将MySQL中的数据导入到Hive，反之也可以。所以可以通过定时脚本的方式进行ETL</p><p><strong>实时数据计算</strong></p><p>通过将Hive与Presto配合使用的方式来填补Hive无法满足实时计算的缺点。对海量数据的批处理操作由Hive完成，对海量数据的计算(GB到TB)有Presto完成。</p><p><strong>Ad-Hoc查询</strong></p><p>即席查询，允许用户根据需求随时调整和选择查询条件，实施返回查询结果或生成报表。与即席查询相对应的是普通查询，因为普通查询是定制开发的，所以可以通过建立索引、分区等优化手段对查询进行优化。即席查询的查询范围等都是未知的，无法对其进行有针对性的优化</p><p>对于分析师而言，查询速度是非常重要的！因此Presto<strong>主要用来处理响应时间小于1秒到几分钟的场景</strong>。</p><h3 id="1-3-Presto架构"><a href="#1-3-Presto架构" class="headerlink" title="1.3 Presto架构"></a>1.3 Presto架构</h3><h4 id="1-3-1-Presto是由什么组成的"><a href="#1-3-1-Presto是由什么组成的" class="headerlink" title="1.3.1 Presto是由什么组成的"></a>1.3.1 Presto是由什么组成的</h4><p>Presto是一个运行在多台服务器上的分布式系统，因此它的架构其实和其他的大数据工具架构都类似，都为主从结构。</p><p>Presto集群通常包括<strong>一个Coordinator</strong>和<strong>多个Worker</strong>。由客户端提交查询，从Presto命令行CLI提交到Coordinator。Coordinator进行解析，分析并执行查询计划，然后分发处理队列到Worker。</p><p>因此Presto有两类服务器：Coordinator和Worker。</p><h5 id="1）Coordinator"><a href="#1）Coordinator" class="headerlink" title="1）Coordinator"></a>1）Coordinator</h5><p><strong>调度者</strong>角色。主要功能就是<strong>管理整个Presto集群</strong>。</p><p>Coordinator服务器是用来<strong>解析语句，执行计划分析</strong>和管理Presto的Worker结点。Presto安装必须有一个Coordinator和多个Worker。如果用于开发环境和测试，则一个Presto实例可以同时担任这两个角色。</p><p>Coordinator跟踪每个Work的活动情况并协调查询语句的执行。Coordinator为每个查询建立模型，模型包含多个Stage，每个Stage再转为Task分发到不同的Worker上执行。</p><p>Coordinator与Worker、Client通信是通过REST API。</p><h5 id="2）Worker"><a href="#2）Worker" class="headerlink" title="2）Worker"></a>2）Worker</h5><p><strong>生产者</strong>角色。Worker是负责<strong>执行任务和处理数据</strong>。Worker从Connector获取数据。Worker之间会交换中间数据。Coordinator是负责从Worker获取结果并返回最终结果给Client。</p><p>当Worker启动时，会广播自己去发现 Coordinator，每隔一定的时间也会向Coordinator上的RESTful服务<strong>发送心跳</strong>，并告知 Coordinator它是可用，随时可以接受Task。</p><p>Worker与Coordinator、Worker通信是通过REST API。</p><h4 id="1-3-2-Presto是如何组织数据的"><a href="#1-3-2-Presto是如何组织数据的" class="headerlink" title="1.3.2 Presto是如何组织数据的"></a>1.3.2 Presto是如何组织数据的</h4><h5 id="1）从结构上看"><a href="#1）从结构上看" class="headerlink" title="1）从结构上看"></a>1）从结构上看</h5><p><strong>Presto采取三层表结构：</strong></p><p><strong>Catalog</strong>：对应某一类数据源，例如Hive的数据，或MySQLql的数据</p><p><strong>Schema</strong>：对应MySQLql中的数据库</p><p><strong>Table</strong>：对应MySQLql中的表 </p><p><strong>1 Connector</strong></p><p>Connector是<strong>适配器</strong>，也可以理解为<strong>驱动</strong>程序，<strong>用于</strong>Presto和数据源（如Hive、RDBMS）的<strong>连接</strong>。你可以认为类似JDBC那样，但却是Presto的SPI的实现，使用标准的API来与不同的数据源交互。</p><p>Presto有几个内建Connector，又经过京东改造增加后，现在已经可以满足绝大多数公司的需求。</p><p>每个Catalog(介绍在下方)都有一个特定的Connector。如果你使用catelog配置文件，你会发现每个文件都必须包含connector.name属性，用于指定catelog管理器（创建特定的Connector使用）。一个或多个catelog用同样的connector是访问同样的数据库。例如，你有两个Hive集群。你可以在一个Presto集群上配置两个catelog，两个catelog都是用Hive Connector，从而达到可以查询两个Hive集群。</p><p><strong>2 Catelog</strong></p><p>Presto中的Catelog类似于关系型数据库中的一个<strong>数据库实例</strong>，而Schema就类似于一个<strong>Database</strong>，通过使用特定的Connector访问Catelog中指定的数据源，因此Catelog和Schema是一对多，一个Catelog包含Schema和Connector。</p><p>例如，你配置MySQL的catelog，通过MySQLConnector访问MySQL信息。当你执行一条SQL语句时，可以同时运行在多个catelog。<br>Presto处理table时，是通过表的完全限定（fully-qualified）名来找到catelog。例如，一个表的权限定名是Hive.test_data.test，则test是表名，test_data是schema，Hive是catelog。</p><p>Catelog的定义文件是在Presto的配置目录中。</p><p><strong>3 Schema</strong></p><p>Schema类似于关系型数据库中的一个<strong>Database</strong>，用于组织table。<strong>把catelog和schema结合在一起来就唯一确定了可以查询的一系列表的集合。</strong>当通过Presto访问Hive或MySQL时，一个schema会同时转为Hive和mySQL的同等概念。</p><p><strong>4 Table</strong></p><p>Table跟关系型的表定义一样，但数据和表的映射是交给Connector。</p><h5 id="2）从存储上看"><a href="#2）从存储上看" class="headerlink" title="2）从存储上看"></a>2）从存储上看</h5><p>Presto的存储单元包括：</p><p><strong>Page</strong>：多行数据的集合，包含多个列的数据，内部仅提供逻辑行，实际以列式存储。</p><p><strong>Block</strong>：一列数据，根据不同类型的数据，通常采取不同的编码方式，了解这些编码方式，有助于自己的存储系统对接presto。</p><p>不同类型的Block：</p><p>① Array类型Block，应用于固定宽度的类型，例如int，long，double。block由两部分组成：<br>boolean valueIsNull[]表示每一行是否有值。<br>T values[] 每一行的具体值。</p><p>② 可变宽度的Block，应用于String类数据，由三部分信息组成<br>Slice：所有行的数据拼接起来的字符串。<br>int offsets[]：每一行数据的起始偏移位置。每一行的长度等于下一行的起始便宜减去当前行的起始偏移。<br>boolean valueIsNull[] 表示某一行是否有值。如果有某一行无值，那么这一行的偏移量等于上一行的偏移量。</p><p>③ 固定宽度的String类型的block，所有行的数据拼接成一长串Slice，每一行的长度固定。</p><p>④ 字典block：对于某些列，distinct值较少，适合使用字典保存。主要有两部分组成：<br>字典，可以是任意一种类型的block(甚至可以嵌套一个字典block)，block中的每一行按照顺序排序编号。<br>int ids[]表示每一行数据对应的value在字典中的编号。在查找时，首先找到某一行的id，然后到字典中获取真实的值。</p><h4 id="1-3-3-Presto是怎样执行查询的"><a href="#1-3-3-Presto是怎样执行查询的" class="headerlink" title="1.3.3 Presto是怎样执行查询的"></a>1.3.3 Presto是怎样执行查询的</h4><p>Presto在执行SQL语句时，将这些SQL语句解析为相应的查询，并在分布式集群中执行这些查询。</p><ul><li><p><strong>Statement</strong><br><strong>statement语句是我们输入的SQL</strong>。</p><p>执行语句时，Presto会<strong>创建</strong>一个查询以及一个<strong>查询计划</strong>，然后将这个查询计划生成可以执行的查询Query。分配给一系列Worker。</p></li><li><p><strong>Query</strong><br>一个语句可以被认为是传递给Presto的SQL文本，而一个查询是指<strong>为了执行该语句而实例化的配置和组件</strong>。 <strong>查询包含阶段(stage)，任务(task)，拆分(split)</strong>，连接器以及其他组件和数据源协同工作以产生结果。Query是<strong>由各个Worker 和相关的Stage 组成</strong>。</p></li><li><p><strong>Stage</strong><br>当Presto执行一个查询时，它通过将执行<strong>分解为一个阶段层次结构</strong>来实现。Stage为<strong>树状</strong>结构，并不会实际执行。每个查询都有<strong>一个根</strong>阶段，负责汇总其他阶段的输出， 阶段是协调员用来为分布式查询计划建模的阶段。只是Coordinator进行管理和建模的<strong>逻辑概念</strong>。</p></li><li><p><strong>Exchange</strong><br>Stage用来连接另一个Stage。</p></li><li><p><strong>Task</strong><br>Task是需要<strong>实际运行</strong>在Presto的各个Worker节点上的。一个Stage被拆分为多个Task，因此可以被并行执行，每个Task处理多个Split，一个Task 又可以分为多个Driver ，从而并行执行一个Task.</p></li><li><p><strong>Driver</strong><br>一个Task包含一个或多个Driver，是作用于一个Split的一系列Operator的集合，一个Driver处理一个Split。一个Driver拥有一个输入和一个输出。</p></li><li><p><strong>Operator</strong><br>一个Operator代表一个Split的一种操作，依次读取Split。列如过滤，加权，转换。均会以Page 为最小单位读取输入数据，产生输出数据。</p></li><li><p><strong>Split</strong><br>一个大的数据集之中的一个小的子集。Presto执行查询时，首先会从Coordinator得到一个表对应的所有Split，然后根据查询计划，选择合适的节点运行Task 处理Split。</p></li><li><p><strong>Page</strong><br>presto处理的最小数据单元，一个Page对象包含多个Block对象，最大Page为1MB，最多16 * 1024行数据。</p><p><img src="/.top//C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581585581521.png" alt="1581585581521"></p><p>总结一下，我们把SQL提交后，Presto会对其进行解析，转换成一个Query。一次查询执行又会被分解为多个Stage，Stage与Stage之间是有前后依赖关系的(树形结构)。每个Stage内部会进一步分解为多个Task，属于每个Stage的Task被均匀的分在了每个Worker上执行(因为有调度者的存在)。每个Task又由一系列前后连接的Operator组成，每个Operator都代表针对于一个Split的操作。可以看出这种层层分解、并行执行的方式也是导致Presto查询速度快的重要因素。</p></li></ul><h3 id="1-4-Presto整体架构"><a href="#1-4-Presto整体架构" class="headerlink" title="1.4 Presto整体架构"></a>1.4 Presto整体架构</h3><h4 id="1-4-1-硬件架构"><a href="#1-4-1-硬件架构" class="headerlink" title="1.4.1 硬件架构"></a>1.4.1 硬件架构</h4><p>Presto是基于内存的，所以硬件要求很高，集群兴建必须满足大内存、万兆网络。上文提到Presto中的服务主要有两种：Coordinator和Worker，所以也是主从架构。另外还需要一个客户端。</p><p>CLI客户端：部署了Presto命令行客户短的服务器</p><p>应用客户端：开发人员可以使用JDBC驱动，通过java使用Presto</p><p><img src="https://i.loli.net/2020/02/14/32DMTZjNlXEKzQO.png" alt></p><h4 id="1-4-2-软件架构"><a href="#1-4-2-软件架构" class="headerlink" title="1.4.2 软件架构"></a>1.4.2 软件架构</h4><p><img src="https://i.loli.net/2020/02/14/zseDaFdkTP2VtBr.png" alt></p><h3 id="1-5-Presto优缺点"><a href="#1-5-Presto优缺点" class="headerlink" title="1.5 Presto优缺点"></a>1.5 Presto优缺点</h3><h4 id="1-5-1-从技术选型上看"><a href="#1-5-1-从技术选型上看" class="headerlink" title="1.5.1 从技术选型上看"></a>1.5.1 从技术选型上看</h4><p>由于Presto是基于Java语言开发而且遵循ANSI SQL，因此无论对开发者和使用者来说，presto极易学习使用并准对特定业务场景进行开发和性能优化。个人觉得这一点非常重要，对于一个大的公司来说，采用一个技术往往不仅需要考虑是否满足业务的需求，更要考虑的是使用与学习成本。</p><h4 id="1-5-2-从技术本身上看"><a href="#1-5-2-从技术本身上看" class="headerlink" title="1.5.2 从技术本身上看"></a>1.5.2 从技术本身上看</h4><ol><li>对于多数据源的支持、良好的扩展性</li><li>简单的数据查询方式，使用者只要会SQL就能直接使用</li><li>卓越的查询性能</li></ol><h4 id="1-5-3-与Hive比较"><a href="#1-5-3-与Hive比较" class="headerlink" title="1.5.3 与Hive比较"></a>1.5.3 与Hive比较</h4><p> Hive的本质是把一个查询<strong>转化成多个MapReduce任务</strong>，然后一个接一个执行。执行的<strong>中间结果通过对磁盘的读写来同步</strong>。然而Presto没有使用MapReduce，它是通过一个<strong>定制的查询和执行引擎</strong>来完成的。它的<strong>所有的查询处理是在内存中</strong>，减少与硬盘的交互，这也是它的性能很高的一个主要原因。 </p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>Presto与Hive对比，都能够处理PB级别的海量数据分析，但Presto是基于内存运算，减少没必要的硬盘IO，所以更快。</li><li>能够连接多个数据源，跨数据源连表查，如从Hive查询大量网站访问记录，然后从MySQL中匹配出设备信息。</li><li>部署也比Hive简单，因为Hive是基于HDFS的，需要先部署HDFS。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>虽然能够处理PB级别的海量数据分析，但不是代表Presto把PB级别都放在内存中计算的。而是根据场景，如count，avg等聚合运算，是边读数据边计算，再清内存，再读数据再计算，这种耗的内存并不高<strong>。但是连表查，就可能产生大量的临时数据，因此速度会变慢，反而Hive此时会更擅长。</strong></li><li>为了达到实时查询，可能会想到用它直连MySQLql来操作查询，这效率并不会提升，瓶颈依然在MySQLql，此时还引入网络瓶颈，所以会比原本直接操作数据库要慢。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Presto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Presto </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分享-5-面向对象</title>
      <link href="/2020/01/06/Python%E5%88%86%E4%BA%AB-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/01/06/Python%E5%88%86%E4%BA%AB-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Python分享第五节"><a href="#Python分享第五节" class="headerlink" title="Python分享第五节"></a>Python分享第五节</h1><p>最近受邀给团队中的小伙伴们分享<code>Python</code>知识，本篇文章是第五节课的基本内容。</p><h2 id="一、课前准备"><a href="#一、课前准备" class="headerlink" title="一、课前准备"></a>一、课前准备</h2><ol><li>复习<code>Python</code>的基础语法与基础数据类型</li></ol><h2 id="二、课堂主题"><a href="#二、课堂主题" class="headerlink" title="二、课堂主题"></a>二、课堂主题</h2><p>第五课主要学习程序设计中面向对象的基本知识</p><h2 id="三、本节目标"><a href="#三、本节目标" class="headerlink" title="三、本节目标"></a>三、本节目标</h2><p>1、掌握<code>Python</code>中对象的创建与使用</p><p>2、掌握对象的方法和属性</p><p>3、掌握面向对象的三大特征：<strong>封装</strong>、<strong>继承</strong>、多态</p><h2 id="四、知识要点"><a href="#四、知识要点" class="headerlink" title="四、知识要点"></a>四、知识要点</h2><h3 id="4-1、匿名函数"><a href="#4-1、匿名函数" class="headerlink" title="4.1、匿名函数"></a>4.1、匿名函数</h3><p><strong>匿名函数</strong>： 顾名思义就是函数没有名字，在<code>Python</code>中，使用<code>lambda</code>关键字定义的函数就是匿名函数。</p><p><strong>优点</strong>：简化代码，增加运行效率。</p><p><strong>特点</strong>： 匿名函数只适合做一下简单的操作，返回值不需要加上return。  </p><p>下面举个例子：</p><p>普通函数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>匿名函数：</p><pre class=" language-python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token punctuation">:</span> a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h3 id="4-2、面向对象编程"><a href="#4-2、面向对象编程" class="headerlink" title="4.2、面向对象编程"></a>4.2、面向对象编程</h3><p><strong>面向对象编程</strong>——Object Oriented Programming，简称<strong>OOP</strong>，是一种程序设计思想。</p><p>OOP把对象作为程序的<strong>基本单元</strong>，一个对象包含了数据和操作数据的函数。</p><p><strong>面向过程</strong>的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把  函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而<strong>面向对象</strong>的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息并处理，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>在自然界中，<strong>万事万物皆为对象</strong>。在<code>Python</code>中，<strong>所有数据类型都可以视为对象</strong>，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（<code>Class</code>）的概念。</p><p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p><p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个<code>dict</code>表示：</p><pre class=" language-python"><code class="language-python">std1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'Curry'</span><span class="token punctuation">,</span> <span class="token string">'score'</span><span class="token punctuation">:</span> <span class="token number">98</span> <span class="token punctuation">}</span>std2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'James'</span><span class="token punctuation">,</span> <span class="token string">'score'</span><span class="token punctuation">:</span> <span class="token number">81</span> <span class="token punctuation">}</span></code></pre><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_score</span><span class="token punctuation">(</span>std<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>std<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token punctuation">[</span><span class="token string">'score'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>如果采用<strong>面向对象的程序设计思想</strong>，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为 一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个<strong>属性</strong>（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>          self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>score <span class="token operator">=</span> score    <span class="token keyword">def</span> <span class="token function">print_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的<strong>方法</strong>（Method）。面向对象的程序写出来就  像这样：</p><pre class=" language-python"><code class="language-python">bart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Bart Simpson'</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span> lisa <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Lisa Simpson'</span><span class="token punctuation">,</span> <span class="token number">87</span><span class="token punctuation">)</span> bart<span class="token punctuation">.</span>print_score<span class="token punctuation">(</span><span class="token punctuation">)</span> lisa<span class="token punctuation">.</span>print_score<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>面向对象的设计思想是从自然界中来的，因为在自然界中，<strong>类</strong>（Class）和<strong>实例</strong>（Instance）的概念是很自然的。<code>Class</code>是一种抽象概念，比如我们定义的<code>Class——Student</code>，是指学生这个概念，而<strong>实例</strong>（Instance）则是一个个具 体的<code>Student</code>，比如，<em>Bart Simpson</em>和<em>Lisa Simpson</em>是两个具体的<code>Student</code>。</p><p>所以，面向对象的设计思想是抽象出<code>Class</code>，根据<code>Class</code>创建<code>Instance</code>。</p><p>面向对象的抽象程度又比函数要高，因为一个<code>Class</code>既包含数据，又包含操作数据的方法。</p><h3 id="4-3、类和对象"><a href="#4-3、类和对象" class="headerlink" title="4.3、类和对象"></a>4.3、类和对象</h3><p><strong>面向对象编程</strong>的2个非常重要的概念：<strong>类和对象</strong></p><p><strong>对象</strong>是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——<strong>类</strong></p><p><strong>类</strong>就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于<strong>对象</strong>。</p><h4 id="4-3-1、类"><a href="#4-3-1、类" class="headerlink" title="4.3.1、类"></a>4.3.1、类</h4><p>物以类聚，人以群分。具有相似内部状态和运动规律的实体的集合(或统称为抽象)。具有相同<strong>属性</strong>和<strong>行为</strong>事物的统称类是抽象的，在使用的时候通常会找到这个类的一个具体的存在，使用这个具体的存在。<strong>一个类可以对应多个对象</strong>。</p><p><img src="https://i.loli.net/2020/01/05/k1ew3RFJaoGK2u4.png" alt></p><h4 id="4-3-2、对象"><a href="#4-3-2、对象" class="headerlink" title="4.3.2、对象"></a>4.3.2、对象</h4><p>某个具体事物的存在在现实世界中可以是看得见摸得着的，可以是直接使用的</p><p><img src="https://i.loli.net/2020/01/05/u7rM5nw6G8btkRg.png" alt></p><h4 id="4-3-3、类和对象之间的关系"><a href="#4-3-3、类和对象之间的关系" class="headerlink" title="4.3.3、类和对象之间的关系"></a>4.3.3、类和对象之间的关系</h4><p><strong>类就是创建对象的模板</strong>  </p><p><img src="https://i.loli.net/2020/01/05/yEqPcTWxwDvSBuF.png" alt></p><h4 id="4-3-4、定义类和创建对象"><a href="#4-3-4、定义类和创建对象" class="headerlink" title="4.3.4、定义类和创建对象"></a>4.3.4、定义类和创建对象</h4><p>定义一个类，格式如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">:</span>    方法列表<span class="token keyword">class</span> <span class="token class-name">Plane</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"飞机可以飞行"</span><span class="token punctuation">)</span></code></pre><p><strong>说明：</strong></p><ul><li><code>object</code>是<code>Python</code>里所有类的最顶级父类 </li><li>类名的命名规则按照”<strong>大驼峰</strong>命名法”</li><li><code>info</code>是一个实例方法，第一个参数一般是<code>self</code>，表示实例对象本身</li><li><code>Python</code>中，可以根据已经定义的类去创建出一个或多个对象</li></ul><p><strong>创建对象的格式为:</strong></p><p>对象名1 = 类名()<br>对象名2 = 类名()<br>对象名3 = 类名()</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Plane</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token triple-quoted-string string">"""fly 是一个实例方法，类对象可以调用实例方法，实例方法的第一个参数一定是self"""</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""当对象调用实例方法时，        Python会自动将对象本身的引用做为参数，传递到实例方法的第一个参数self里"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"飞机可以飞行"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"self各不同，对象是出处。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Plane这个类 实例化了一个对象</span>plane <span class="token operator">=</span> Plane<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对象调用实例方法fly()，执行fly()里的代码</span><span class="token comment" spellcheck="true"># .表示选择属性或者方法</span>plane<span class="token punctuation">.</span>fly<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>plane<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 打印对象，则默认打印对象在内存的地址，结果等同于fly里的print(self)</span></code></pre><h3 id="4-4、对象的属性和方法"><a href="#4-4、对象的属性和方法" class="headerlink" title="4.4、对象的属性和方法"></a>4.4、对象的属性和方法</h3><h4 id="4-4-1、添加和获取对象的属性"><a href="#4-4-1、添加和获取对象的属性" class="headerlink" title="4.4.1、添加和获取对象的属性"></a>4.4.1、添加和获取对象的属性</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""定义了一个英雄类，可以移动和攻击"""</span>     <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""实例方法"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在前往战场..."</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 实例化了一个英雄对象</span>hero <span class="token operator">=</span> Hero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给对象添加属性，以及对应的属性值</span>hero<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"妲己"</span> <span class="token comment" spellcheck="true"># 姓名</span>hero<span class="token punctuation">.</span>hp <span class="token operator">=</span> <span class="token number">2600</span> <span class="token comment" spellcheck="true"># 生 命 值</span><span class="token comment" spellcheck="true"># 通过.成员选择运算符，获取对象的属性值</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"英雄 %s 的生命值 :%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>hero<span class="token punctuation">.</span>name<span class="token punctuation">,</span> hero<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过.成员选择运算符，获取对象的实例方法</span>hero<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="4-4-2、通过self获取对象属性"><a href="#4-4-2、通过self获取对象属性" class="headerlink" title="4.4.2、通过self获取对象属性"></a>4.4.2、通过self获取对象属性</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""定义了一个英雄类，可以移动和攻击"""</span>     <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""实例方法"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在前往战场..."</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在类的实例方法中，通过self获取该对象的属性"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"英雄 %s 的生命值 :%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 实例化了一个英雄对象</span>hero <span class="token operator">=</span> Hero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给对象添加属性，以及对应的属性值</span>hero<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"妲己"</span> <span class="token comment" spellcheck="true"># 姓名</span>hero<span class="token punctuation">.</span>hp <span class="token operator">=</span> <span class="token number">2600</span> <span class="token comment" spellcheck="true"># 生 命 值</span><span class="token comment" spellcheck="true"># 通过.成员选择运算符，获取对象的属性值</span>hero<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 只需要调用实例方法info()，即可获取英雄的属性</span>hero<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="4-4-3、-init-魔法方法"><a href="#4-4-3、-init-魔法方法" class="headerlink" title="4.4.3、__init__魔法方法"></a>4.4.3、__init__魔法方法</h4><h5 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__()方法"></a><code>__init__()</code>方法</h5><p><strong>魔法方法</strong>：<code>Python</code> 类里提供的，以两个下划线开始，两个下划线结束的方法，叫做魔法方法。</p><p><code>__init__()</code>就是一个魔法方法， 通常用来做<strong>属性初始化</strong>或<strong>赋值</strong>操作 。</p><p>如果类中没有写 <code>__init__()</code> 方法，<code>Python</code>会自动创建，但是不执行任何操作。 如果为了能够在完成自己想要的功能，可以自己定义<code>__init__()</code>方法。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在类实例化对象的时候，会被自动调用"""</span>         self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"hero"</span> <span class="token comment" spellcheck="true"># 姓 名</span>        self<span class="token punctuation">.</span>hp <span class="token operator">=</span> <span class="token number">2600</span> <span class="token comment" spellcheck="true"># 生命值</span>    <span class="token triple-quoted-string string">"""定义了一个英雄类，可以移动和攻击"""</span>     <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""实例方法"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在前往战场..."</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在类的实例方法中，通过self获取该对象的属性"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"英雄 %s 的生命值 :%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 实例化了一个英雄对象</span>hero <span class="token operator">=</span> Hero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过.成员选择运算符，获取对象的属性值</span>hero<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 只需要调用实例方法info()，即可获取英雄的属性</span>hero<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p> <code>__init__()</code>方法的<strong>注意点</strong>：</p><ul><li><code>__init__()</code>方法，在创建一个对象时默认被调用，不需要手动调用</li><li><code>__init__(self)</code>中的<code>self</code>参数，不需要开发者传递，<code>Python</code>解释器会自动把当前的对象引用传递过去</li></ul><h5 id="带参数的-init-方法"><a href="#带参数的-init-方法" class="headerlink" title="带参数的__init__()方法"></a>带参数的<code>__init__()</code>方法</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> hp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在类实例化对象的时候，会被自动调用"""</span>         self<span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment" spellcheck="true"># 姓 名</span>        self<span class="token punctuation">.</span>hp <span class="token operator">=</span> hp <span class="token comment" spellcheck="true"># 生命值</span>    <span class="token triple-quoted-string string">"""定义了一个英雄类，可以移动和攻击"""</span>     <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""实例方法"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在前往战场..."</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在类的实例方法中，通过self获取该对象的属性"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"英雄 %s 的生命值 :%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 实例化了一个英雄对象</span>hero1 <span class="token operator">=</span> Hero<span class="token punctuation">(</span><span class="token string">"妲己"</span><span class="token punctuation">,</span> <span class="token number">2600</span><span class="token punctuation">)</span>hero2 <span class="token operator">=</span> Hero<span class="token punctuation">(</span><span class="token string">"武则天"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过.成员选择运算符，获取对象的属性值</span>hero1<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 只需要调用实例方法info()，即可获取英雄的属性</span>hero2<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hero1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hero2<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 不同对象的属性值的单独保存</span><span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>hero1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>hero2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 同一个类的不同对象，实例方法共享</span><span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>hero1<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>hero2<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>总结：</strong></p><ul><li>通过一个类可以创建多个对象，就好比通过一个模具创建多个实体一样</li><li><code>__init__()</code>中，默认有1个参数名字为<code>self</code>，如果在创建对象时传递了2个实参，那么<code>__init__()</code>中出了<code>self</code>作为第1个形参外还需要2个形参，例如__init__(self, x, y)</li><li>在类内部获取<em>属性</em>和<em>实例</em>方法，通过<code>self</code>获取</li><li>在类外部获取<em>属性</em>和<em>实例</em>方法，通过对象名获取</li><li>如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址</li><li>通过一个类可以创建多个对象，就好比通过一个模具创建多个实体一样</li><li>但是实例方法是所有对象共享的，只占用一份内存空间。类会通过<code>self</code>来判断是哪个对象调用了实例方法</li></ul><h3 id="4-5、继承"><a href="#4-5、继承" class="headerlink" title="4.5、继承"></a>4.5、继承</h3><p>在程序中，<strong>继承</strong>描述的是多个类之间的所属关系。</p><p><strong>继承</strong>就是当你写一个类时，虽然这个类满足了某些功能但是你又想拓展它的功能，此时你就可以使用继承机制再写一个该类的子类，来完成你需要的功能。</p><p>一旦<strong>子类继承了父类就拥有了父类的方法与域（除私有方法和私有域）</strong>，在子类中也可以<strong>重写</strong>父类的方法，<strong>覆盖</strong>父类中同名的方法，<strong>定义</strong>与父类相同的域实现子类需要的功能。</p><p>继承的优点是<strong>提高代码效率</strong>，<strong>避免代码重写</strong>。 </p><p>如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，<strong>传递</strong>到类B里。那么类A就是<strong>基类</strong>，也叫做<strong>父类</strong>，类B就是<strong>派生类</strong>，也叫做<strong>子类</strong>。  </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 父 类</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">def</span> <span class="token function">print_num</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子 类</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">pass</span>b <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>num<span class="token punctuation">)</span> b<span class="token punctuation">.</span>print_num<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="4-5-1、单继承"><a href="#4-5-1、单继承" class="headerlink" title="4.5.1、单继承"></a>4.5.1、单继承</h4><p><strong>单继承：</strong>子类只继承一个父类。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义一个Person类</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 属性</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"女娲"</span>    <span class="token comment" spellcheck="true"># 实例方法</span>    <span class="token keyword">def</span> <span class="token function">make_person</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" &lt;%s> 造了一个人..."</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义Teacher类，继承了 Person，则Teacher是子类，Person是父类。</span><span class="token keyword">class</span> <span class="token class-name">Chinese</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 子类可以继承父类所有的属性和方法，哪怕子类没有自己的属性和方法，也可以使用父类的属性和方法。</span>    <span class="token keyword">pass</span>panda <span class="token operator">=</span> Chinese<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>panda<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建子类实例对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>panda<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 子类对象可以直接使用父类的属性</span>panda<span class="token punctuation">.</span>make_person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子类对象可以直接使用父类的方法</span></code></pre><p><strong>总结：</strong></p><p>虽然子类没有定义<code>__init__()</code>方法初始化属性，也没有定义实例方法，但是父类有。所以只要创建子类的对象，就默认执行了那个继承过来的<code>__init__()</code>方法</p><p>如果子类需要继承某个父类，需要在定义类时在小括号()中填上父类的类名。父类的<strong>属性、方法</strong>，会被继承给子类</p><h4 id="4-5-2、多继承"><a href="#4-5-2、多继承" class="headerlink" title="4.5.2、多继承"></a>4.5.2、多继承</h4><p><strong>多继承：</strong>子类继承多个父类。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Human</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sex<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sex <span class="token operator">=</span> sex    <span class="token keyword">def</span> <span class="token function">p</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这是Human的方法"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">p</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这是Person的方法"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这是person特有的方法"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Human<span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#要想调用特定父类的构造器可以使用父类名.__init__方式。</span>       Human<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span>sex<span class="token punctuation">)</span>       Person<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span>       self<span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token comment" spellcheck="true"># ------创建对象 -------------</span>stu <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span>stu<span class="token punctuation">.</span>sex<span class="token punctuation">,</span>stu<span class="token punctuation">.</span>grade<span class="token punctuation">)</span>stu<span class="token punctuation">.</span>p<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 提问：这里调用的p()方法是谁的p()方法呢？</span><span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token comment" spellcheck="true">#定义函数</span><span class="token keyword">class</span> <span class="token class-name">Son</span><span class="token punctuation">(</span>Human<span class="token punctuation">,</span> Teacher<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> fan<span class="token punctuation">)</span><span class="token punctuation">:</span>        Human<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> sex<span class="token punctuation">)</span>        Teacher<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fan <span class="token operator">=</span> fanson1 <span class="token operator">=</span> Son<span class="token punctuation">(</span><span class="token string">"jerry"</span><span class="token punctuation">,</span> <span class="token string">"female"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"打球"</span><span class="token punctuation">)</span>son1<span class="token punctuation">.</span>person<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 可以调用父类的父类的方法。</span>son1<span class="token punctuation">.</span>p<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 子类调用众多父类中同名的方法，按继承的顺序查找</span></code></pre><p>在多继承中， 如果<strong>不同的父类</strong>中存在 <strong>同名的方法</strong>，<strong>子类对象</strong>在调用方法时，会调用<strong>哪一个父类中</strong>的方法呢？ </p><p>在<code>Python</code>中，针对<strong>类</strong>提供了一个<strong>内置属性</strong> <code>__mro__</code> 可以查看<strong>方法</strong>搜索顺序。 MRO是<code>method resolution order</code>，主要用于<strong>在多继承时判断 方法、属性的调用路径</strong> </p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#Student是多继承后的类名</span></code></pre><ul><li>在搜索方法时，是按照 <code>__mro__</code> 的输出结果<strong>从左至右</strong>的顺序查找的 </li><li>如果在当前类中<strong>找到方法，就直接执行，不再搜索</strong> </li><li>如果<strong>没有找到，就查找下一个类</strong> 中是否有对应的方法，<strong>如果找到，就直接执行，不再搜索</strong> </li><li>如果找到最后一个类，还没有找到方法，程序报错 </li></ul><h4 id="4-5-3、重写父类方法"><a href="#4-5-3、重写父类方法" class="headerlink" title="4.5.3、重写父类方法"></a>4.5.3、重写父类方法</h4><p>当子类继承父类时，父类的方法满足不了子类的需要，此时可以对父类的方法进行重写</p><p>重写的特点: </p><ul><li>继承关系</li><li>方法名相同</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"人可以奔跑"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token comment" spellcheck="true"># 因为父类的方法满足不了子类的需要，对其进行重写</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s跑的比一般人快"</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>stu <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用方法的时候先从本类去找，如果本来没有再去父类去找，会遵循mro的特点</span>stu<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="4-5-4、属性方法"><a href="#4-5-4、属性方法" class="headerlink" title="4.5.4、属性方法"></a>4.5.4、属性方法</h4><h5 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h5><p><strong>类属性</strong>就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。</p><p>对于公有的类属性，在类外可以通过类对象和实例对象访问</p><p>在定义变量名时， 尽量避免定义以下划线开头的变量</p><ol><li><code>_xxx</code>    “单下划线 “ 开始的成员变量叫做保护变量，意思是只有类对象（即类实例）和子类对象自己能访问到这些变量，需通过类提供的接口进行访问；不能用’from module import *’导入</li><li><code>__xxx</code>   类中的私有变量/方法名 （<code>Python</code>的函数也是对象，所以成员方法称为成员变量也行得通。），” 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</li><li><code>__xxx__</code> 系统定义名字，前后均有一个“双下划线” ，代表<code>python</code>里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。 </li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> <span class="token string">'Tom'</span> <span class="token comment" spellcheck="true"># 公有的类属性</span>    __age <span class="token operator">=</span> <span class="token number">12</span> <span class="token comment" spellcheck="true"># 私有的类属性</span>p <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 正 确</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 正 确</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 错误，不能在类外通过实例对象访问私有的类属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 错误，不能在类外通过类对象访问私有的类属性实例属性(对象属性)</span></code></pre><p>实例属性(对象属性)</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     address <span class="token operator">=</span> <span class="token string">'江苏'</span> <span class="token comment" spellcheck="true"># 类属性</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'xiaowang'</span> <span class="token comment" spellcheck="true"># 实例属性</span>        self<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment" spellcheck="true"># 实例属性</span>p <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">12</span> <span class="token comment" spellcheck="true"># 实例属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#正确</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 正确</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 正确</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 正确</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 错误</span></code></pre><p>通过实例(对象)去修改类属性</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#通过实例(对象)去修改类属性</span><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    country <span class="token operator">=</span> <span class="token string">'china'</span> <span class="token comment" spellcheck="true">#类属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>country<span class="token punctuation">)</span> p <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>country<span class="token punctuation">)</span> p<span class="token punctuation">.</span>country <span class="token operator">=</span> <span class="token string">'japan'</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>country<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实例属性会屏蔽掉同名的类属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>country<span class="token punctuation">)</span><span class="token keyword">del</span> p<span class="token punctuation">.</span>country <span class="token comment" spellcheck="true"># 删除实例属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>country<span class="token punctuation">)</span></code></pre><p><strong>总结</strong></p><p>如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。<br>如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。</p><h5 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h5><p><strong>(1) 类方法</strong></p><p><strong>类方法</strong>是类对象所拥有的方法，需要用修饰器<code>@classmethod</code>来标识其为类方法，对于类方法，第一个参数必须是类对象， 一般以<code>cls</code>作为第一个参数，能够通过实例对象和类对象去访问。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     country <span class="token operator">=</span> <span class="token string">'china'</span><span class="token comment" spellcheck="true">#类方法，用classmethod来进行修饰</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">get_country</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> cls<span class="token punctuation">.</span>countryp <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#可以用过实例对象引用</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#可以通过类对象引用</span></code></pre><p>类方法还有一个用途就是可以对类属性进行修改：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     country <span class="token operator">=</span> <span class="token string">'china'</span>    <span class="token comment" spellcheck="true">#类方法，用classmethod来进行修饰@classmethod</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">get_country</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> cls<span class="token punctuation">.</span>country    @classmethod    <span class="token keyword">def</span> <span class="token function">set_country</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span>country<span class="token punctuation">)</span><span class="token punctuation">:</span>         cls<span class="token punctuation">.</span>country <span class="token operator">=</span> countryp <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#可以用过实例对象访问</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#可以通过类访问</span>p<span class="token punctuation">.</span>set_country<span class="token punctuation">(</span><span class="token string">'japan'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变</span></code></pre><p><strong>(2) 静态方法</strong></p><p>需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     country <span class="token operator">=</span> <span class="token string">'china'</span>    @staticmethod <span class="token comment" spellcheck="true">#静态方法</span>    <span class="token keyword">def</span> <span class="token function">get_country</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> People<span class="token punctuation">.</span>countryp <span class="token operator">=</span> People<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过对象访问静态方法</span>p<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过类访问静态方法</span><span class="token keyword">print</span><span class="token punctuation">(</span>People<span class="token punctuation">.</span>get_country<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>总结</strong></p><p>从类方法和实例方法以及静态方法的定义形式就可以看出来，<strong>类方法</strong>的第一个参数是类对象cls，那么通过cls引用的  必定是类对象的属性和方法； <strong>实例方法</strong>的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。<strong>静态方法</strong>中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类实例对象来引用</p><h3 id="4-6、多态"><a href="#4-6、多态" class="headerlink" title="4.6、多态"></a>4.6、多态</h3><p><strong>多态</strong>：让具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容(功能)的函数。<br><strong>特点</strong>：</p><ul><li>只关心对象的实例方法是否同名，不关心对象所属的类型；</li><li>对象所属的类之间，继承关系可有可无；</li><li>多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；</li><li>多态是调用方法的技巧，不会影响到类的内部设计。</li></ul><p><strong>应用场景</strong>：</p><p><strong>1、对象所属的类之间没有继承关系</strong></p><p>调用同一个函数<code>fly()</code>, 传入不同的参数（对象），可以达成不同的功能</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Duck</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>                                  <span class="token comment" spellcheck="true"># 鸭子类</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"鸭子沿着地面飞起来了"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Swan</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>                                  <span class="token comment" spellcheck="true"># 天鹅类</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"天鹅在空中翱翔"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Plane</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>                                 <span class="token comment" spellcheck="true"># 飞机类</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"飞机隆隆地起飞了"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>                                        <span class="token comment" spellcheck="true"># 实现飞的功能函数</span>    obj<span class="token punctuation">.</span>fly<span class="token punctuation">(</span><span class="token punctuation">)</span>duck <span class="token operator">=</span> Duck<span class="token punctuation">(</span><span class="token punctuation">)</span>fly<span class="token punctuation">(</span>duck<span class="token punctuation">)</span>swan <span class="token operator">=</span> Swan<span class="token punctuation">(</span><span class="token punctuation">)</span>fly<span class="token punctuation">(</span>swan<span class="token punctuation">)</span>plane <span class="token operator">=</span> Plane<span class="token punctuation">(</span><span class="token punctuation">)</span>fly<span class="token punctuation">(</span>plane<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span>运行结果：<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>鸭子沿着地面飞起来了天鹅在空中翱翔飞机隆隆地起飞了</code></pre><p>2、对象所属的类之间有继承关系（应用更广）</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">gradapa</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>money <span class="token operator">=</span> money    <span class="token keyword">def</span> <span class="token function">p</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is gradapa"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">father</span><span class="token punctuation">(</span>gradapa<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>money<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>money<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>job <span class="token operator">=</span> job    <span class="token keyword">def</span> <span class="token function">p</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is father,我重写了父类的方法"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">mother</span><span class="token punctuation">(</span>gradapa<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> money<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>money<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>job <span class="token operator">=</span> job    <span class="token keyword">def</span> <span class="token function">p</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is mother,我重写了父类的方法"</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token number">100</span><span class="token comment" spellcheck="true">#定义一个函数，函数调用类中的p()方法</span><span class="token keyword">def</span> <span class="token function">fc</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>     obj<span class="token punctuation">.</span>p<span class="token punctuation">(</span><span class="token punctuation">)</span>gradapa1 <span class="token operator">=</span> gradapa<span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span> father1 <span class="token operator">=</span> father<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token string">"工人"</span><span class="token punctuation">)</span>mother1 <span class="token operator">=</span> mother<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token string">"老师"</span><span class="token punctuation">)</span>fc<span class="token punctuation">(</span>gradapa1<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#这里的多态性体现是向同一个函数，传递不同参数后，可以实现不同功能.</span>fc<span class="token punctuation">(</span>father1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>fc<span class="token punctuation">(</span>mother1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span>运行结果：<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>this <span class="token keyword">is</span> gradapathis <span class="token keyword">is</span> father<span class="token punctuation">,</span>我重写了父类的方法this <span class="token keyword">is</span> mother<span class="token punctuation">,</span>我重写了父类的方法<span class="token number">100</span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>本节课的和大家普及了<strong>面向对象</strong>这个编程中很重要的思想</li><li>需要掌握对象的创建，属性和方法的调用</li><li>需要掌握继承的使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分享-4-函数</title>
      <link href="/2020/01/06/Python%E5%88%86%E4%BA%AB-4-%E5%87%BD%E6%95%B0/"/>
      <url>/2020/01/06/Python%E5%88%86%E4%BA%AB-4-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python分享第四节"><a href="#Python分享第四节" class="headerlink" title="Python分享第四节"></a>Python分享第四节</h1><p>最近受邀给团队中的小伙伴们分享<code>Python</code>知识，本篇文章是第四节课的基本内容。</p><h2 id="一、课前准备"><a href="#一、课前准备" class="headerlink" title="一、课前准备"></a>一、课前准备</h2><ol><li>复习<code>Python</code>的基础语法与基础数据类型</li></ol><h2 id="二、课堂主题"><a href="#二、课堂主题" class="headerlink" title="二、课堂主题"></a>二、课堂主题</h2><p>第四课主要学习<code>Python</code>基础中函数的创建与调用以及参数的传递。</p><h2 id="三、本节目标"><a href="#三、本节目标" class="headerlink" title="三、本节目标"></a>三、本节目标</h2><p>1、掌握<code>Python</code>中函数的创建和使用</p><p>2、掌握<code>Python</code>中函数的调用顺序以及参数的使用</p><h2 id="四、知识要点"><a href="#四、知识要点" class="headerlink" title="四、知识要点"></a>四、知识要点</h2><h3 id="4-1、函数的简介"><a href="#4-1、函数的简介" class="headerlink" title="4.1、函数的简介"></a>4.1、函数的简介</h3><p>如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以<strong>把具有独立功能的代码块组织为一个小模块</strong>，这就是<strong>函数</strong>。你已经知道<code>Python</code>提供了许多内建函数，比如<code>print()</code>。但你也可以自己创建函数，这被叫做用户自定义函数。<br>例如：我们知道圆的面积计算公式为：$S = πr^2$<br>当我们知道半径$r$的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p><pre class=" language-python"><code class="language-python">r1 <span class="token operator">=</span> <span class="token number">12.34</span>r2 <span class="token operator">=</span> <span class="token number">9.08</span>r3 <span class="token operator">=</span> <span class="token number">73.1</span>s1 <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">*</span> r1 <span class="token operator">*</span> r1 s2 <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">*</span> r2 <span class="token operator">*</span> r2 s3 <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">*</span> r3 <span class="token operator">*</span> r3</code></pre><p>当代码出现有规律的重复的时候你就会发现，每次写$3.14 * x * x$不仅很麻烦，而且如果要把3.14改成3.14159265359的时候，得全部替换。</p><p>有了函数，我们就不再每次写$S = 3.14 * x * x$，而是写成更有意义的函数调用<strong>s = area_of_circle(x)</strong>， 而函数<code>area_of_circle</code>本身只需要写一次，就可以多次调用。</p><p>基本上所有的高级语言都支持函数，<code>Python</code>也不例外。<code>Python</code>不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p><h3 id="4-2、函数的定义与使用"><a href="#4-2、函数的定义与使用" class="headerlink" title="4.2、函数的定义与使用"></a>4.2、函数的定义与使用</h3><h4 id="4-2-1、定义函数"><a href="#4-2-1、定义函数" class="headerlink" title="4.2.1、定义函数"></a>4.2.1、定义函数</h4><p>定义函数的格式如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     代码<span class="token comment" spellcheck="true"># 定义一个函数，能够完成打印信息的功能</span><span class="token keyword">def</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-------------------------'</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Life is short ,use Python'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-------------------------'</span><span class="token punctuation">)</span> </code></pre><h4 id="4-2-2、调用函数"><a href="#4-2-2、调用函数" class="headerlink" title="4.2.2、调用函数"></a>4.2.2、调用函数</h4><p>定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它调用函数很简单的，通过 <strong>函数名()</strong> 即可完成调用</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义完函数后，函数是不会自动执行的，需要调用它才可以</span>printInfo<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>注意</strong>:</p><ul><li>每次调用函数时，函数都会从头开始执行，当这个函数中的代码执行完毕后，意味着调用结束了</li><li>如果函数中执行到了<code>return</code>也会结束函数（后面会讲到）</li></ul><h3 id="4-3、函数的文档说明"><a href="#4-3、函数的文档说明" class="headerlink" title="4.3、函数的文档说明"></a>4.3、函数的文档说明</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''用来完成对2个数求和'''</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token operator">%</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span>输出：<span class="token number">33</span></code></pre><p>可以使用<code>help(函数名)</code>查看函数的相关说明</p><pre class=" language-python"><code class="language-python">help<span class="token punctuation">(</span>test<span class="token punctuation">)</span></code></pre><p>也可是使用<code>test. doc</code>直接查看文档说明 </p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token string">"用来完成对2个数求和"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token operator">%</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>__doc__<span class="token punctuation">)</span>输出：用来完成对<span class="token number">2</span>个数求和</code></pre><h3 id="4-4、函数的参数"><a href="#4-4、函数的参数" class="headerlink" title="4.4、函数的参数"></a>4.4、函数的参数</h3><p><code>Python</code>的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用<strong>默认参数、可变参数和关键字参数等</strong>，使得函数定义出来的接口不但能处理复杂的参数，还可以简化调用者的代码。</p><h4 id="4-4-1、位置参数"><a href="#4-4-1、位置参数" class="headerlink" title="4.4.1、位置参数"></a>4.4.1、位置参数</h4><p>假设我们有一个需求使计算数字的平方，我们先写一个计算$x^2$ 的函数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x</code></pre><p>对于power(x)函数，参数x就是一个<strong>位置参数</strong>。</p><p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code>：</p><pre class=" language-python"><code class="language-python">power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>输出：<span class="token number">25</span>power<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> 输出：<span class="token number">225</span></code></pre><p>现在，如果我们要计算 $x^3$怎么办？</p><p>可以再定义一个$power3$函数，但是如果要计算 $x^4 $、$ x^5$ ……怎么办？我们不可能定义无限多个函数。</p><p>你也许想到可以再增加一个参数，把<code>power(x)</code>修改为<code>power(x, n)</code>，用来计算$ x^n $就可以写成如下形式：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token triple-quoted-string string">"""计算x的n次方       x:底数       n:指数    """</span>    s <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>         s <span class="token operator">=</span> s <span class="token operator">*</span> x    <span class="token keyword">return</span> s</code></pre><p>对于这个修改后的<code>power(x, n)</code>函数，可以计算任意$n$次方：</p><pre class=" language-python"><code class="language-python">power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">25</span>power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token number">125</span></code></pre><p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值<strong>必须严格按照位置顺序</strong>依次赋给参数<code>x</code>和<code>n</code>，而且<strong>一个参数都不能少传</strong>。</p><h4 id="4-4-2、默认参数"><a href="#4-4-2、默认参数" class="headerlink" title="4.4.2、默认参数"></a>4.4.2、默认参数</h4><p>新的<code>power(x, n)</code>函数定义没有问题，但是旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p><pre class=" language-python"><code class="language-python">power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span> File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>TypeError<span class="token punctuation">:</span> power<span class="token punctuation">(</span><span class="token punctuation">)</span> missing <span class="token number">1</span> required positional argument<span class="token punctuation">:</span> <span class="token string">'n'</span></code></pre><p><code>Python</code>的错误信息很明确：调用函数<code>power()</code>缺少了一个位置参数<code>n</code>。</p><p>这个时候，默认参数就派上用场了。由于我们经常计算$ x^2 $，所以完全可以把第二个参数n的默认值设定为2：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     s <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>         s <span class="token operator">=</span> s <span class="token operator">*</span> x    <span class="token keyword">return</span> s</code></pre><p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p><pre class=" language-python"><code class="language-python">power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token number">25</span>power<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">25</span></code></pre><p>而对于<code>n &gt; 2</code>的其他情况，就必须明确地传入<code>n</code>，比如<code>power(5, 3)</code>。</p><p>从上面的例子可以看出，默认参数<strong>可以简化函数的调用</strong>。设置默认参数时，有几点要注意： </p><ul><li>一是<strong>必选参数在前，默认参数在后</strong>，否则<code>Python</code>的解释器会报错；</li><li>二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li></ul><h4 id="4-4-3、使用默认参数的好处"><a href="#4-4-3、使用默认参数的好处" class="headerlink" title="4.4.3、使用默认参数的好处"></a>4.4.3、使用默认参数的好处</h4><p>举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">enroll</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'gender:'</span><span class="token punctuation">,</span> gender<span class="token punctuation">)</span></code></pre><p>这样，调用<code>enroll()</code>函数只需要传入两个参数：</p><pre class=" language-python"><code class="language-python">enroll<span class="token punctuation">(</span><span class="token string">'Sarah'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span> 输出：name<span class="token punctuation">:</span> Sarahgender<span class="token punctuation">:</span> F</code></pre><p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。<br>我们可以把年龄和城市设为默认参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">enroll</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Nanjing'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'gender:'</span><span class="token punctuation">,</span> gender<span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'age:'</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'city:'</span><span class="token punctuation">,</span> city<span class="token punctuation">)</span></code></pre><p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p><pre class=" language-python"><code class="language-python">enroll<span class="token punctuation">(</span><span class="token string">'Sarah'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span>输出：name<span class="token punctuation">:</span> Sarahgender<span class="token punctuation">:</span> F age<span class="token punctuation">:</span> <span class="token number">6</span>city<span class="token punctuation">:</span> Nanjing</code></pre><p>只有与默认参数不符的学生才需要提供额外的信息：</p><pre class=" language-python"><code class="language-python">enroll<span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>enroll<span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'ANhui'</span><span class="token punctuation">)</span></code></pre><p>从上面的例子可以看出，<strong>默认参数降低了函数调用的难度</strong>，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><p>当有多个默认参数时，<strong>可以按顺序</strong>提供默认参数对函数进行调用：</p><pre class=" language-python"><code class="language-python">enroll<span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span></code></pre><p>上方代码的意思是：除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p><p>与此同时，<strong>也可以不按顺序提供部分默认参数</strong>。当不按顺序提供部分默认参数时，需要把参数名写上。比如：</p><pre class=" language-python"><code class="language-python">enroll<span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span>  city<span class="token operator">=</span><span class="token string">'Tianjin'</span><span class="token punctuation">)</span></code></pre><p>上方代码的意思是：city参数用传进去的值，其他默认参数继续使用默认值。</p><p><strong>注意</strong>：默认参数有个最大的坑，演示如下：</p><p>先定义一个函数，传入一个list，添加一个END再返回：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_end</span><span class="token punctuation">(</span>L<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     L<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> L</code></pre><p>当你正常调用时，结果似乎不错：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'END'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token string">'END'</span><span class="token punctuation">]</span></code></pre><p>当你使用默认参数调用时，一开始结果也是对的：</p><pre><code>&gt;&gt;&gt; add_end() [&#39;END&#39;]</code></pre><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">'END'</span><span class="token punctuation">,</span> <span class="token string">'END'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'END'</span><span class="token punctuation">,</span> <span class="token string">'END'</span><span class="token punctuation">,</span> <span class="token string">'END'</span><span class="token punctuation">]</span></code></pre><p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了’END’后的那个<code>list</code>。<br>原因解释如下：<br><code>Python</code>函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>。<br>因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>， 所以 每次调用该函数如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>定义默认参数要牢记一点：<strong>默认参数必须指向不可变对象！</strong></p><p><strong>可变对象与不可变对象</strong>的解释可以参照上次发给大家的<code>jupyter</code>笔记中的<em>02.07-mutable-and-immutable-data-types.ipynb<em>，如果想要深入理解可变与不可变，请参照</em>02.13-how-python-assignment-works.ipynb</em></p><p>要修改上面的例子，我们可以用<strong>None</strong>这个不变对象来实现：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_end</span><span class="token punctuation">(</span>L<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">if</span> L <span class="token keyword">is</span> None<span class="token punctuation">:</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> L</code></pre><p>现在，无论调用多少次，都不会有问题：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">'END'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> add_end<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">'END'</span><span class="token punctuation">]</span></code></pre><p>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？<br>因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。<br>此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。<br>我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><h4 id="4-4-4、可变参数"><a href="#4-4-4、可变参数" class="headerlink" title="4.4.4、可变参数"></a>4.4.4、可变参数</h4><p>在<code>Python</code>函数中，还可以定义可变参数。顾名思义，可变参数就是<strong>传入的参数个数是可变的</strong>，可以是1个、2个到n个，还可以是0个。</p><p>我们以数学题为例子，给定一组数字<code>a，b，c……</code>，请计算$a^2 + b^2 + c^2 +..$ 。</p><p>按照先前的知识，要定义出这个函数，我们必须<strong>确定输入的参数</strong>。由于参数个数不确定，我们首先想到可以把<code>a, b, c……</code>作为一个<code>lis</code>t或<code>tuple</code>传进来，这样函数可以定义如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calc</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>     sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> n <span class="token operator">*</span> n     <span class="token keyword">return</span> sum</code></pre><p>但是调用的时候，需要先<strong>组装</strong>出一个<code>list</code>或<code>tuple</code>：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">14</span><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">84</span></code></pre><p>我们可不可以把调用函数的方式可以简化成下面这样呢？</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token number">14</span><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token number">84</span></code></pre><p><code>Python</code>可以<strong>把函数的参数改为可变参数</strong>：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token operator">*</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>     sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> n <span class="token operator">*</span> n     <span class="token keyword">return</span> sum</code></pre><p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个*号。在函数内部，<strong>参数numbers接收到的是一个tuple</strong>，因此函数代码完全不变。但是在调用该函数时，可以传入任意个参数，包括<code>0</code>个参数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token number">0</span></code></pre><p>如果已经有一个<code>list</code>或者<code>tuple</code>，要调用一个可变参数怎么办？可以这样做：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token number">14</span></code></pre><p>这种写法当然是可行的，问题是太繁琐。为了解决这个问题所，<code>Python</code>允许你在<code>list</code>或<code>tuple</code>前面加一个*号，把<code>list</code>或<code>tuple</code>的元素变成可变参数传进去：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> calc<span class="token punctuation">(</span><span class="token operator">*</span>nums<span class="token punctuation">)</span> <span class="token number">14</span></code></pre><p>*nums表示把<code>nums</code>这个<code>list</code>的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p><h4 id="4-4-5、关键字参数"><a href="#4-4-5、关键字参数" class="headerlink" title="4.4.5、关键字参数"></a>4.4.5、关键字参数</h4><p>试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他例如籍贯、性别等等都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 </p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'age:'</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token string">'other:'</span><span class="token punctuation">,</span> kw<span class="token punctuation">)</span></code></pre><p>函数<code>person()</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Michael age<span class="token punctuation">:</span> <span class="token number">30</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>也可以传入任意个数的关键字参数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Nanjing'</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Bob age<span class="token punctuation">:</span> <span class="token number">35</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Nanjing'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Data Analyst'</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Adam age<span class="token punctuation">:</span> <span class="token number">45</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'gender'</span><span class="token punctuation">:</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">}</span></code></pre><p>在上面函数的声明中，<code>**kw</code>是关键字参数，<code>kw</code>接收的是一个<code>dict</code>，关键字参数允许你传入<strong>0个或任意个含参数名的参数</strong>，这些关键字参数在函数内部自动组装为一个<code>dict</code></p><p>在这里你可能会想到一个和可变参数同样的问题，如果我本身就有个一个字典，我应该怎么样直接使用呢？</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> extra <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Nanjing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> city<span class="token operator">=</span>extra<span class="token punctuation">[</span><span class="token string">'city'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> job<span class="token operator">=</span>extra<span class="token punctuation">[</span><span class="token string">'job'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Jack age<span class="token punctuation">:</span> <span class="token number">24</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Nanjing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">}</span></code></pre><p>当然，上面复杂的调用可以用简化的写法：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> extra <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Nanjing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token operator">**</span>extra<span class="token punctuation">)</span>name<span class="token punctuation">:</span> Jack age<span class="token punctuation">:</span> <span class="token number">24</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Nanjing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">}</span></code></pre><p>**extra表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的**kw参数，<code>kw</code>将获得一个<code>dict</code>。</p><h4 id="4-4-6、命名关键字参数"><a href="#4-4-6、命名关键字参数" class="headerlink" title="4.4.6、命名关键字参数"></a>4.4.6、命名关键字参数</h4><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部对传入的kw检查。<br>仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">if</span> <span class="token string">'city'</span> <span class="token keyword">in</span> kw<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#有city参数</span>        <span class="token keyword">pass</span>    <span class="token keyword">if</span> <span class="token string">'job'</span> <span class="token keyword">in</span> kw<span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 有job参数</span>        <span class="token keyword">pass</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'age:'</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token string">'other:'</span><span class="token punctuation">,</span> kw<span class="token punctuation">)</span></code></pre><p>但是调用者仍可以传入<strong>不受限制的关键字参数</strong>：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Nanjing'</span><span class="token punctuation">,</span> addr<span class="token operator">=</span><span class="token string">'Chaoyang'</span><span class="token punctuation">,</span> zipcode<span class="token operator">=</span><span class="token number">123456</span><span class="token punctuation">)</span></code></pre><p>如果要限制关键字参数的名字，就可以用<strong>命名关键字参数</strong>，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span></code></pre><p>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为<strong>命名关键字参数</strong>。  调用方式如下：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Nanjing'</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Data Analyst'</span><span class="token punctuation">)</span>Jack <span class="token number">24</span> Nanjing Data Analyst</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span></code></pre><p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token string">'Nanjing'</span><span class="token punctuation">,</span> <span class="token string">'Data Analyst'</span><span class="token punctuation">)</span> Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>TypeError<span class="token punctuation">:</span> person<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">2</span> positional arguments but <span class="token number">4</span> were given</code></pre><p>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。<br>命名关键字参数可以有缺省值，从而简化调用：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Nanjing'</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span></code></pre><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Data Analyst'</span><span class="token punctuation">)</span>Jack <span class="token number">24</span> Nanjing Data Analyst</code></pre><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">pass</span></code></pre><p>缺少 *，<code>city</code>和<code>job</code>被视为位置参数</p><h4 id="4-4-7、参数组合"><a href="#4-4-7、参数组合" class="headerlink" title="4.4.7、参数组合"></a>4.4.7、参数组合</h4><p>在<code>Python</code>中定义函数，可以用<strong>必选参数、默认参数、可变参数、关键字参数和命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<br><strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong>。<br>比如定义一个函数，包含上述若干种参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a ='</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token string">'b ='</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'c ='</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">'args ='</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token string">'kw ='</span><span class="token punctuation">,</span> kw<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">f2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a ='</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token string">'b ='</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'c ='</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">'d ='</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token string">'kw ='</span><span class="token punctuation">,</span> kw<span class="token punctuation">)</span></code></pre><p>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">0</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">3</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">3</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">3</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">,</span> ext<span class="token operator">=</span>None<span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">0</span> d <span class="token operator">=</span> <span class="token number">99</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'ext'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span></code></pre><p>最神奇的是通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'#'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f1<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">3</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">)</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'#'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'#'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> f2<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token number">1</span> b <span class="token operator">=</span> <span class="token number">2</span> c <span class="token operator">=</span> <span class="token number">3</span> d <span class="token operator">=</span> <span class="token number">88</span> kw <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'#'</span><span class="token punctuation">}</span></code></pre><p>所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。<br>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p><h3 id="4-5、函数的返回值"><a href="#4-5、函数的返回值" class="headerlink" title="4.5、函数的返回值"></a>4.5、函数的返回值</h3><h4 id="4-5-1、“返回值“介绍"><a href="#4-5-1、“返回值“介绍" class="headerlink" title="4.5.1、“返回值“介绍"></a>4.5.1、“返回值“介绍</h4><p><strong>所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果</strong></p><h4 id="4-5-2、带有返回值的函数"><a href="#4-5-2、带有返回值的函数" class="headerlink" title="4.5.2、带有返回值的函数"></a>4.5.2、带有返回值的函数</h4><p>想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add2num</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>     c <span class="token operator">=</span> a<span class="token operator">+</span>b    <span class="token keyword">return</span> c<span class="token comment" spellcheck="true"># 或者</span><span class="token keyword">def</span> <span class="token function">add2num</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">return</span> a<span class="token operator">+</span>b</code></pre><h4 id="4-5-3、保存函数的返回值"><a href="#4-5-3、保存函数的返回值" class="headerlink" title="4.5.3、保存函数的返回值"></a>4.5.3、保存函数的返回值</h4><p>如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存.<br>保存函数的返回值示例如下:</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义函数</span><span class="token keyword">def</span> <span class="token function">add2num</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">return</span> a<span class="token operator">+</span>b</code></pre><p>调用函数，顺便保存函数的返回值</p><pre class=" language-python"><code class="language-python">result <span class="token operator">=</span> add2num<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h4 id="4-5-4、在Python中怎样返回多个值"><a href="#4-5-4、在Python中怎样返回多个值" class="headerlink" title="4.5.4、在Python中怎样返回多个值"></a>4.5.4、在<code>Python</code>中怎样返回多个值</h4><p><strong>可以使用多个return吗？</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_nums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---1---"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---2---"</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---3---"</span><span class="token punctuation">)</span></code></pre><p>实践后我们会发现<code>return 1</code>后面的代码都不会被执行到。因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数<br>举个例子：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_nums</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---1---"</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---2---"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> num<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---3---"</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> num<span class="token operator">+</span><span class="token number">2</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---4---"</span><span class="token punctuation">)</span>result1 <span class="token operator">=</span> create_nums<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 打 印 101 </span>result2 <span class="token operator">=</span> create_nums<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 打印202</span></code></pre><p>那么既然不可以使用多个<code>return</code>，是否可以在一个<code>return</code>中返回多个值呢？</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">divid</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>     shang <span class="token operator">=</span> a<span class="token operator">//</span>b     yushu <span class="token operator">=</span> a<span class="token operator">%</span>b    <span class="token keyword">return</span> shang<span class="token punctuation">,</span> yushu    result <span class="token operator">=</span> divid<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 输出(2, 1)</span></code></pre><p><code>return</code>后面返回元组，列表、字典等</p><h3 id="4-6、递归函数"><a href="#4-6、递归函数" class="headerlink" title="4.6、递归函数"></a>4.6、递归函数</h3><p>在函数内部，可以调用其他函数。如果一个函数<strong>在内部调用自身本身</strong>，这个函数就是<strong>递归函数</strong>。</p><p>举个例子，我们来计算阶乘$n! = 1 * 2 * 3 * … * n$，用函数<code>fact(n)</code>表示，可以看出：</p><p>$$fact(n) = n! = 1 * 2 * 3 * … * (n-1) * n = (n-1)! * n = fact(n-1) * n$$</p><p>所以，<code>fact(n)</code>可以表示为$n * fact(n-1)$，只有<code>n=1</code>时需要特殊处理。于是，<code>fact(n)</code>用递归的方式写出来就是：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">return</span> n <span class="token operator">*</span> fact<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>上面就是一个递归函数。可以试试：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fact<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> fact<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token number">120</span><span class="token operator">>></span><span class="token operator">></span> fact<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token number">9332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615</span><span class="token number">6518286253697920827223758251185210916864000000000000000000000000</span></code></pre><p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p><pre class=" language-python"><code class="language-python"><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> fact<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> <span class="token number">5</span> <span class="token operator">*</span> fact<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> fact<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">4</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">3</span>    <span class="token operator">*</span> fact<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">4</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">3</span>    <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> fact<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">4</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">3</span>    <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">4</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">3</span>    <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token punctuation">(</span><span class="token number">4</span>    <span class="token operator">*</span>    <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token number">5</span>    <span class="token operator">*</span>    <span class="token number">24</span>            <span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> <span class="token number">120</span></code></pre><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p><h3 id="4-7、局部变量"><a href="#4-7、局部变量" class="headerlink" title="4.7、局部变量"></a>4.7、局部变量</h3><p><strong>局部变量</strong>：就是在函数内部定义的变量。<br>作用范围是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的。因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量。<br>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储。<br>当函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 局部变量</span>    score <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"分数:"</span><span class="token punctuation">,</span> score<span class="token punctuation">)</span> show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(score)</span></code></pre><h3 id="4-8、全局变量"><a href="#4-8、全局变量" class="headerlink" title="4.8、全局变量"></a>4.8、全局变量</h3><h4 id="4-8-1、全局变量的定义"><a href="#4-8-1、全局变量的定义" class="headerlink" title="4.8.1、全局变量的定义"></a>4.8.1、全局变量的定义</h4><p>如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义全局变量</span>a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 虽然没有定义变量a但是依然可以获取其数据</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 虽然没有定义变量a但是依然可以获取其数据</span><span class="token comment" spellcheck="true"># 调用函数</span>test1<span class="token punctuation">(</span><span class="token punctuation">)</span> test2<span class="token punctuation">(</span><span class="token punctuation">)</span>运行结果<span class="token punctuation">:</span> <span class="token number">100</span><span class="token number">100</span></code></pre><h4 id="4-8-2、全局变量和局部变量名字相同问题"><a href="#4-8-2、全局变量和局部变量名字相同问题" class="headerlink" title="4.8.2、全局变量和局部变量名字相同问题"></a>4.8.2、全局变量和局部变量名字相同问题</h4><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 定义局部变量</span>    a <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---test1---%d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#修改</span>    a <span class="token operator">=</span> <span class="token number">200</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'修改后的%d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a = %d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span>test1<span class="token punctuation">(</span><span class="token punctuation">)</span> test2<span class="token punctuation">(</span><span class="token punctuation">)</span>结果：<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test1<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">300</span>修改后的<span class="token number">200</span> a <span class="token operator">=</span> <span class="token number">100</span></code></pre><h4 id="4-8-3、修改全局变量"><a href="#4-8-3、修改全局变量" class="headerlink" title="4.8.3、修改全局变量"></a>4.8.3、修改全局变量</h4><p>函数中进行使用全局变量时可否进行修改呢？</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> a    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'修改之前：%d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#修改</span>    a <span class="token operator">=</span> <span class="token number">200</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'修改后的%d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a = %d'</span><span class="token operator">%</span>a<span class="token punctuation">)</span>test1<span class="token punctuation">(</span><span class="token punctuation">)</span> test2<span class="token punctuation">(</span><span class="token punctuation">)</span>结果：修改之前：<span class="token number">100</span> 修改后的<span class="token number">200</span>a <span class="token operator">=</span> <span class="token number">200</span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>本节课的所有知识点全是重点，后面的学习离不开基础语法</li><li>需要着重掌握的是函数的定义以及参数的传递</li><li>局部变量和全局变量的定义和使用</li><li>所有的代码尽量都自己写一遍，练习是学习编程最简单的途径</li></ul><h2 id="六、作业"><a href="#六、作业" class="headerlink" title="六、作业"></a>六、作业</h2><p>1、分别使用<strong>循环</strong>和<strong>递归</strong>编写一个斐波那契计算函数(斐波那契数列：1,1,2,3,5,8,13…从第三项开始每项等于前两项之和)</p><p>2、 编写一个函数，输入<code>n</code>为偶数时，调用函数求$1/2+1/4+…+1/n$,当输入<code>n</code>为奇数时，调用函数求$1/1+1/3+…+1/n$</p><h2 id="七、分享"><a href="#七、分享" class="headerlink" title="七、分享"></a>七、分享</h2><p><a href="https://lh3.googleusercontent.com/a0iQG7x5uYWS9vMIXhnOH4yq_NWJi64t2iJwztA02gEPITB6mfdV_2zhD-IGhlHTmp5SClpUPA=w440-h280-e365" target="_blank" rel="noopener">沙拉查词</a>:是一个 chrome的扩展程序。沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语，支持复杂的划词操作、网页翻译、生词本与 PDF 浏览。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分享-3-基础数据类型</title>
      <link href="/2020/01/06/Python%E5%88%86%E4%BA%AB-3-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/06/Python%E5%88%86%E4%BA%AB-3-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python分享第三节"><a href="#Python分享第三节" class="headerlink" title="Python分享第三节"></a>Python分享第三节</h1><p>最近受邀给团队中的小伙伴们分享<code>Python</code>知识，本篇文章是第三节课的基本内容。</p><h2 id="一、课前准备-amp-回顾"><a href="#一、课前准备-amp-回顾" class="headerlink" title="一、课前准备&amp;回顾"></a>一、课前准备&amp;回顾</h2><p>1、复习<code>Python</code>基本语法</p><p>2、上次课的题目讲解</p><h2 id="二、课堂主题"><a href="#二、课堂主题" class="headerlink" title="二、课堂主题"></a>二、课堂主题</h2><p>第三课主要学习<code>Python</code>的基础，大体包含：<strong>列表、元组、字典、集合</strong>等<code>Python</code>中数据容器的基础知识点</p><h2 id="三、本节目标"><a href="#三、本节目标" class="headerlink" title="三、本节目标"></a>三、本节目标</h2><p>1、掌握<code>Python</code>中各种数据容器的创建和使用</p><p>2、掌握<code>Python</code>中各种容器对数据存储的方式和特点</p><h2 id="四、知识要点"><a href="#四、知识要点" class="headerlink" title="四、知识要点"></a>四、知识要点</h2><h3 id="4-1、字符串"><a href="#4-1、字符串" class="headerlink" title="4.1、字符串"></a>4.1、字符串</h3><p><a href="http://naotu.baidu.com/file/a916fec55145c1f89449b4243dd9153e?token=0aef0a143f12e61f" target="_blank" rel="noopener">字符串的思维导图</a></p><h4 id="4-1-1、字符串的定义"><a href="#4-1-1、字符串的定义" class="headerlink" title="4.1.1、字符串的定义"></a>4.1.1、字符串的定义</h4><p>在这里简单的介绍一下字符串类型，因为字符串不仅仅是<code>Python</code>中重要的概念，也在所有变成语言中都有着很重要的地位。</p><p>在<code>Python</code>中，<strong>字符串是不可变类型对象</strong>。字符串的声明有<strong>三</strong>种形式：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#使用单引号定义字符串</span>a <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token comment" spellcheck="true">#使用双引号定义字符串</span>a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token comment" spellcheck="true">#使用三引号定义多行字符串变量</span>a <span class="token operator">=</span> <span class="token triple-quoted-string string">"""hellohello"""</span></code></pre><h4 id="4-1-2、下标和分片"><a href="#4-1-2、下标和分片" class="headerlink" title="4.1.2、下标和分片"></a>4.1.2、下标和分片</h4><h5 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h5><p>下标在<code>Python</code>中的概念就是编号的意思。字符串、元组、列表等都会经常用到下标的概念，我们可以根据下标找到他们所对应的元素，就好像你元旦去看电影，要根据电影票的座位号找到对应的位置。</p><p>现在思考这样一个问题，现在我们创建了一个新的字符串</p><pre class=" language-python"><code class="language-python">name<span class="token operator">=</span><span class="token string">'zhangsan'</span></code></pre><p>现在我们想获取名字为<code>name</code>字符串里面的<code>a</code>字符，根据我们现有的知识，应该如何获取呢？</p><p>我们可以通过上节课学习过的<code>for</code>循环来遍历这个字符串，通过这种方法来取出字符串中的字符，但是<code>Python</code>给我们提供了更为简便的方法，我们可以通过<strong>下标</strong>来取数<code>a</code>字符</p><pre class=" language-python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'zhangsan'</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>需要注意的是，在<code>Python</code>中，字符串的==下标是从0开始的==。</p><p><code>SQL</code>中和<code>Excel</code>中同样有函数可以对字符串进行切片操作</p><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>我们可以利用下标索引获取字符串里对应的一个元素，但是如果想要<strong>截取一段元素</strong>，就需要用到切片操作。</p><p>切片是指对操作的对象截取其中的一部分的操作。 字符串、列表、元组都支持切片操作。 <code>Python</code>中直接为我们提供了灵活的字符串切片操作。</p><p>切片的语法: <strong>[起始:结束:步长]</strong></p><pre class=" language-python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'abcdef'</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#取下标0、2的字符</span>运行结果：abc<span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#取下标3、4的字符</span>运行结果：de<span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#取下标为2开始到最后的字符</span>运行结果<span class="token punctuation">:</span>cdef</code></pre><p><code>Python</code>中的切片支持<strong>负数</strong>：</p><pre class=" language-python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'abcdef'</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#取下标1开始到最后第二个之间的字符</span>运行结果：bcdea <span class="token operator">=</span> <span class="token string">"abcdef"</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token string">'abc'</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token string">'ace'</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token string">''</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token string">'bd'</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token string">'fdb'</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token string">'fd'</span></code></pre><h4 id="4-1-3、字符串的常见操作"><a href="#4-1-3、字符串的常见操作" class="headerlink" title="4.1.3、字符串的常见操作"></a>4.1.3、字符串的常见操作</h4><p>如果有一串字符串为<code>my_str = &quot;hello world haha&quot;</code>，以下是常用的函数操作</p><h5 id="find、rfind"><a href="#find、rfind" class="headerlink" title="find、rfind"></a>find、rfind</h5><p><code>find()</code>检测<code>str</code>是否包含在<code>my_str</code>中，如果存在返回开始的索引值，否则返回-1</p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>find<span class="token punctuation">(</span>str<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> end<span class="token operator">=</span>len<span class="token punctuation">(</span>mystr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>例如</p><pre class=" language-python"><code class="language-python">mystr <span class="token operator">=</span> <span class="token string">'hello world kkb'</span>mystr<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"kkb"</span><span class="token punctuation">)</span>运行结果为<span class="token punctuation">:</span><span class="token number">12</span>mystr <span class="token operator">=</span> <span class="token string">'hello world kkb'</span>mystr<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"kkb"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#在mstr字符串0-10下标范围查询</span>运行结果<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span></code></pre><p>可以使用<code>in</code>来判断</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> str <span class="token keyword">in</span> my_str<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"包含"</span><span class="token punctuation">)</span></code></pre><p><code>rfind()</code>类似于 <code>find()</code> 函数，不过是从右边开始查找  </p><h5 id="index、rindex"><a href="#index、rindex" class="headerlink" title="index、rindex"></a>index、rindex</h5><p><code>index()</code>和<code>find()</code>方法类似，区别在与如果<code>str</code>不在<code>mystr</code>中会报异常</p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>index<span class="token punctuation">(</span>str<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> end<span class="token operator">=</span>len<span class="token punctuation">(</span>mystr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>例如:  </p><pre class=" language-python"><code class="language-python">mystr <span class="token operator">=</span> <span class="token string">'hello world kkb'</span>mystr<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span>运行结果<span class="token punctuation">:</span>控制台会直接报错<span class="token punctuation">(</span>Vale Error<span class="token punctuation">:</span>substring <span class="token operator">not</span> found<span class="token punctuation">)</span></code></pre><p><code>rindex()</code>类似于 <code>index()</code>，不过是从右边开始  </p><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>返回 <code>str</code> 在<code>start</code>和<code>end</code>之间 在 <code>mystr</code>中出现的次数</p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>count<span class="token punctuation">(</span>str<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> end<span class="token operator">=</span>len<span class="token punctuation">(</span>mystr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>例如:  </p><pre class=" language-python"><code class="language-python">mystr <span class="token operator">=</span> <span class="token string">'hello world kkb and kkb'</span>mystr<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'kkb'</span><span class="token punctuation">)</span>运行结果<span class="token punctuation">:</span><span class="token number">2</span></code></pre><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>把 <code>mystr</code> 中的 <code>str1</code> 替换成 <code>str2</code> ,如果 <code>count</code> 指定，则替换不超过 <code>count</code> 次  </p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">,</span> mystr<span class="token punctuation">.</span>count<span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="split"><a href="#split" class="headerlink" title="split"></a>split</h5><p>以 <code>str</code> 为分隔符切片<code>mystr</code> ，如果 <code>maxsplit</code> 有指定值，则仅分隔 <code>maxsplit</code> 个字符</p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>split<span class="token punctuation">(</span>str<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre><h5 id="capitallze"><a href="#capitallze" class="headerlink" title="capitallze"></a>capitallze</h5><p>把字符串的第一个字符大写  </p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="title"><a href="#title" class="headerlink" title="title"></a>title</h5><p>把字符串的每个英文单词第一个字符大写  </p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token string">"hello kkb"</span>a<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>运行结果<span class="token string">'Hello Kkb'</span></code></pre><h5 id="startswith、endswith"><a href="#startswith、endswith" class="headerlink" title="startswith、endswith"></a>startswith、endswith</h5><p>检查字符串是否是以<code>str</code>开头或结尾, 是则返回 True，否则返回 False  </p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span>hello<span class="token punctuation">)</span>mystr<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><h5 id="lower、upper"><a href="#lower、upper" class="headerlink" title="lower、upper"></a>lower、upper</h5><p>转换 <code>mystr</code> 中所有大写/小写字符为小写/大写</p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>mystr<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="lstrip、rstrip、strip"><a href="#lstrip、rstrip、strip" class="headerlink" title="lstrip、rstrip、strip"></a>lstrip、rstrip、strip</h5><p><code>lstrip()</code>删除 <code>mystr</code> 左边的空白字符  </p><p><code>rstrip()</code>删除 <code>mystr</code> 字符串末尾的空白字符  </p><p><code>strip()</code>删除 <code>mystr</code> 字符串两端的空白字符  </p><h5 id="partition、rpartition"><a href="#partition、rpartition" class="headerlink" title="partition、rpartition"></a>partition、rpartition</h5><p><code>partition()</code>把<code>mystr</code>以 <code>str</code> 分割成三部分, <code>str</code>前， <code>str</code>和<code>str</code>后  </p><p><code>rpartition()</code>类似于 <code>partition()</code>函数,不过是从右边开始.  </p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>str<span class="token punctuation">)</span>mystr<span class="token punctuation">.</span>rpartition<span class="token punctuation">(</span>str<span class="token punctuation">)</span></code></pre><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p><code>mystr</code>中每个元素后插入<code>str</code> ,构造出新的字符串  </p><pre class=" language-python"><code class="language-python">mystr<span class="token punctuation">.</span>join<span class="token punctuation">(</span>str<span class="token punctuation">)</span></code></pre><h3 id="4-2、列表"><a href="#4-2、列表" class="headerlink" title="4.2、列表"></a>4.2、列表</h3><p><a href="http://naotu.baidu.com/file/7e960d60c2522b27c2407a6146e4fb69?token=772f8faafb9242d3" target="_blank" rel="noopener">列表的思维导图</a></p><h4 id="4-2-1、列表简介"><a href="#4-2-1、列表简介" class="headerlink" title="4.2.1、列表简介"></a>4.2.1、列表简介</h4><p><strong>列表</strong>：<code>Python</code>内置的一种数据类型。<strong>list 是一种有序的集合</strong>，可以随时添加和删除其中的元素，是写在方括号之间、使用逗号分隔开的数值列表。列表内的项目<strong>不必全是相同的类型</strong>。  </p><pre class=" language-python"><code class="language-python">my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">3.214</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h4 id="4-2-2、列表的常见操作"><a href="#4-2-2、列表的常见操作" class="headerlink" title="4.2.2、列表的常见操作"></a>4.2.2、列表的常见操作</h4><h5 id="len"><a href="#len" class="headerlink" title="len"></a>len</h5><p><code>len()</code>函数用于计算列表的长度，它不仅可以用于列表，还可以用于字符串、元组、字典等等。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#len()函数可以获得list元素的个数：</span>namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span>len<span class="token punctuation">(</span>namesList<span class="token punctuation">)</span></code></pre><h5 id="列表的访问"><a href="#列表的访问" class="headerlink" title="列表的访问"></a>列表的访问</h5><p>用<strong>索引</strong>来访问 list 中每个位置的元素，再次强调<strong>索引是从0开始的</strong>：  </p><pre class=" language-python"><code class="language-python">namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果：    xiaoWang    xiaoZhang    xiaoHua    Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>    File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    IndexError<span class="token punctuation">:</span> list index out of range</code></pre><p><strong>注意</strong>： 当索引超出了范围时，<code>Python</code>会报 <code>IndexError</code> 错误，所以要确保索引不要越界，记得最后一个元素的索引是 <code>len(classmates) - 1</code>  。如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：  </p><pre class=" language-python"><code class="language-python">namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果：xiaoHua</code></pre><p>以此类推，可以获取倒数第2个、倒数第3个：  </p><pre class=" language-python"><code class="language-python">namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果：xiaoHuaxiaoZhangxiaoWang</code></pre><h5 id="列表的切片"><a href="#列表的切片" class="headerlink" title="列表的切片"></a>列表的切片</h5><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用切片的方式获取一部分数据</span>result <span class="token operator">=</span> my_str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#前三个</span>result <span class="token operator">=</span> my_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>result <span class="token operator">=</span> my_str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h5 id="添加元素-append-extend-insert"><a href="#添加元素-append-extend-insert" class="headerlink" title="添加元素 (append , extend , insert )"></a>添加元素 (append , extend , insert )</h5><p>通过<code>append()</code>可以向列表添加元素  </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义列表stu_list，默认有3个元素</span>stu_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----添加之前，列表stu_list的数据-----"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu_list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#提示、并添加元素</span>temp <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入要添加的学生姓名:'</span><span class="token punctuation">)</span>stu_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----添加之后，列表stu_list的数据-----"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu_list<span class="token punctuation">)</span></code></pre><p>通过<code>extend()</code>可以将另一个集合中的元素逐一添加到列表中</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></code></pre><p><code>insert(index, object)</code>在指定位置<code>index</code>前插入元素<code>object</code></p><pre class=" language-python"><code class="language-python">insert<span class="token punctuation">(</span>index<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span></code></pre><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><p>修改元素的时候，要通过<strong>下标</strong>来确定要修改的是哪个元素，然后才能进行修改  </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义变量A，默认有3个元素</span>stu_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----修改之前，列表stu_list的数据-----"</span><span class="token punctuation">)</span><span class="token keyword">for</span> tempName <span class="token keyword">in</span> stu_list<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>tempName<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#修改元素</span>stu_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'xiaoLu'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----修改之后，列表stu_list的数据-----"</span><span class="token punctuation">)</span><span class="token keyword">for</span> tempName <span class="token keyword">in</span> stu_list<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>tempName<span class="token punctuation">)</span>结果<span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>修改之前，列表stu_list的数据<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>xiaoWangxiaoZhangxiaoHua<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>修改之后，列表stu_list的数据<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>xiaoWangxiaoLuxiaoHua</code></pre><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><p>列表中所谓的<strong>查找</strong>，就是看看指定的元素<strong>是否存在</strong>。<br><code>Python</code>中<strong>常用的查找方法</strong>为：</p><ul><li><code>in</code>（存在） ,如果存在那么结果为 true ，否则为 false</li><li><code>not in</code> （不存在），如果不存在那么结果为 true ，否则 false  </li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#待查找的列表</span>name_List <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#获取⽤户要查找的名字</span>findName <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入要查找的姓名:'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#查找是否存在</span><span class="token keyword">if</span> findName <span class="token keyword">in</span> name_List<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'在字典中找到了相同的名字'</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'没有找到'</span><span class="token punctuation">)</span></code></pre><p><code>index</code> 和 <code>count</code> 与字符串中的用法相同  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 注意是左闭右开区间</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>ValueError<span class="token punctuation">:</span> <span class="token string">'a'</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token keyword">in</span> list<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token number">3</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token number">0</span></code></pre><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>列表元素的<strong>常用删除方法</strong>有：</p><ul><li><code>del</code>：根据下标进行删除</li><li><code>pop</code>：删除最后一个元素</li><li><code>remove</code>：根据元素的值进行删除  </li></ul><p><strong>(1) del</strong></p><pre class=" language-python"><code class="language-python">list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之前------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token keyword">del</span> list1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之后------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span>结果<span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之前<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之后<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span></code></pre><p><strong>(2) pop</strong></p><pre class=" language-python"><code class="language-python">list2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之前------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span>list2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之后------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span>结果<span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之前<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之后<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span></code></pre><p><strong>(3) remove</strong></p><pre class=" language-python"><code class="language-python">list3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之前------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list3<span class="token punctuation">)</span>list3<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'------删除之后------'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list3<span class="token punctuation">)</span>结果<span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之前<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>删除之后<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span></code></pre><h5 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h5><p><code>sort()</code>方法是将 <code>list</code> 按特定顺序重新排列，默认为由小到达，参数 <code>reverse=True</code> 可改为倒序，由大到小。<br><code>reverse()</code>方法是将 <code>list</code> 逆置。  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>如何使用<strong>索引</strong>的方式将列表进行逆置？</p><h4 id="4-2-3、列表的遍历"><a href="#4-2-3、列表的遍历" class="headerlink" title="4.2.3、列表的遍历"></a>4.2.3、列表的遍历</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>为了更有效率的输出列表的每个数据，可以使<code>for</code>循环来完成  </p><pre class=" language-python"><code class="language-python">namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> namesList<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>结果<span class="token punctuation">:</span>xiaoWangxiaoZhangxiaoHua</code></pre><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre class=" language-python"><code class="language-python">namesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoWang'</span><span class="token punctuation">,</span><span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span><span class="token string">'xiaoHua'</span><span class="token punctuation">]</span>length <span class="token operator">=</span> len<span class="token punctuation">(</span>namesList<span class="token punctuation">)</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i<span class="token operator">&lt;</span>length<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>namesList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    i<span class="token operator">+=</span><span class="token number">1</span>结果<span class="token punctuation">:</span>xiaoWangxiaoZhangxiaoHua</code></pre><h3 id="4-3、元组"><a href="#4-3、元组" class="headerlink" title="4.3、元组"></a>4.3、元组</h3><p><a href="http://naotu.baidu.com/file/c2136fdce7ab944e9263588ee92a25d2?token=d9ef1180fd5ee82f" target="_blank" rel="noopener">元组的思维导图</a></p><p>另一种<strong>有序列表</strong>叫元组： <code>tuple</code> 。 <code>tuple</code> 和 <code>list</code>非常类似，但是 <strong>tuple一旦初始化就不能修改</strong>，如同样是列出同学的名字：  </p><pre class=" language-python"><code class="language-python">classmates <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">)</span></code></pre><p>  现在， <code>classmates</code> 这个 <code>tuple</code> 不能变了，它也没有 <code>append()</code> ， <code>insert( )</code>这样的方法。其他获取元素的方法和<code>list</code>是一样的，你可以正常地使用 classmates[0] ，classmates[-1] ，但不能赋值成另外的元素。</p><p>不可变的tuple有什么意义？</p><p>因为tuple不可变，所以代码更安全。</p><p>如果要定义一个空的 <code>tuple</code> ，可以写成 <code>()</code> ：  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>但是，要定义一个<code>只有1个元素的 tuple</code> ，如果你这么定义：  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token number">1</span></code></pre><p>定义的<code>不是``tuple</code>，是1这个数！这是因为括号<code>()</code>既可以表示<code>tuple</code>，也可以表示<strong>数学公式中的<code>()</code>括号</strong>，这就产生了歧义。因此<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>所以，只有1个元素的<code>tuple</code>定义时<strong>必须加一个逗号</strong>，来消除歧义：  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre><p><code>Python</code>在显示只有1个元素的 <code>tuple</code> 时，也会加一个逗号，以免你误解成数学计算意义上的括号。<br>最后来看一个“<strong>可变的</strong>”<code>tuple</code>：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Y'</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'Y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="4-4、字典"><a href="#4-4、字典" class="headerlink" title="4.4、字典"></a>4.4、字典</h3><p><a href="http://naotu.baidu.com/file/29d9993ee133ac726fa3e2bdd536fed7?token=d1efff2551754dec" target="_blank" rel="noopener">字典的思维导图</a></p><h4 id="4-4-1、字典简介"><a href="#4-4-1、字典简介" class="headerlink" title="4.4.1、字典简介"></a>4.4.1、字典简介</h4><p><strong>字典</strong>是另一种可变容器模型，且可存储任意类型对象。  </p><p><strong>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号{}中</strong><br>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>list</code>实现，需要两个<code>list</code> ：  </p><pre class=" language-python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">]</span>scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">]</span></code></pre><p>给定一个名字，要查找对应的成绩，就先要在 <code>names</code> 中找到对应的位置，再从 <code>scores</code> 取出对应的成绩， <code>list</code> 越长， 耗时越大。<br>如果⽤用<code>dict</code> 实现，只需要<strong>“名字”-“成绩”</strong>的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。</p><pre class=" language-python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Michael'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">:</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">:</span> <span class="token number">85</span><span class="token punctuation">}</span>d<span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">]</span><span class="token number">95</span></code></pre><p>由于一个 <code>key</code> 只能对应一个 <code>value</code> ，所以多次对一个 <code>key</code> 放入<code>value</code> ， <strong>后面的值会把前面的值冲掉</strong>：  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Jack'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token number">90</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Jack'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">88</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token number">88</span></code></pre><p>如果<code>key</code>不存在， <code>dict</code>就会报错：  </p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Thomas'</span><span class="token punctuation">]</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>KeyError<span class="token punctuation">:</span> <span class="token string">'Thomas'</span></code></pre><h4 id="4-4-2-字典的常用操作"><a href="#4-4-2-字典的常用操作" class="headerlink" title="4.4.2 字典的常用操作"></a>4.4.2 字典的常用操作</h4><h5 id="修改元素-1"><a href="#修改元素-1" class="headerlink" title="修改元素"></a>修改元素</h5><p>字典的每个元素中的数据是可以修改的，只要通过 <code>key</code> 找到，即可修改</p><pre class=" language-python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'kkb'</span><span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'中国北京'</span><span class="token punctuation">}</span>new_id <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入新的学号:'</span><span class="token punctuation">)</span>info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> int<span class="token punctuation">(</span>new_id<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'修改之后的id为: %d'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h5 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h5><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#访问不存在的元素</span>info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'kkb'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'中国北京'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'id为:%d'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果<span class="token punctuation">:</span>KeyError              Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython<span class="token operator">-</span>input<span class="token number">-18</span><span class="token operator">-</span><span class="token number">7c5504a15199</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token number">1</span> info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'kkb'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'中国北京'</span><span class="token punctuation">}</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">2</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'id为:%d'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>KeyError<span class="token punctuation">:</span> <span class="token string">'id'</span></code></pre><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>如果在使用<strong>变量名[‘键’] = 数据</strong>时，这个“键”不在字典中就会新增这个元素。</p><pre class=" language-python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'kkb'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'中国北京'</span><span class="token punctuation">}</span>newId <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入新的学号： '</span><span class="token punctuation">)</span>info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> int<span class="token punctuation">(</span>newId<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'添加之后的id为:%d'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果<span class="token punctuation">:</span>请输入新的学号： <span class="token number">188</span>添加之后的id为<span class="token punctuation">:</span> <span class="token number">188</span></code></pre><p>如果”键“已经存在，就会更新键对应的值。</p><pre class=" language-python"><code class="language-python">newId <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入新的学号： '</span><span class="token punctuation">)</span>info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span> <span class="token operator">=</span> int<span class="token punctuation">(</span>newId<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'添加之后的id为:%d'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h5 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h5><p>对字典进行删除操作，有以下几种：</p><ul><li><code>del</code></li><li><code>clear()</code></li><li><code>pop()</code></li></ul><p><code>del</code> 删除指定的元素  </p><pre class=" language-python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'kkb'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'中国北京'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除前,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">del</span> info<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除后,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>结果Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>KeyError<span class="token punctuation">:</span> <span class="token string">'name'</span></code></pre><p><code>del</code> 删除整个字典  </p><pre class=" language-python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'monitor'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'China'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除前,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">)</span><span class="token keyword">del</span> info<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除后,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">)</span></code></pre><p><code>clear</code>清空整个字典  </p><pre class=" language-python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'monitor'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'address'</span><span class="token punctuation">:</span><span class="token string">'China'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'清空前,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">)</span>info<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'清空后,%s'</span> <span class="token operator">%</span> info<span class="token punctuation">)</span></code></pre><h5 id="len-1"><a href="#len-1" class="headerlink" title="len()"></a>len()</h5><p>测量字典中键值对的个数  </p><pre class=" language-python"><code class="language-python">d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">:</span><span class="token string">'18'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">:</span><span class="token string">'cnh'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">)</span>结果：<span class="token number">3</span></code></pre><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><p>返回包含字典所有<code>key</code>的列表  </p><pre class=" language-python"><code class="language-python">d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">:</span><span class="token string">'18'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">:</span><span class="token string">'cnh'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>d1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>结果：<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">]</span></code></pre><h5 id="values"><a href="#values" class="headerlink" title="values"></a>values</h5><p>返回⼀个包含字典所有value的列表  </p><pre class=" language-python"><code class="language-python">d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">:</span><span class="token string">'18'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">:</span><span class="token string">'cnh'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>d1<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>结果：<span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">,</span> <span class="token string">'cnh'</span><span class="token punctuation">]</span></code></pre><h5 id="items"><a href="#items" class="headerlink" title="items"></a>items</h5><p>返回包含所有（键，值） 元组的列表  </p><pre class=" language-python"><code class="language-python">d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">:</span><span class="token string">'18'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">:</span><span class="token string">'cnh'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>d1<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>结果：<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'cnh'</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h3 id="4-5、集合"><a href="#4-5、集合" class="headerlink" title="4.5、集合"></a>4.5、集合</h3><p><a href="http://naotu.baidu.com/file/a722117e543aaf9f587bdc5b7ebe10df?token=af4d8b1ed3b0eb49" target="_blank" rel="noopener">集合的思维导图</a></p><h4 id="4-5-1、集合简介"><a href="#4-5-1、集合简介" class="headerlink" title="4.5.1、集合简介"></a>4.5.1、集合简介</h4><p>集合（set）是<strong>一个无序的不重复元素序列</strong>。<br>可以使<strong>大括号 { }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合<strong>必须用set() 而不是 { }</strong>，因为 { }用来创建空字典</p><pre class=" language-python"><code class="language-python">my_set <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 不支持下标赋值和取值</span><span class="token comment" spellcheck="true"># my_set[0] = 3</span><span class="token comment" spellcheck="true"># value = my_set[0]</span><span class="token comment" spellcheck="true"># print(value)</span><span class="token comment" spellcheck="true"># 集合可以对容器类型数据去重</span>my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 把列表转成集合，会把数据去重</span>my_set <span class="token operator">=</span> set<span class="token punctuation">(</span>my_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_set<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 列表，元组， 集合 三者之间可以相互转换</span>my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_tuple<span class="token punctuation">,</span> type<span class="token punctuation">(</span>my_tuple<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="4-5-2、集合的常见操作"><a href="#4-5-2、集合的常见操作" class="headerlink" title="4.5.2、集合的常见操作"></a>4.5.2、集合的常见操作</h4><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p> <code>add</code> ：跟列表的 <code>append</code> 方法类似，集合用<code>add</code>添加单个元素。如果添加的是已有元素，集合不改变： </p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义空的集合的时候不能直接使用{}</span>my_set <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>my_set<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>my_set<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_set<span class="token punctuation">,</span> type<span class="token punctuation">(</span>my_set<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><code>update</code>：跟列表的<code>extend</code>方法类似，用来向集合添加多个元素。</p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><p>因为没有索引所以无法定位，只能用先删除后增加的方法进行修改</p><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><p><code>remove</code>：从集合中移除元素，如果不存在会报错。</p><p><code>pop</code>：由于集合没有顺序，不能像列表一样按照位置弹出元素，所以<code>pop</code> 方法删除并返回集合中任意一个元素，如果集合中没有元素会报错。</p><p><code>discard</code>：作用与 <code>remove</code> 一样，但是当元素在集合中不存在的时候不会报错。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>a<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>discard<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p> 假设有这样两个集合： </p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span>b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span></code></pre><h5 id="并"><a href="#并" class="headerlink" title="并"></a>并</h5><p>两个集合的并，返回包含两个集合所有元素的集合（去除重复）。</p><p>可以用方法 <code>a.union(b)</code> 或者操作 <code>a | b</code> 实现。</p><pre class=" language-python"><code class="language-python">a<span class="token punctuation">.</span>union<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span></code></pre><h5 id="交"><a href="#交" class="headerlink" title="交"></a>交</h5><p>两个集合的交，返回包含两个集合共有元素的集合。</p><p>可以用方法 <code>a.intersection(b)</code> 或者操作 <code>a &amp; b</code> 实现。</p><pre class=" language-python"><code class="language-python">a<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span></code></pre><h5 id="差"><a href="#差" class="headerlink" title="差"></a>差</h5><p><code>a</code> 和 <code>b</code> 的差集，返回只在 <code>a</code> 不在 <code>b</code> 的元素组成的集合。</p><p>可以用方法 <code>a.difference(b)</code> 或者操作 <code>a - b</code> 实现。</p><pre class=" language-python"><code class="language-python">a<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span></code></pre><p>注意，<code>a - b</code> 与 <code>b - a</code>并不一样，<code>b - a</code> 返回的是返回 b 不在 a 的元素组成的集合：</p><pre class=" language-python"><code class="language-python">b<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span></code></pre><h5 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h5><p>假设现在有这样两个集合： </p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span></code></pre><p>要判断 <code>b</code> 是不是 <code>a</code> 的子集，可以用 <code>b.issubset(a)</code> 方法，或者更简单的用操作 <code>b &lt;= a</code> ： </p><pre class=" language-python"><code class="language-python">b<span class="token punctuation">.</span>issubset<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token boolean">True</span>b <span class="token operator">&lt;=</span> a<span class="token boolean">True</span></code></pre><p>与之对应，也可以用 <code>a.issuperset(b)</code> 或者 <code>a &gt;= b</code> 来判断：</p><pre class=" language-python"><code class="language-python">a<span class="token punctuation">.</span>issuperset<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token boolean">True</span>a <span class="token operator">>=</span> b<span class="token boolean">True</span></code></pre><p>方法只能用来测试子集，但是操作符可以用来判断真子集：</p><pre class=" language-python"><code class="language-python">a <span class="token operator">&lt;=</span> a<span class="token boolean">True</span></code></pre><p>自己不是自己的真子集：</p><pre class=" language-python"><code class="language-python">a <span class="token operator">&lt;</span> a<span class="token boolean">False</span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1、本次分享的大部分知识点都是重点，都是后面学习离不开的基础语法。</p><p>2、需要着重掌握的是各个数据容器的创建方法以及对数据的操作</p><p>2、尽量自己动手实践一遍，练习是学习编程最简单的途径</p><h2 id="六、作业"><a href="#六、作业" class="headerlink" title="六、作业"></a>六、作业</h2><p>1、利用下划线将列表中的每一个元素拼接成字符串，list = [‘alex’, ‘eric’, ‘rain’] </p><p>2、有一个列表： li = [‘hello’, ‘seven’, [‘mom’, [‘h’,’kelly’], ‘all’], 123, 446] ，请根据索引输出’kelly’ ；再找到’all’元素并将其修改为’ALL’ </p><p>3、有如下值列表[11, 22, 33, 44, 55, 66, 77, 88, 99, 90]，将所有大于66的只保存在字典k1中，将小于66的值保存至字典k2中 </p><h2 id="七、分享"><a href="#七、分享" class="headerlink" title="七、分享"></a>七、分享</h2><p><a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener">everything</a>：Everthing/搜索工具： 它体积小巧，界面简洁易用，快速建立索引，快速搜索，同时占用极低的系统资源，实时跟踪文件变化，并且还可以通过http或ftp形式分享搜索。在搜索框输入文字，它就会只显示过滤后的文件和目录。Everything搜索只基于文件和文件夹的名称，所以它创建数据库很快。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分享-2-基础知识</title>
      <link href="/2020/01/06/Python%E5%88%86%E4%BA%AB-2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/06/Python%E5%88%86%E4%BA%AB-2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Python分享第二节"><a href="#Python分享第二节" class="headerlink" title="Python分享第二节"></a><code>Python</code>分享第二节</h1><p>最近受邀给团队中的小伙伴们分享<code>Python</code>知识，本篇文章是第二节课的基本内容。</p><h2 id="一、课前准备-amp-回顾"><a href="#一、课前准备-amp-回顾" class="headerlink" title="一、课前准备&amp;回顾"></a>一、课前准备&amp;回顾</h2><p>1、根据上次课的安装教程安装好<code>Python</code>环境</p><h2 id="二、课堂主题"><a href="#二、课堂主题" class="headerlink" title="二、课堂主题"></a>二、课堂主题</h2><p>第二课主要学习<code>Python</code>的基础，大体包含：输入与输出、变量、数据类型、运算符、关键字、判断语句、循环语句等<code>Python</code>基础知识点</p><h2 id="三、本节目标"><a href="#三、本节目标" class="headerlink" title="三、本节目标"></a>三、本节目标</h2><p>1、掌握<code>Python</code>书写语法结构以及书写特点</p><p>2、掌握<code>Python</code>基础知识点</p><p>3、根据判断语句和循环语句了解程序的执行顺序</p><h2 id="四、知识要点"><a href="#四、知识要点" class="headerlink" title="四、知识要点"></a>四、知识要点</h2><h3 id="4-1、注释"><a href="#4-1、注释" class="headerlink" title="4.1、注释"></a>4.1、注释</h3><h4 id="4-1-1、注释的作用"><a href="#4-1-1、注释的作用" class="headerlink" title="4.1.1、注释的作用"></a>4.1.1、注释的作用</h4><p><strong>注释</strong>：注释的作用是对代码进行解释和说明，不仅可以提高代码的可读性，也可以方便他人阅读。</p><p>对于初学者在开始编程的时候一定要重视注释的书写，尽量把自己的思路通过文字或注释的方式记录下来，方便归纳总结。</p><h4 id="4-1-2、Python中注释的写法"><a href="#4-1-2、Python中注释的写法" class="headerlink" title="4.1.2、Python中注释的写法"></a>4.1.2、<code>Python</code>中注释的写法</h4><p>在<code>Python</code>中，注释分为两种：</p><ul><li>单行注释符号(#) </li><li>批量、多行注释符号(通常使用三个双引号或者三个单引号将注释信息包裹)</li></ul><p>代码示例：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 这是一个注释</span><span class="token triple-quoted-string string">'''这是多行注释，用三个单引号这是多行注释，用三个单引号 这是多行注释，用三个单引号'''</span><span class="token triple-quoted-string string">"""这是多行注释，用三个双引号这是多行注释，用三个双引号 这是多行注释，用三个双引号"""</span></code></pre><h4 id="4-1-3、注释的快捷键"><a href="#4-1-3、注释的快捷键" class="headerlink" title="4.1.3、注释的快捷键"></a>4.1.3、注释的快捷键</h4><p><code>Python</code>中注释的快捷键是<code>control</code>+<code>/</code></p><h3 id="4-2、变量"><a href="#4-2、变量" class="headerlink" title="4.2、变量"></a>4.2、变量</h3><p><strong>变量</strong>：通俗的理解 就是存储程序数据的容器</p><p><strong>变量定义的格式</strong>：<strong>变量名 = 数据</strong>（变量名应该简洁且有含义，方便理解）</p><p> <strong>每个变量在使用前都必须赋值</strong>，变量赋值以后该变量才会被创建。 </p><p><code>Python</code>是<strong>弱类型</strong>的语言，因此在声明变量是<strong>不需要</strong>指定变量的数据类型，<code>Python</code>会根据数据<strong>自动推导</strong>出数据类型</p><p><strong>C</strong>中声明变量的写法：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">100</span></code></pre><p><strong><code>Python</code></strong>中声明变量的写法：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分别定义了四个变量，第一个变量名叫做score，存储的数据是100</span>score <span class="token operator">=</span> <span class="token number">100</span>name <span class="token operator">=</span> <span class="token string">"Timmy"</span>pi <span class="token operator">=</span> <span class="token number">3.14</span>is_show <span class="token operator">=</span> <span class="token boolean">True</span></code></pre><p>使用<code>type()</code>方法可以查看变量的数据类型</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"score的数据类型是："</span> <span class="token punctuation">,</span> type<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"name的数据类型是："</span> <span class="token punctuation">,</span> type<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pi的数据类型是："</span> <span class="token punctuation">,</span> type<span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"is_show的数据类型是："</span> <span class="token punctuation">,</span> type<span class="token punctuation">(</span>is_show<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>数据类型</strong></p><p><code>Python</code>中<strong>常用</strong>的数据类型有一下几个：</p><table><thead><tr><th>类型</th><th>例子</th></tr></thead><tbody><tr><td>整数<code>int</code></td><td><code>-100</code></td></tr><tr><td>浮点数<code>float</code></td><td><code>3.1416</code></td></tr><tr><td>字符串<code>str</code></td><td><code>&#39;hello&#39;</code></td></tr><tr><td>列表<code>list</code></td><td><code>[1, 1.2, &#39;hello&#39;]</code></td></tr><tr><td>字典<code>dict</code></td><td><code>{&#39;dogs&#39;: 5, &#39;pigs&#39;: 3}</code></td></tr><tr><td>Numpy数组</td><td><code>array([1, 2, 3])</code></td></tr></tbody></table><p>还有一些其他类型：</p><table><thead><tr><th>类型</th><th>例子</th></tr></thead><tbody><tr><td>布尔型<code>bool</code></td><td><code>True, False</code></td></tr><tr><td>元组<code>tuple</code></td><td><code>(&#39;ring&#39;, 1000)</code></td></tr><tr><td>集合<code>set</code></td><td><code>{1, 2, 3}</code></td></tr><tr><td>Pandas类型</td><td><code>DataFrame, Series</code></td></tr><tr><td>自定义</td><td><code>Object Oriented Classes</code></td></tr></tbody></table><h3 id="4-3、变量的命名规则"><a href="#4-3、变量的命名规则" class="headerlink" title="4.3、变量的命名规则"></a>4.3、变量的命名规则</h3><p><strong>变量名</strong>：<strong>只能</strong>由字母、数字、下划线组成，但是数字<strong>不能</strong>作为开头</p><p>变量名的命名方式有两种：<strong>驼峰命名法</strong>和<strong>下划线命名法</strong></p><ul><li>驼峰命名法<ul><li>小驼峰：第一个单词首字母小写，其他单词首字母大写</li><li>大驼峰：多有单词首字母都大写</li></ul></li><li>下划线命名：单词全部使用小写，以下滑线分割</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 小驼峰</span>myName <span class="token operator">=</span> <span class="token string">"Timmy"</span><span class="token comment" spellcheck="true"># 大驼峰</span>MyName <span class="token operator">=</span> <span class="token string">"Timmy"</span><span class="token comment" spellcheck="true"># 下划线命名--推荐使用</span>my_name <span class="token operator">=</span> <span class="token string">"Timmy"</span><span class="token comment" spellcheck="true"># 以下是错误的命名示例</span>3name <span class="token operator">=</span> <span class="token string">"Timmy"</span> <span class="token comment" spellcheck="true"># 以数字开头</span>na!me <span class="token operator">=</span> <span class="token string">"Timmy"</span> <span class="token comment" spellcheck="true"># 名称中间有非法字符</span></code></pre><p>在<code>Python</code>中，<strong>推荐大家使用下划线命名法</strong>，在初学编程中，培养良好的编码习惯也是非常重要的一环，对变量的命名也要尤为重视，命名在尽量简洁的。</p><p><a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">CODELF</a>：一个自动生成变量名的网站。</p><h3 id="4-4、关键字"><a href="#4-4、关键字" class="headerlink" title="4.4、关键字"></a>4.4、关键字</h3><p><strong>关键字</strong>又叫保留字，在<code>Python</code>中，具有特殊功能的标识符称为关键字。</p><p>关键字是<code>Python</code>语言自己已经使用的了，不允许开发者自己定义和关键字相同名字的标识符。常见的有<code>def</code>,<code>if</code>,<code>try</code>,<code>class</code>等。</p><p>可以通过代码查询<code>Python</code>中的关键字</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> keyword<span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 以下是输出结果：</span><span class="token punctuation">[</span><span class="token string">'False'</span><span class="token punctuation">,</span> <span class="token string">'None'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'as'</span><span class="token punctuation">,</span> <span class="token string">'assert'</span><span class="token punctuation">,</span> <span class="token string">'async'</span><span class="token punctuation">,</span> <span class="token string">'await'</span><span class="token punctuation">,</span> <span class="token string">'break'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'continue'</span><span class="token punctuation">,</span> <span class="token string">'def'</span><span class="token punctuation">,</span> <span class="token string">'del'</span><span class="token punctuation">,</span> <span class="token string">'elif'</span><span class="token punctuation">,</span> <span class="token string">'else'</span><span class="token punctuation">,</span> <span class="token string">'except'</span><span class="token punctuation">,</span> <span class="token string">'finally'</span><span class="token punctuation">,</span> <span class="token string">'for'</span><span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> <span class="token string">'global'</span><span class="token punctuation">,</span> <span class="token string">'if'</span><span class="token punctuation">,</span> <span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token string">'in'</span><span class="token punctuation">,</span> <span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token string">'lambda'</span><span class="token punctuation">,</span> <span class="token string">'nonlocal'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'pass'</span><span class="token punctuation">,</span> <span class="token string">'raise'</span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">,</span> <span class="token string">'try'</span><span class="token punctuation">,</span> <span class="token string">'while'</span><span class="token punctuation">,</span> <span class="token string">'with'</span><span class="token punctuation">,</span> <span class="token string">'yield'</span><span class="token punctuation">]</span></code></pre><h3 id="4-5、常用的数据类型转换"><a href="#4-5、常用的数据类型转换" class="headerlink" title="4.5、常用的数据类型转换"></a>4.5、常用的数据类型转换</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>int(x [,base ])</td><td>将x转换为一个整数</td></tr><tr><td>float(x )</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag ])</td><td>创建一个复数</td></tr><tr><td>str(x )</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x )</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str )</td><td>用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</td></tr><tr><td>tuple(s )</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s )</td><td>将序列 s 转换为一个列表</td></tr><tr><td>chr(x )</td><td>将一个整数转换为一个字符</td></tr><tr><td>unichr(x )</td><td>将一个整数转换为Unicode字符</td></tr><tr><td>ord(x )</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x )</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x )</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><pre class=" language-python"><code class="language-python">my_str <span class="token operator">=</span> <span class="token string">"1010"</span><span class="token comment" spellcheck="true"># 把字符串转成 int 类型</span>num2 <span class="token operator">=</span> int<span class="token punctuation">(</span>my_str<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#判断数据是不是指定类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>num2<span class="token punctuation">,</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="4-6、输入和输出"><a href="#4-6、输入和输出" class="headerlink" title="4.6、输入和输出"></a>4.6、输入和输出</h3><h4 id="4-6-1、Python中的输入"><a href="#4-6-1、Python中的输入" class="headerlink" title="4.6.1、Python中的输入"></a>4.6.1、<code>Python</code>中的输入</h4><p><code>Python</code>中的输入是使用<code>input()</code>函数</p><pre class=" language-python"><code class="language-python">name <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入一个数："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></code></pre><h4 id="4-6-2、Python中的输出"><a href="#4-6-2、Python中的输出" class="headerlink" title="4.6.2、Python中的输出"></a>4.6.2、<code>Python</code>中的输出</h4><p><code>Python</code>中的输入是使用<code>print()</code>函数，使用方法也很简单，在这里普及一个jupyter的小技巧，如果忘记函数有哪些参数或不知道函数如何使用时，可以在函数前加上一个<code>?</code>，或者,这样jupyter就会弹出相应的文档，下面是示例。</p><pre class=" language-python"><code class="language-python">?<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#或者</span><span class="token keyword">print</span>?? </code></pre><p><img src="/.top//E:%5C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%60Python%60%E5%9F%B9%E8%AE%AD%5Cfile%5CQQ%E5%BD%B1%E9%9F%B3.lnk" alt="1577604390445"></p><h3 id="4-7、格式化输出"><a href="#4-7、格式化输出" class="headerlink" title="4.7、格式化输出"></a>4.7、格式化输出</h3><p>常用的格式化符号有<code>%s</code>、<code>%d</code>、<code>%f</code></p><ul><li><code>%s</code>：输出字符串</li><li><code>%d</code>：输出int类型的数字</li><li><code>%f</code>：输出浮点数</li></ul><pre class=" language-python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'Timmy'</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我叫%s ,年龄%d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># format 格式化函数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我叫{} ,年龄{}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我叫{na} ,年龄{ag}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>na<span class="token operator">=</span>age<span class="token punctuation">,</span>ag<span class="token operator">=</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我叫{0} ,年龄{1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我叫{1} ,年龄{1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="4-8、运算符"><a href="#4-8、运算符" class="headerlink" title="4.8、运算符"></a>4.8、运算符</h3><h4 id="4-8-1、数学运算符"><a href="#4-8-1、数学运算符" class="headerlink" title="4.8.1、数学运算符"></a>4.8.1、数学运算符</h4><p>以下假设变量： a =10, b=20:</p><table><thead><tr><th>运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td>+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td>-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td>*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td>/</td><td align="left">除 - x除以y</td><td align="left">b / a 输出结果 2</td></tr><tr><td>%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td>**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td>//</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left"><code>9//2 4</code></td></tr></tbody></table><h4 id="4-8-2、比较运算符"><a href="#4-8-2、比较运算符" class="headerlink" title="4.8.2、比较运算符"></a>4.8.2、比较运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 true.</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。</td><td align="left">(a &lt; b) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 true。</td></tr></tbody></table><h4 id="4-8-3、赋值运算符"><a href="#4-8-3、赋值运算符" class="headerlink" title="4.8.3、赋值运算符"></a>4.8.3、赋值运算符</h4><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr></tbody></table><p>以下实例演示了<code>Python</code>所有赋值运算符的操作：</p><h4 id="4-8-4、Python逻辑运算符"><a href="#4-8-4、Python逻辑运算符" class="headerlink" title="4.8.4、Python逻辑运算符"></a>4.8.4、<code>Python</code>逻辑运算符</h4><p><code>Python</code>语言支持逻辑运算符，以下假设变量 a 为布尔类型的 True, b为 False:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td align="left">(a and b) 返回 False。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 True。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 True</td></tr></tbody></table><h3 id="4-9、Python中的缩进规则"><a href="#4-9、Python中的缩进规则" class="headerlink" title="4.9、Python中的缩进规则"></a>4.9、<code>Python</code>中的缩进规则</h3><p>在讲解if语句与循环语句之前，我们先来了解一下<code>Python</code>与众不同的缩进规则。</p><p><code>Python</code>中的缩进决定了<strong>代码的作用域范围</strong>。这一点和传统的c/Java有很大的不同（传统的c/Java使用花括号花括号{}符决定作用域的范围；python使用缩进空格来表示作用域的范围，相同缩进行的代码是处于同一范围）。</p><p>Java条件判断示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> score <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>score<span class="token operator">></span><span class="token number">60</span> <span class="token operator">&amp;&amp;</span> score<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成绩合格"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score<span class="token operator">></span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成绩异常"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成绩不及格"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个<strong>必须严格执行</strong>。</p><p>通常我们使用<strong>四个空格</strong>区分每个缩进层次，具体示例如下：</p><pre class=" language-python"><code class="language-python">age <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">6</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"teenager"</span><span class="token punctuation">)</span></code></pre><h3 id="4-10、if语句"><a href="#4-10、if语句" class="headerlink" title="4.10、if语句"></a>4.10、if语句</h3><p>计算机之所以能做过很多自动化任务，因为它可以自己做条件判断</p><p>比如，输入用户年龄，根据年龄打印不同的内容，在<code>Python</code>程序中，用<code>if</code>实现，<code>if</code>语句在<code>SQL</code>中也有使用，即使从来没有接触过编程的小伙伴应该也不会陌生</p><p>首先看下<code>SQL</code>中的<code>if</code>条件语句：</p><pre class=" language-mysql"><code class="language-mysql">if(logical_test,[value_if_true],[value_if_false])</code></pre><p><code>SQL</code>中的<code>if</code>判断语句与<code>Excel</code>中基本一致，下面看一下<code>Python</code>中的if判断</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> <span class="token operator">&lt;</span>条件<span class="token number">1</span>为<span class="token boolean">True</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>条件成立要执行的语句<span class="token punctuation">]</span><span class="token keyword">elif</span> <span class="token operator">&lt;</span>条件<span class="token number">2</span>为<span class="token boolean">True</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>条件成立要执行的语句<span class="token punctuation">]</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>上述条件均不满足要执行的语句<span class="token punctuation">]</span></code></pre><p>看下下面的小例子：</p><pre class=" language-python"><code class="language-python">age <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">6</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"teenager"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"adult"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"kid"</span><span class="token punctuation">)</span></code></pre><p><code>if</code>语句执行的特点：<code>if</code>语句是从上往下判断，如果在某个判断上是True，那么把该判断对应的语句执行完成后，就忽略掉剩下的<code>elif</code>和<code>else</code></p><h3 id="4-11、循环"><a href="#4-11、循环" class="headerlink" title="4.11、循环"></a>4.11、循环</h3><p>和<code>if</code>判断语句一样，循环语句也是所有编程语言的核心。</p><p>在不少实际问题中有许多具有规律性的重复操作,因此在程序中就需要重复执行某些语句。</p><p>一组被重复执行的语句称之为循环体,能否继续重复,决定循环的终止条件。</p><p>循环语句是由<strong>循环体</strong>及<strong>循环的终止条件</strong>两部分组成的。</p><p>要使用循环语句时，必须要确定循环体及条件（布尔表达式）两个重要因素，亦即首要考虑的是：要重复执行哪些语句，要重复到什么时候为止。</p><p>在python中，循环分为两种，一种是<code>for</code>循环，一种是<code>while</code>循环，下面我们分别进行介绍</p><h4 id="4-11-1、while循环"><a href="#4-11-1、while循环" class="headerlink" title="4.11.1、while循环"></a>4.11.1、while循环</h4><p><code>while</code>循环的语法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">while</span> 条件<span class="token punctuation">:</span>    <span class="token punctuation">[</span>条件满足执行的代码<span class="token punctuation">]</span>    </code></pre><p>举个小栗子：</p><p>1、输出10次<code>Hello world</code></p><pre class=" language-python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> n <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在输出第%d次 Hello world"</span> <span class="token operator">%</span> n<span class="token punctuation">)</span>    n <span class="token operator">+=</span> <span class="token number">1</span><span class="token triple-quoted-string string">'''提问：    1.此时print(n)输出的值是多少    2.如果把print(n)前面加4个空格，输出的情况是什么样的'''</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><h4 id="4-11-2、for循环"><a href="#4-11-2、for循环" class="headerlink" title="4.11.2、for循环"></a>4.11.2、for循环</h4><p><code>for</code>循环和<code>while</code>循环一样同样可以进行循环，并且是运用最多的循环方式。它有一项非常实用的功能——遍历 。</p><p>在<code>Python</code>中<code>for</code>循环可以遍历任何序列项目，如字符串，或者今后会学到的列表。</p><p><code>for</code>循环的语法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> X <span class="token keyword">in</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>循环执行的代码<span class="token punctuation">]</span>    </code></pre><p>如果遍历列表，就会将列表中的元素全部访问一遍</p><p>如果遍历字符串，就特指将自身的所有字符都全部访问一遍</p><p>下方的代码会输出什么？</p><pre class=" language-python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> names<span class="token punctuation">:</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> i<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>如果我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加</p><pre class=" language-python"><code class="language-python">sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    sum <span class="token operator">+=</span> i    <span class="token comment" spellcheck="true"># 也可以写成 sum = sum + i</span><span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span></code></pre><p><code>Python</code>还提供了一个<code>range()</code>函数，可以配合我们的<code>for</code>循环使用，例如：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#效果等价于</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span></code></pre><p><code>range()</code>函数经常配合for循环使用，需要注意的是，<code>range()</code>函数默认是从0开始的，而且属于<code>[start,end)</code>这种左闭右开区间。</p><h4 id="4-11-3、break"><a href="#4-11-3、break" class="headerlink" title="4.11.3、break"></a>4.11.3、break</h4><p><strong>在循环中</strong>，<code>break</code>语句用于<strong>提前</strong>退出循环。</p><p>现在考虑这样一个问题，现在想找在数字30到70之间<strong>第一个</strong>可以被17整除的数，如果有则直接返回这个数，然后结束本次循环。那么这个程序应该怎么写呢？</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">71</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">17</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 使用break直接强制跳出循环</span>        <span class="token keyword">break</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"循环结束了"</span><span class="token punctuation">)</span></code></pre><p>上面的代码输出了什么？</p><p>因为<code>break</code>直接跳出了循环，所以<code>break</code>后面的语句不会被执行</p><h4 id="4-11-4、continue"><a href="#4-11-4、continue" class="headerlink" title="4.11.4、continue"></a>4.11.4、continue</h4><p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p><p>大家在思考一下，怎样输出1-100中的所有的偶数呢？</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1、本次分享的大部分知识点都是重点，都是后面学习离不开的基础语法。</p><p>2、需要理解<code>break</code>和<code>continue</code>的区别与在循环中的使用</p><p>3、尽量自己动手实践一遍，练习是学习编程最简单的途径</p><h2 id="六、作业"><a href="#六、作业" class="headerlink" title="六、作业"></a>六、作业</h2><p>1、从键盘输入一个正整数年份，判断该年份是否是闰年，判断闰年的方法如下：</p><ol><li>普通年能被4整除且不能被100整除的为<a href="https://www.baidu.com/s?wd=闰年&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">闰年</a>。（如2004年就是<a href="https://www.baidu.com/s?wd=闰年&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">闰年</a>，1900年不是闰年）</li><li>世纪年能被400整除的是闰年。（如2000年是闰年，1900年不是闰年）</li></ol><p>2、实现模拟登录功能：实现用户输入用户名和密码，当用户名为shein且密码为888888时，显示登录成功，否则显示登录失败，失败时允许重复复输入三次，三次全部错误后提示“账户已锁定！”</p><p>3、使用for循环和range实现输出<code>1-2+3-4+5-6+99-100</code>的和</p><p>4、使用循环打印99乘法表,类似下图</p><p><img src="https://i.loli.net/2020/01/06/GMmybqxjEDzt9fA.png" alt></p><h2 id="七、分享"><a href="#七、分享" class="headerlink" title="七、分享"></a>七、分享</h2><p>马上快过年了，给有买火车票需求的小伙伴推荐几个软件，不仅不需要分享凑人数，也比携程、飞猪等等等等的软件成功率高的多，而且免费。</p><p>第一个：<a href="https://www.bypass.cn/" target="_blank" rel="noopener">分流抢票</a>，客户端工具，基于微软.Net开发的抢火车票程序，电脑小白也可以轻松抢到回家的票</p><p>第二个：<a href="https://github.com/testerSunshine" target="_blank" rel="noopener">testerSunshine</a> <code>Python</code>写的抢票软件，目前已经start接近24.8万，fork7.8k，还会继续上涨！是一位叫文贤平的程序员，项目名称很有档次，直接明了，就叫“12306”，功能一直在更新，2018年初开始提交，最近的一次提交是几天前，看得出很用心。</p><p> <img src="https://i.loli.net/2020/01/06/3KAPJMfv5XtanT7.png" alt></p><p>第三个：<a href="https://github.com/pjialin/py12306" target="_blank" rel="noopener">py12306</a> 名叫py12306购票助手。就是说，一台机器抢不到，可以让许多硬件一起跑。它还支持多任务 (多班列车) 、多日期、多账号一起查。另一个机智的功能是，同时观察多个始发站和到达站的组合。第三个项目是在第二个项目的基础之上做的，所以第二个项目有的功能，第三个项目都有。但是第三个项目的一些功能某程度上比第二个项目更加强大一些。</p><p><img src="https://i.loli.net/2020/01/06/k6a9tgLGcxOXB4s.png" alt></p><p>后两个使用起来稍微有些复杂，有需要的小伙伴自行研究，如果有问题随时来找我。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN-5-KNN算法总结</title>
      <link href="/2020/01/05/KNN-5-KNN%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/05/KNN-5-KNN%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="KNN的优点"><a href="#KNN的优点" class="headerlink" title="KNN的优点"></a>KNN的优点</h1><p>1、<code>KNN</code>算法是一个非常简单的算法，理论成熟，思想简单，既可以用来做分类也可以用来做回归</p><p>2、天然解决多分类问题，也可用于回归问题</p><p>3、和朴素贝叶斯之类的算法比，对数据没有假设，准确度高，对异常点不敏感</p><p>4、<code>KNN</code>在训练过程中实质上不需要做任何事情，所以训练本身不产生任何时间上的消耗</p><p>5、由于<code>KNN</code>方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，<code>KNN</code>方法较其他方法更为适合</p><h1 id="KNN的缺点"><a href="#KNN的缺点" class="headerlink" title="KNN的缺点"></a>KNN的缺点</h1><p>1、计算量大，效率低。即使优化算法，效率也不高。</p><p>2、高度数据相关，样本不平衡的时候，对稀有类别的预测准确率低</p><p>3、相比决策树模型，KNN模型可解释性不强</p><p>4、维度灾难：随着维度的增加，“看似相近”的两个点之间的距离越来越大，而knn非常依赖距离</p><table><thead><tr><th>维数</th><th>点到点</th><th>距离</th></tr></thead><tbody><tr><td>1维</td><td>0到1的距离</td><td>1</td></tr><tr><td>2维</td><td>(0,0)到(1,1)的距离</td><td>1.414</td></tr><tr><td>3维</td><td>(0,0,0)到(1,1,1)的距离</td><td>1.73</td></tr><tr><td>64维</td><td>(0,0,…0)到(1,1,…1)</td><td>8</td></tr><tr><td>10000维</td><td>(0,0,…0)到(1,1,…1)</td><td>100</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN-4-KNN算法的优化-KD树</title>
      <link href="/2020/01/05/KNN-4-KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/"/>
      <url>/2020/01/05/KNN-4-KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h1><p><code>KNN</code>算法的重要步骤是<strong>对所有的实例点进行快速k近邻搜索</strong>。如果采用线性扫描（linear scan），要计算输入点与每一个点的距离，时间复杂度非常高。因此在查询操作时，可以使用<strong>kd树</strong>对查询操作进行优化。</p><h2 id="1、kd树的原理"><a href="#1、kd树的原理" class="headerlink" title="1、kd树的原理"></a>1、kd树的原理</h2><p>Kd树是<em>K-dimension tree</em>的缩写，是对数据点在k维空间（如二维(x，y)，三维(x，y，z)，k维(x1，y，z..)）中划分的一种数据结构，主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。<strong>本质上说，Kd-树就是一种平衡二叉树。</strong></p><p><code>k-d tree</code>是每个节点均为<code>k</code>维样本点的二叉树，其上的每个样本点代表一个超平面，该超平面垂直于当前划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在其右子树。即若当前节点的划分维度为<code>d</code>，其左子树上所有点在<code>d</code>维的坐标值均小于当前值，右子树上所有点在d维的坐标值均大于等于当前值，本定义对其任意子节点均成立。</p><p>必须搞清楚的是，<code>k-d</code>树是一种空间划分树，说白了就是把整个空间划分为特定的几个部分，然后在特定空间的部分内进行相关搜索操作。想像一个三维(多维有点为难你的想象力了)空间，<code>kd</code>树按照一定的划分规则把这个三维空间划分了多个空间，如下图所示：</p><p> <img src="https://i.loli.net/2020/01/06/CM8biwa5hoGnrUk.png" alt></p><p>首先，边框为红色的竖直平面将整个空间划分为两部分，此两部分又分别被边框为绿色的水平平面划分为上下两部分。最后此4个子空间又分别被边框为蓝色的竖直平面分割为两部分，变为8个子空间，此8个子空间即为叶子节点。</p><h2 id="2、kd树的构建"><a href="#2、kd树的构建" class="headerlink" title="2、kd树的构建"></a>2、kd树的构建</h2><p>常规的<code>k-d tree</code>的构建过程为：</p><ol><li><p>循环依序取数据点的各维度来作为切分维度</p></li><li><p>取数据点在该维度的中值作为切分超平面</p></li><li><p>将中值左侧的数据点挂在其左子树，将中值右侧的数据点挂在其右子树</p></li><li><p>递归处理其子树，直至所有数据点挂载完毕</p></li></ol><p>对于构建过程，有两个优化点：</p><ul><li>选择切分维度：根据数据点在各维度上的分布情况，方差越大，分布越分散，从方差大的维度开始切分，有较好的切分效果和平衡性。</li></ul><ul><li>确定中值点：预先对原始数据点在所有维度进行一次排序，存储下来，然后在后续的中值选择中，无须每次都对其子集进行排序，提升了性能。也可以从原始数据点中随机选择固定数目的点，然后对其进行排序，每次从这些样本点中取中值，来作为分割超平面。该方式在实践中被证明可以取得很好性能及很好的平衡性。</li></ul><p>例子：采用常规的构建方式，以二维平面点(x,y)的集合(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2) 为例结合下图来说明k-d tree的构建过程：</p><pre><code>1、构建根节点时，此时的切分维度为x，如上点集合在x维从小到大排序为(2,3)，(4,7)，(5,4)，(7,2)，(8,1)，(9,6)；其中值为(7,2)。（注：2,4,5,7,8,9在数学中的中值为(5 + 7)/2=6，但因该算法的中值需在点集合之内，所以本文中值计算用的是len(points)//2=3, points[3]=(7,2)）2、(2,3)，(4,7)，(5,4)挂在(7,2)节点的左子树，(8,1)，(9,6)挂在(7,2)节点的右子树。3、构建(7,2)节点的左子树时，点集合(2,3)，(4,7)，(5,4)此时的切分维度为y，中值为(5,4)作为分割平面，(2,3)挂在其左子树，(4,7)挂在其右子树。4、构建(7,2)节点的右子树时，点集合(8,1)，(9,6)此时的切分维度也为y，中值为(9,6)作为分割平面，(8,1)挂在其左子树。至此k-d tree构建完成。</code></pre><p><img src="/.top//C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1578321492531.png" alt="1578321492531"></p><p>如上算法所述，kd树的构建是一个递归过程，我们对左子空间和右子空间内的数据重复根节点的过程就可以得到一级子节点（5,4）和（9,6），同时将空间和数据集进一步细分，如此往复直到空间中只包含一个数据点。</p><p><img src="https://i.loli.net/2020/01/06/KrNegciq4jZWTmH.png" alt></p><p>如之前所述，kd树中，kd代表k-dimension，每个节点即为一个k维的点。每个非叶节点可以想象为一个分割超平面，用垂直于坐标轴的超平面将空间分为两个部分，这样递归的从根节点不停的划分，直到没有实例为止。经典的构造k-d tree的规则如下：</p><pre><code>1、随着树的深度增加，循环的选取坐标轴，作为分割超平面的法向量。对于3-d tree来说，根节点选取x轴，根节点的孩子选取y轴，根节点的孙子选取z轴，根节点的曾孙子选取x轴，这样循环下去。2、每次均为所有对应实例的中位数的实例作为切分点，切分点作为父节点，左右两侧为划分的作为左右两子树。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># points为实例点集合，depth深度，为用来确定取维度的参数</span><span class="token keyword">def</span> <span class="token function">kd_tree</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">==</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> None    <span class="token comment" spellcheck="true"># 指定切分维度，len(points[0])是数据的实际维度，这样计算可以保证循环</span>    cutting_dim <span class="token operator">=</span> depth <span class="token operator">%</span> len<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 切分点初始化</span>    medium_index <span class="token operator">=</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 对所有的实例点按照指定维度进行排序，itemgetter用于获取对象哪些维度上的数据，参数为需要获取的数据在对象中的序号</span>    points<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>itemgetter<span class="token punctuation">(</span>cutting_dim<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 将该维度的中值点作为根节点</span>    node <span class="token operator">=</span> Node<span class="token punctuation">(</span>points<span class="token punctuation">[</span>medium_index<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 对于左子树，重复构建（depth+1）</span>    node<span class="token punctuation">.</span>left <span class="token operator">=</span> kd_tree<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token punctuation">:</span>medium_index<span class="token punctuation">]</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 对于右子树，重复构建（depth+1）</span>    node<span class="token punctuation">.</span>right <span class="token operator">=</span> kd_tree<span class="token punctuation">(</span>points<span class="token punctuation">[</span>medium_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> node</code></pre><h2 id="3、kd树的检索"><a href="#3、kd树的检索" class="headerlink" title="3、kd树的检索"></a>3、kd树的检索</h2><p>kd树的检索是KNN算法至关重要的一步，给定点p，查询数据集中与其距离最近点的过程即为最近邻搜索。<br><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.gif" alt="检索步骤（图片来自于数据科学家联盟公众号）"><br>如在构建好的k-d tree上搜索(3,5)的最近邻时，对二维空间的最近邻搜索过程作分析。</p><p>首先从根节点(7,2)出发，将当前最近邻设为(7,2)，对该k-d tree作深度优先遍历。</p><p>以(3,5)为圆心，其到(7,2)的距离为半径画圆（多维空间为超球面），可以看出(8,1)右侧的区域与该圆不相交，所以(8,1)的右子树全部忽略。</p><p>接着走到(7,2)左子树根节点(5,4)，与原最近邻对比距离后，更新当前最近邻为(5,4)。</p><p>以(3,5)为圆心，其到(5,4)的距离为半径画圆，发现(7,2)右侧的区域与该圆不相交，忽略该侧所有节点，这样(7,2)的整个右子树被标记为已忽略。</p><p>遍历完(5,4)的左右叶子节点，发现与当前最优距离相等，不更新最近邻。所以(3,5)的最近邻为(5,4)。<br><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/%E6%A3%80%E7%B4%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="检索示意图（图片来自于数据科学家联盟公众号）"></p><p>举例：查询点（2.1,3.1）</p><p>星号表示要查询的点（2.1,3.1）。通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点（2,3）。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行相关的‘回溯’操作。也就是说，算法首先沿搜索路径反向查找是否有距离查询点更近的数据点。</p><pre><code>1、二叉树搜索：先从（7,2）点开始进行二叉查找，然后到达（5,4），最后到达（2,3），此时搜索路径中的节点为&lt;(7,2)，(5,4)，(2,3)&gt;，首先以（2,3）作为当前最近邻点，计算其到查询点（2.1,3.1）的距离为0.1414，2、回溯查找：在得到（2,3）为查询点的最近点之后，回溯到其父节点（5,4），并判断在该父节点的其他子节点空间中是否有距离查询点更近的数据点。以（2.1,3.1）为圆心，以0.1414为半径画圆，如下图所示。发现该圆并不和超平面y = 4交割，因此不用进入（5,4）节点右子空间中(图中灰色区域)去搜索；3、最后，再回溯到（7,2），以（2.1,3.1）为圆心，以0.1414为半径的圆更不会与x = 7超平面交割，因此不用进入（7,2）右子空间进行查找。至此，搜索路径中的节点已经全部回溯完，结束整个搜索，返回最近邻点（2,3），最近距离为0.1414。</code></pre><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/example1.jpg" alt="example1"></p><p>举例：查询点（2，4.5）</p><p>一个复杂点了例子如查找点为（2，4.5），具体步骤依次如下：</p><pre><code>1、同样先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但（4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点；2、以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；3、回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。</code></pre><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/example2.jpg" alt="example2"></p><p> 上述两次实例表明，当查询点的邻域与分割超平面两侧空间交割时，需要查找另一侧子空间，导致检索过程复杂，效率下降。</p><p> 一般来讲，最临近搜索只需要检测几个叶子结点即可，如下图所示：　<br> <img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/1.jpg" alt="1"><br> 但是，如果当实例点的分布比较糟糕时，几乎要遍历所有的结点，如下所示：<br> <img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/2.jpg" alt="2"><br> 研究表明N个节点的K维k-d树搜索过程时间复杂度为：tworst=O（kN1-1/k）。</p><p>同时，以上为了介绍方便，讨论的是二维或三维情形。但在实际的应用中，如SIFT特征矢量128维，SURF特征矢量64维，维度都比较大，直接利用k-d树快速检索（维数不超过20）的性能急剧下降，几乎接近贪婪线性扫描。假设数据集的维数为D，一般来说要求数据的规模N满足N»2D，才能达到高效的搜索。</p><h2 id="4、sklearn中的KDTree"><a href="#4、sklearn中的KDTree" class="headerlink" title="4、sklearn中的KDTree"></a>4、sklearn中的KDTree</h2><p>Sklearn中有KDTree的实现，仅构建了一个二维空间的k-d tree，然后对其作k近邻搜索及指定半径的范围搜索。多维空间的检索，调用方式与此例相差无多。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> matplotlib<span class="token punctuation">.</span>patches <span class="token keyword">import</span> Circle<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KDTree<span class="token operator">%</span>matplotlib inlinenp<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>points <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(points)</span>tree <span class="token operator">=</span> KDTree<span class="token punctuation">(</span>points<span class="token punctuation">)</span>point <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kNN</span>dists<span class="token punctuation">,</span> indices <span class="token operator">=</span> tree<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dists<span class="token punctuation">,</span> indices<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># query radius</span>indices <span class="token operator">=</span> tree<span class="token punctuation">.</span>query_radius<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span> aspect<span class="token operator">=</span><span class="token string">'equal'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>add_patch<span class="token punctuation">(</span>Circle<span class="token punctuation">(</span>point<span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>point<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>[[0.         0.06703304 0.10907128]] [[ 0 68 11]][array([62,  1, 67, 68,  2, 53, 16, 18, 93, 22, 55,  0, 11], dtype=int64)]</code></pre><h1 id="KD树-1"><a href="#KD树-1" class="headerlink" title="KD树"></a>KD树</h1><p>KNN算法的重要步骤是对所有的实例点进行快速k近邻搜索。如果采用线性扫描（linear scan），要计算输入点与每一个点的距离，时间复杂度非常高。因此在查询操作时，可以使用kd树对查询操作进行优化。</p><h2 id="1、kd树的原理-1"><a href="#1、kd树的原理-1" class="headerlink" title="1、kd树的原理"></a>1、kd树的原理</h2><p>Kd-树是K-dimension tree的缩写，是对数据点在k维空间（如二维(x，y)，三维(x，y，z)，k维(x1，y，z..)）中划分的一种数据结构，主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。本质上说，Kd-树就是一种平衡二叉树。</p><p>k-d tree是每个节点均为k维样本点的二叉树，其上的每个样本点代表一个超平面，该超平面垂直于当前划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在其右子树。即若当前节点的划分维度为d，其左子树上所有点在d维的坐标值均小于当前值，右子树上所有点在d维的坐标值均大于等于当前值，本定义对其任意子节点均成立。</p><p>必须搞清楚的是，k-d树是一种空间划分树，说白了，就是把整个空间划分为特定的几个部分，然后在特定空间的部分内进行相关搜索操作。想像一个三维(多维有点为难你的想象力了)空间，kd树按照一定的划分规则把这个三维空间划分了多个空间，如下图所示：</p><p>   <img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/KD%E6%A0%91%E5%88%92%E5%88%86%E5%90%8E%E7%9A%84%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="KD树划分后的三维空间"></p><p>首先，边框为红色的竖直平面将整个空间划分为两部分，此两部分又分别被边框为绿色的水平平面划分为上下两部分。最后此4个子空间又分别被边框为蓝色的竖直平面分割为两部分，变为8个子空间，此8个子空间即为叶子节点。</p><h2 id="2、kd树的构建-1"><a href="#2、kd树的构建-1" class="headerlink" title="2、kd树的构建"></a>2、kd树的构建</h2><p>常规的k-d tree的构建过程为：</p><pre><code>1、循环依序取数据点的各维度来作为切分维度2、取数据点在该维度的中值作为切分超平面3、将中值左侧的数据点挂在其左子树，将中值右侧的数据点挂在其右子树4、递归处理其子树，直至所有数据点挂载完毕</code></pre><p>对于构建过程，有两个优化点：</p><ul><li>选择切分维度：根据数据点在各维度上的分布情况，方差越大，分布越分散，从方差大的维度开始切分，有较好的切分效果和平衡性。</li></ul><ul><li>确定中值点：预先对原始数据点在所有维度进行一次排序，存储下来，然后在后续的中值选择中，无须每次都对其子集进行排序，提升了性能。也可以从原始数据点中随机选择固定数目的点，然后对其进行排序，每次从这些样本点中取中值，来作为分割超平面。该方式在实践中被证明可以取得很好性能及很好的平衡性。</li></ul><p>例子：采用常规的构建方式，以二维平面点(x,y)的集合(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2) 为例结合下图来说明k-d tree的构建过程：</p><pre><code>1、构建根节点时，此时的切分维度为x，如上点集合在x维从小到大排序为(2,3)，(4,7)，(5,4)，(7,2)，(8,1)，(9,6)；其中值为(7,2)。（注：2,4,5,7,8,9在数学中的中值为(5 + 7)/2=6，但因该算法的中值需在点集合之内，所以本文中值计算用的是len(points)//2=3, points[3]=(7,2)）2、(2,3)，(4,7)，(5,4)挂在(7,2)节点的左子树，(8,1)，(9,6)挂在(7,2)节点的右子树。3、构建(7,2)节点的左子树时，点集合(2,3)，(4,7)，(5,4)此时的切分维度为y，中值为(5,4)作为分割平面，(2,3)挂在其左子树，(4,7)挂在其右子树。4、构建(7,2)节点的右子树时，点集合(8,1)，(9,6)此时的切分维度也为y，中值为(9,6)作为分割平面，(8,1)挂在其左子树。至此k-d tree构建完成。</code></pre><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/kd%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.webp" alt="构建过程（图片来自于数据科学家联盟公众号）"><br><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/kd%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="构建过程"></p><p>如上算法所述，kd树的构建是一个递归过程，我们对左子空间和右子空间内的数据重复根节点的过程就可以得到一级子节点（5,4）和（9,6），同时将空间和数据集进一步细分，如此往复直到空间中只包含一个数据点。</p><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/kd%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt="构建过程"></p><p>如之前所述，kd树中，kd代表k-dimension，每个节点即为一个k维的点。每个非叶节点可以想象为一个分割超平面，用垂直于坐标轴的超平面将空间分为两个部分，这样递归的从根节点不停的划分，直到没有实例为止。经典的构造k-d tree的规则如下：</p><pre><code>1、随着树的深度增加，循环的选取坐标轴，作为分割超平面的法向量。对于3-d tree来说，根节点选取x轴，根节点的孩子选取y轴，根节点的孙子选取z轴，根节点的曾孙子选取x轴，这样循环下去。2、每次均为所有对应实例的中位数的实例作为切分点，切分点作为父节点，左右两侧为划分的作为左右两子树。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># points为实例点集合，depth深度，为用来确定取维度的参数</span><span class="token keyword">def</span> <span class="token function">kd_tree</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">==</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> None    <span class="token comment" spellcheck="true"># 指定切分维度，len(points[0])是数据的实际维度，这样计算可以保证循环</span>    cutting_dim <span class="token operator">=</span> depth <span class="token operator">%</span> len<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 切分点初始化</span>    medium_index <span class="token operator">=</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 对所有的实例点按照指定维度进行排序，itemgetter用于获取对象哪些维度上的数据，参数为需要获取的数据在对象中的序号</span>    points<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>itemgetter<span class="token punctuation">(</span>cutting_dim<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 将该维度的中值点作为根节点</span>    node <span class="token operator">=</span> Node<span class="token punctuation">(</span>points<span class="token punctuation">[</span>medium_index<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 对于左子树，重复构建（depth+1）</span>    node<span class="token punctuation">.</span>left <span class="token operator">=</span> kd_tree<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token punctuation">:</span>medium_index<span class="token punctuation">]</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 对于右子树，重复构建（depth+1）</span>    node<span class="token punctuation">.</span>right <span class="token operator">=</span> kd_tree<span class="token punctuation">(</span>points<span class="token punctuation">[</span>medium_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> node</code></pre><h2 id="3、kd树的检索-1"><a href="#3、kd树的检索-1" class="headerlink" title="3、kd树的检索"></a>3、kd树的检索</h2><p>kd树的检索是KNN算法至关重要的一步，给定点p，查询数据集中与其距离最近点的过程即为最近邻搜索。<br><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.gif" alt="检索步骤（图片来自于数据科学家联盟公众号）"><br>如在构建好的k-d tree上搜索(3,5)的最近邻时，对二维空间的最近邻搜索过程作分析。</p><p>首先从根节点(7,2)出发，将当前最近邻设为(7,2)，对该k-d tree作深度优先遍历。</p><p>以(3,5)为圆心，其到(7,2)的距离为半径画圆（多维空间为超球面），可以看出(8,1)右侧的区域与该圆不相交，所以(8,1)的右子树全部忽略。</p><p>接着走到(7,2)左子树根节点(5,4)，与原最近邻对比距离后，更新当前最近邻为(5,4)。</p><p>以(3,5)为圆心，其到(5,4)的距离为半径画圆，发现(7,2)右侧的区域与该圆不相交，忽略该侧所有节点，这样(7,2)的整个右子树被标记为已忽略。</p><p>遍历完(5,4)的左右叶子节点，发现与当前最优距离相等，不更新最近邻。所以(3,5)的最近邻为(5,4)。<br><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/%E6%A3%80%E7%B4%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="检索示意图（图片来自于数据科学家联盟公众号）"></p><p>举例：查询点（2.1,3.1）</p><p>星号表示要查询的点（2.1,3.1）。通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点（2,3）。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行相关的‘回溯’操作。也就是说，算法首先沿搜索路径反向查找是否有距离查询点更近的数据点。</p><pre><code>1、二叉树搜索：先从（7,2）点开始进行二叉查找，然后到达（5,4），最后到达（2,3），此时搜索路径中的节点为&lt;(7,2)，(5,4)，(2,3)&gt;，首先以（2,3）作为当前最近邻点，计算其到查询点（2.1,3.1）的距离为0.1414，2、回溯查找：在得到（2,3）为查询点的最近点之后，回溯到其父节点（5,4），并判断在该父节点的其他子节点空间中是否有距离查询点更近的数据点。以（2.1,3.1）为圆心，以0.1414为半径画圆，如下图所示。发现该圆并不和超平面y = 4交割，因此不用进入（5,4）节点右子空间中(图中灰色区域)去搜索；3、最后，再回溯到（7,2），以（2.1,3.1）为圆心，以0.1414为半径的圆更不会与x = 7超平面交割，因此不用进入（7,2）右子空间进行查找。至此，搜索路径中的节点已经全部回溯完，结束整个搜索，返回最近邻点（2,3），最近距离为0.1414。</code></pre><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/example1.jpg" alt="example1"></p><p>举例：查询点（2，4.5）</p><p>一个复杂点了例子如查找点为（2，4.5），具体步骤依次如下：</p><pre><code>1、同样先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径&lt;(7,2)，(5,4)，(4,7)&gt;，但（4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点；2、以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得&lt;(7,2)，(2,3)&gt;；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；3、回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。</code></pre><p><img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/example2.jpg" alt="example2"></p><p> 上述两次实例表明，当查询点的邻域与分割超平面两侧空间交割时，需要查找另一侧子空间，导致检索过程复杂，效率下降。</p><p> 一般来讲，最临近搜索只需要检测几个叶子结点即可，如下图所示：　<br> <img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/1.jpg" alt="1"><br> 但是，如果当实例点的分布比较糟糕时，几乎要遍历所有的结点，如下所示：<br> <img src="/.top//Users/Administrator/Desktop/4%E3%80%81KNN%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96-KD%E6%A0%91/file/2.jpg" alt="2"><br> 研究表明N个节点的K维k-d树搜索过程时间复杂度为：tworst=O（kN1-1/k）。</p><p>同时，以上为了介绍方便，讨论的是二维或三维情形。但在实际的应用中，如SIFT特征矢量128维，SURF特征矢量64维，维度都比较大，直接利用k-d树快速检索（维数不超过20）的性能急剧下降，几乎接近贪婪线性扫描。假设数据集的维数为D，一般来说要求数据的规模N满足N»2D，才能达到高效的搜索。</p><h2 id="4、sklearn中的KDTree-1"><a href="#4、sklearn中的KDTree-1" class="headerlink" title="4、sklearn中的KDTree"></a>4、sklearn中的KDTree</h2><p>Sklearn中有KDTree的实现，仅构建了一个二维空间的k-d tree，然后对其作k近邻搜索及指定半径的范围搜索。多维空间的检索，调用方式与此例相差无多。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> matplotlib<span class="token punctuation">.</span>patches <span class="token keyword">import</span> Circle<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KDTree<span class="token operator">%</span>matplotlib inlinenp<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>points <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(points)</span>tree <span class="token operator">=</span> KDTree<span class="token punctuation">(</span>points<span class="token punctuation">)</span>point <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kNN</span>dists<span class="token punctuation">,</span> indices <span class="token operator">=</span> tree<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dists<span class="token punctuation">,</span> indices<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># query radius</span>indices <span class="token operator">=</span> tree<span class="token punctuation">.</span>query_radius<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span> aspect<span class="token operator">=</span><span class="token string">'equal'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>add_patch<span class="token punctuation">(</span>Circle<span class="token punctuation">(</span>point<span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token punctuation">[</span>point<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>point<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>[[0.         0.06703304 0.10907128]] [[ 0 68 11]][array([62,  1, 67, 68,  2, 53, 16, 18, 93, 22, 55,  0, 11], dtype=int64)]</code></pre><p><img src="https://i.loli.net/2020/01/06/THU5YQlgh6JnrRe.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN-3-KNN算法实操</title>
      <link href="/2020/01/05/KNN-3-KNN%E7%AE%97%E6%B3%95%E5%AE%9E%E6%93%8D/"/>
      <url>/2020/01/05/KNN-3-KNN%E7%AE%97%E6%B3%95%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Means聚类算法</title>
      <link href="/2019/12/29/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/29/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="K-Means聚类算法"><a href="#K-Means聚类算法" class="headerlink" title="K-Means聚类算法"></a>K-Means聚类算法</h1><h2 id="Kmeans聚类的思想和原理"><a href="#Kmeans聚类的思想和原理" class="headerlink" title="Kmeans聚类的思想和原理"></a>Kmeans聚类的思想和原理</h2><h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>对于有监督的数据挖掘算法而言，数据集中需要包含标签变量（即因变量y的值）。但在有些场景下，并没有给定的y值，对于这类数据的建模，一般称为无监督的数据挖掘算法，最为典型的当属聚类算法。</p><p>Kmeans聚类算法利用距离远近的思想将目标数据聚为指定的k个簇，进而使样本呈现簇内差异小，簇间差异大的特征。</p><h3 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h3><ul><li>从数据中随机挑选<em>k</em>个样本点作为原始的簇中心</li><li>计算剩余样本与簇中心的距离，并把各样本标记为离<em>k</em>个簇中心最近的类别</li><li>重新计算各簇中样本点的均值，并以均值作为新的<em>k</em>个簇中心</li><li>不断重复第二步和第三步，直到簇中心的变化趋于稳定，形成最终的<em>k</em>个簇</li></ul><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>在Kmeans聚类模型中，对于指定的k个簇，只有簇内样本越相似，聚类效果才越好。基于这个思想，可以理解为簇内样本的离差平方和之和达到最小即可。进而可以衍生出Kmeans聚类的目标函数：<br>$$<br>J(c_1,c_2,…c_k)={\sum_{j=1}^{k}\sum_{i}^{n_j}(x_{i}-{c_j})^2}<br>$$<br>其中，$c_j$表示第j个簇的簇中心，$x_i$属于第j个簇的样本i，$n_j$表示第j个簇的样本总量。对于该目标函数而言，$c_j$是未知的参数，要想求得目标函数的最小值，得先知道参数$c_j$的值。  </p><h3 id="求解参数-𝑐-𝑗"><a href="#求解参数-𝑐-𝑗" class="headerlink" title="求解参数$𝑐_𝑗$"></a>求解参数$𝑐_𝑗$</h3><p>1、对目标函数求偏导<br>$$<br>\frac{\partial J}{\partial c_{j}}=\sum_{j=1}^{k} \sum_{i=1}^{n_{j}} \frac{\left(x_{i}-c_{j}\right)^{2}}{\partial c_{j}}=\sum_{i=1}^{n_{j}} \frac{\left(x_{i}-c_{j}\right)^{2}}{\partial c_{j}}=\sum_{i=1}^{n_{j}}-2\left(x_{i}-c_{j}\right)<br>$$<br>2、令导数为0<br>$$<br>\begin{array}{l}{\sum_{i=1}^{n_{j}}-2\left(x_{i}-c_{j}\right)=0} \ {n_{j} c_{j}-\sum_{i=1}^{n_{j}} x_{i}=0} \ {\therefore c_{j}=\frac{\sum_{i=1}^{n_{j}} x_{i}}{n_{j}}=\mu_{j}}\end{array}<br>$$</p><h3 id="Scikit-learn中的KMeans函数"><a href="#Scikit-learn中的KMeans函数" class="headerlink" title="Scikit-learn中的KMeans函数"></a>Scikit-learn中的KMeans函数</h3><pre class=" language-python"><code class="language-python">KMeans<span class="token punctuation">(</span>n_clusters<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> init<span class="token operator">=</span><span class="token string">'k-means++'</span><span class="token punctuation">,</span> n_init<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>        max_iter<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> tol<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">,</span>        precompute_distances<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span>        verbose<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span>None<span class="token punctuation">,</span>copy_x<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        n_jobs<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> algorithm<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">)</span></code></pre><p><strong>n_clusters</strong>：用于指定聚类的簇数</p><p><strong>init</strong>：用于指定初始的簇中心设置方法，如果为’k-means++’，则表示设置的初始簇中心之间相距较远；如果为’random’，则表示从数据集中随机挑选k个样本作为初始簇中心；如果为数组，则表示用户指定具体的簇中心</p><p><strong>n_init</strong>：用于指定Kmeans算法运行的次数，每次运行时都会选择不同的初始簇中心，目的是防止算法收敛于局部最优，默认为10</p><p><strong>max_iter</strong>：用于指定单次运行的迭代次数，默认为300</p><p><strong>tol</strong>：用于指定算法收敛的阈值，默认为0.0001</p><p><strong>precompute_distances</strong>：bool类型的参数，是否在算法运行之前计算样本之间的距离，默认为’auto’，表示当样本量与变量个数的乘积大于1200万时不计算样本间距离</p><p><strong>verbose</strong>：通过该参数设置算法返回日志信息的频度，默认为0，表示不输出日志信息；如果为1，就表示每隔一段时间返回一次日志信息</p><p><strong>random_state</strong>：用于指定随机数生成器的种子</p><p><strong>copy_x</strong>：bool类型参数，当参数precompute_distances 为True时有效，如果该参数为True，就表示提前计算距离时不改变原始数据，否则会修改原始数据</p><p><strong>n_jobs</strong>：用于指定算法运算时使用的CPU数量，默认为1，如果为-1，就表示使用所有可用的CPU</p><p><strong>algorithm</strong>：用于指定Kmeans的实现算法，可以选择’auto’ ‘full’和’elkan’，默认为’auto’，表示自动根据数据特征选择运算的算法</p><h2 id="最佳k值的选择"><a href="#最佳k值的选择" class="headerlink" title="最佳k值的选择"></a>最佳k值的选择</h2><h3 id="拐点法"><a href="#拐点法" class="headerlink" title="拐点法"></a>拐点法</h3><p>簇内离差平方和拐点法的思想很简单，就是在不同的k值下计算簇内离差平方和，然后通过可视化的方法找到“拐点”所对应的k值。当折线图中的斜率由大突然变小时，并且之后的斜率变化缓慢，则认为突然变化的点就是寻找的目标点，因为继续随着簇数k的增加，聚类效果不再有大的变化。  </p><p><img src="https://i.loli.net/2019/12/29/5PeZQL7UBwscujR.png" alt></p><p><img src="https://i.loli.net/2019/12/29/72GIExh9MbNyCkv.png" alt></p><h4 id="拐点法核心代码"><a href="#拐点法核心代码" class="headerlink" title="拐点法核心代码"></a>拐点法核心代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">k_SSE</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> clusters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 选择连续的K种不同的值</span>    K <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>clusters<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 构建空列表用于存储总的簇内离差平方和</span>    TSSE <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> K<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 用于存储各个簇内离差平方和</span>        SSE <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        kmeans <span class="token operator">=</span> KMeans<span class="token punctuation">(</span>n_clusters<span class="token operator">=</span>k<span class="token punctuation">)</span>        kmeans<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 返回簇标签</span>        labels <span class="token operator">=</span> kmeans<span class="token punctuation">.</span>labels_        <span class="token comment" spellcheck="true"># 返回簇中心</span>        centers <span class="token operator">=</span> kmeans<span class="token punctuation">.</span>cluster_centers_        <span class="token comment" spellcheck="true"># 计算各簇样本的离差平方和，并保存到列表中</span>        <span class="token keyword">for</span> label <span class="token keyword">in</span> set<span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">:</span>            SSE<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>labels <span class="token operator">==</span> label<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token operator">-</span>centers<span class="token punctuation">[</span>label<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 计算总的簇内离差平方和 </span>        TSSE<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>SSE<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="轮廓系数法"><a href="#轮廓系数法" class="headerlink" title="轮廓系数法"></a>轮廓系数法</h3><p>该方法综合考虑了簇的密集性与分散性两个信息，如果数据集被分割为理想的k个簇，那么对应的簇内样本会很密集，而簇间样本会很分散。轮廓系数的计算公式可以表示为：  </p><p>$$<br>S(i)=\frac{b{(i)}-a(i)}{max(a(i)-b{(i)})}<br>$$</p><h4 id="轮廓系数法中-a-i-和-b-i-的计算含义"><a href="#轮廓系数法中-a-i-和-b-i-的计算含义" class="headerlink" title="轮廓系数法中$a(i)$和$b(i)$的计算含义"></a>轮廓系数法中$a(i)$和$b(i)$的计算含义</h4><p><img src="https://i.loli.net/2019/12/29/xUrvukyDmiMwpo4.png" alt></p><p>假设数据集被拆分为4个簇，样本i对应的a(i)值就是所有$C_1$中其他样本点与样本i的距离平均值；样本i对应的b(i)值分两步计算，首先计算该点分别到$C_2$、$C_3$和$C_4$中样本点的平均距离，然后将三个平均值中的最小值作为b(i)的度量。  </p><p><img src="https://i.loli.net/2019/12/29/u4sQJnCTYNBb8Uk.png" alt></p><p><img src="https://i.loli.net/2019/12/29/gqhJ4I9jwa6vUE8.png" alt></p><h4 id="轮廓系数法的核心代码"><a href="#轮廓系数法的核心代码" class="headerlink" title="轮廓系数法的核心代码"></a>轮廓系数法的核心代码</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构造自定义函数 </span><span class="token keyword">def</span> <span class="token function">k_silhouette</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> clusters<span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>clusters<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 构建空列表，用于存储不同簇数下的轮廓系数</span>    S <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> K<span class="token punctuation">:</span>        kmeans <span class="token operator">=</span> KMeans<span class="token punctuation">(</span>n_clusters<span class="token operator">=</span>k<span class="token punctuation">)</span>        kmeans<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        labels <span class="token operator">=</span> kmeans<span class="token punctuation">.</span>labels_        <span class="token comment" spellcheck="true"># 调用子模块metrics中的silhouette_score函数，计算轮廓系数</span>        S<span class="token punctuation">.</span>append<span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>silhouette_score<span class="token punctuation">(</span>X<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">'euclidean'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="Kmeans聚类的应用实战"><a href="#Kmeans聚类的应用实战" class="headerlink" title="Kmeans聚类的应用实战"></a>Kmeans聚类的应用实战</h2><h4 id="聚类前的准备"><a href="#聚类前的准备" class="headerlink" title="聚类前的准备"></a>聚类前的准备</h4><p>聚类前必须指定具体的簇数k值，如果k值是已知的，可以直接调用cluster子模块中的Kmeans类，对数据集进行分割；如果k值是未知的，可以根据行业经验或前面介绍的三种方法确定合理的k值；</p><p>另一个是对原始数据集做必要的标准化处理，由于聚类是基于点之间的距离实现的，所以，如果原始数据集存在量纲上的差异，就必须对其进行标准化的预处理；</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入第三方包</span><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np  <span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>cluster <span class="token keyword">import</span> KMeans<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metrics<span class="token operator">%</span>matplotlib inline<span class="token comment" spellcheck="true"># 读取iris数据集</span>iris <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>r<span class="token string">'iris.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看数据集的前几行</span>iris<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://i.loli.net/2019/12/29/tXJfnCy8TjZeizh.png" alt></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 提取出用于建模的数据集X</span>X <span class="token operator">=</span> iris<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>labels <span class="token operator">=</span> <span class="token string">'Species'</span><span class="token punctuation">,</span> axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 构建Kmeans模型</span>kmeans <span class="token operator">=</span> KMeans<span class="token punctuation">(</span>n_clusters <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>kmeans<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 聚类结果标签</span>X<span class="token punctuation">[</span><span class="token string">'cluster'</span><span class="token punctuation">]</span> <span class="token operator">=</span> kmeans<span class="token punctuation">.</span>labels_<span class="token comment" spellcheck="true"># 各类频数统计</span>X<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token number">0</span>    <span class="token number">62</span><span class="token number">1</span>    <span class="token number">50</span><span class="token number">2</span>    <span class="token number">38</span>Name<span class="token punctuation">:</span> cluster<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span class="token comment" spellcheck="true"># 导入第三方模块</span><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token comment" spellcheck="true"># 三个簇的簇中心</span>centers <span class="token operator">=</span> kmeans<span class="token punctuation">.</span>cluster_centers_<span class="token comment" spellcheck="true"># 绘制聚类效果的散点图</span>sns<span class="token punctuation">.</span>lmplot<span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token string">'Petal_Length'</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'Petal_Width'</span><span class="token punctuation">,</span> hue <span class="token operator">=</span> <span class="token string">'cluster'</span><span class="token punctuation">,</span>            markers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'^'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            data <span class="token operator">=</span> X<span class="token punctuation">,</span> fit_reg <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span> scatter_kws <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'alpha'</span><span class="token punctuation">:</span><span class="token number">0.8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            legend_out <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>centers<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> centers<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> marker <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">130</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'花瓣长度'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'花瓣宽度'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 图形显示</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://i.loli.net/2019/12/29/dEZpHo9XPMUSzxJ.png" alt></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入第三方模块</span><span class="token keyword">import</span> pygal<span class="token comment" spellcheck="true"># 调用Radar这个类，并设置雷达图的填充，及数据范围</span>radar_chart <span class="token operator">=</span> pygal<span class="token punctuation">.</span>Radar<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加雷达图各顶点的名称</span>radar_chart<span class="token punctuation">.</span>x_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'花萼长度'</span><span class="token punctuation">,</span><span class="token string">'花萼宽度'</span><span class="token punctuation">,</span><span class="token string">'花瓣长度'</span><span class="token punctuation">,</span><span class="token string">'花瓣宽度'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制三个雷达图区域，代表三个簇中心的指标值</span>radar_chart<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">'C1'</span><span class="token punctuation">,</span> centers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>radar_chart<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">'C2'</span><span class="token punctuation">,</span> centers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>radar_chart<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">'C3'</span><span class="token punctuation">,</span> centers<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图像</span><span class="token comment" spellcheck="true"># radar_chart.render_to_png('radar_chart.png')</span>radar_chart<span class="token punctuation">.</span>render_to_file<span class="token punctuation">(</span><span class="token string">'radar_chart.svg'</span><span class="token punctuation">)</span></code></pre><p><img src="https://i.loli.net/2019/12/29/8uH2CUJeY45KyDc.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分享-1-初识Python</title>
      <link href="/2019/12/25/Python%E5%88%86%E4%BA%AB-1-%E5%88%9D%E8%AF%86Python/"/>
      <url>/2019/12/25/Python%E5%88%86%E4%BA%AB-1-%E5%88%9D%E8%AF%86Python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python分享第一节"><a href="#Python分享第一节" class="headerlink" title="Python分享第一节"></a>Python分享第一节</h1><p>最近受邀给团队中的小伙伴们分享Python知识，初步打算分成6节课教大家基础语法，然后再往数据分析方向拓展，本篇文章是第一节课的基本内容。</p><h2 id="一、课前准备"><a href="#一、课前准备" class="headerlink" title="一、课前准备"></a>一、课前准备</h2><ol><li>笔记本电脑</li><li>Anaconda安装包</li></ol><h2 id="二、课堂主题"><a href="#二、课堂主题" class="headerlink" title="二、课堂主题"></a>二、课堂主题</h2><p>第一课主要帮助零基础的同学了解Python以及帮助大家安装好Python的工作环境，同时普及一些基本的计算机知识，从而让大家可以更快的开始Python语法的学习。</p><h2 id="三、本节目标"><a href="#三、本节目标" class="headerlink" title="三、本节目标"></a>三、本节目标</h2><p>1、Python简介</p><p>2、为什么要学习Python</p><p>3、Python的安装与jupyter notebook的安装与使用</p><p>4、如何书写Markdown</p><p>5、解决问题的通用方法&amp;书籍推荐</p><h2 id="四、知识要点"><a href="#四、知识要点" class="headerlink" title="四、知识要点"></a>四、知识要点</h2><h3 id="4-1、Python简介"><a href="#4-1、Python简介" class="headerlink" title="4.1、Python简介"></a>4.1、Python简介</h3><h4 id="4-1-1、什么是Python语言"><a href="#4-1-1、什么是Python语言" class="headerlink" title="4.1.1、什么是Python语言"></a>4.1.1、什么是Python语言</h4><p>在学习<strong>Python</strong>之前，先向大家普及一些基本的计算机知识。</p><p>用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个文件，编写一个文档等等，而计算机干活的CPU只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。</p><p>相信大家在大学中都学过<strong>C</strong>语言，C语言的基本设计原则是让机器能够更快的运行，在那个年代，个人电脑的配置普遍都很低，所以更需要C这种更贴近于底层的语言，所以C语言的编写过程需要耗费大量的时间，即使他已经准确的知道功能应该如何实现，也因此，大家把C语言叫做<strong>面向过程</strong>的编程语言。 </p><p><strong>Python</strong>也是编程语言的一种，而且是一门<strong>高级</strong>编程语言，Python语法简单且功能强大，不仅适合初学者，也适合专业人员使用。</p><p>对于不同的编程语言来说，干同一个活，编写的代码量，差距也很大。</p><p>通常情况下，在完成同一种功能时，越高级的语言所需要的代码越少。可能完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。 但是代码少的代价是运行速度慢，C程序运行1秒钟，Java程序可能需要2秒，而Python程序可能就需要10秒。 </p><h4 id="4-1-2、Python语言的优点"><a href="#4-1-2、Python语言的优点" class="headerlink" title="4.1.2、Python语言的优点"></a>4.1.2、Python语言的优点</h4><p>1、<strong>语法简单</strong>：Python是一种代表简单主义思想的语言，也是一种高级语言，不用考虑底层细节</p><p>2、<strong>易学</strong>：这点其实前面已经提到，python非常容易上手，类比于C语言来说有着极其简单的语法</p><p>3、<strong>免费、开源</strong>：Python是开放源代码的，你可以自由发布这个软件的拷贝、阅读源码、在它的基础上做改动</p><p>4、<strong>可移植性</strong>：由于Python开源的本质，它的代码不用修改就可以在多平台上运行</p><p>5、<strong>丰富的库</strong>：Python有众多的标准库与第三方库，它可以帮你处理各种各样的工作。</p><h4 id="4-1-3、Python可以干什么"><a href="#4-1-3、Python可以干什么" class="headerlink" title="4.1.3、Python可以干什么"></a>4.1.3、Python可以干什么</h4><p>1、<strong>web开发</strong>：做服务器端编程，Python在这方面有非常常熟的web开发框架，如 Django和Flask。国内外有很多知名的网站都是使用Python进行开发，比如：豆瓣 、NASA、YouTube、 Quora等等</p><p><img src="https://i.loli.net/2019/12/25/upe36RkTMj5ZEbB.png" alt="1577154510758.png"></p><p>2、<strong>系统网络运维、软件测试</strong>：在运维工作中，有大量的重复性工作，并需要管理、监控、发布系统等，可以使用Python将工作自动化，提高工作效率。</p><p><img src="https://i.loli.net/2019/12/25/4jVysdCN3Znfwgu.png" alt="1577154561956.png"></p><p><img src="https://i.loli.net/2019/12/25/dPiaH1IyZf5Vt2w.png" alt="1577154641884.png"></p><p>3、<strong>爬虫</strong><a href="https://www.baidu.com/link?url=DALeI_e5JmO7yg7yBBNHQmjRI0IFSaz7N-A4YnYN8f30JMUV2M0HAk3AVBr37jhCqY-x4kERVlvmrT7dHq15xeSOIUjNOQdjQN6LrfeVqHL08aVm_TFvwdRGhMuy_EmM&wd=&eqid=92850b150000a597000000045e01b589" target="_blank" rel="noopener">百度蜘蛛</a>：在爬虫领域，Python的地位无人撼动，将网络一切数据作为资源，通过自动化程序进行针对性的数据采集和处理。</p><p><img src="https://i.loli.net/2019/12/25/MkIi4yXPL1C8zcs.png" alt="1577154701107.png"></p><p>4、<strong>数据分析</strong>：Python被广泛的应用到科学与数据分析中，比如图像可视化、数值计算等等，常用的包有Numpy、Pandas等</p><p><img src="https://i.loli.net/2019/12/25/z39Hwq2unrFjlT6.png" alt="1577154956814.png"></p><p>5、<strong>人工智能&amp;机器学习</strong>：因为google等公司早期大量使用Python，为Python积累了丰富的科学运算库，所以当AI时代来临后，Python从众多编程语言中脱颖而出，现在各种人工只能算法都基于Python编写，Python作为AI时代头牌编程语言的位置基本确定   </p><p><img src="https://i.loli.net/2019/12/25/8Td6W13FyLthIBu.png" alt="1577155025423.png"></p><h3 id="4-2、为什么要学习Python"><a href="#4-2、为什么要学习Python" class="headerlink" title="4.2、为什么要学习Python"></a>4.2、为什么要学习Python</h3><p>上段时间有个新闻比较火：</p><p><img src="https://i.loli.net/2019/12/25/9VAsoIeZJWD6hUq.png" alt="1577169441328.png"><br><img src="https://i.loli.net/2019/12/25/VCdoDkqv94rx7Su.png" alt="1577169497916.png"></p><p>潘总是做房地产的，尤其是商业地产，收集/分析/预测市场数据/竞争对手数据太重要了，所以我猜测潘总是用Python做爬虫+数据分析+AI预测，这样SOHO中国就变成了地产科技公司，一下子和其他地产公司拉开了档次，不仅可以吸（ hū ）引（  yōu ）投资人，公司估值也会上一个台阶😎。</p><p>回归正题，通过上面的了解其实大家也大体能够明白学习Python的好处。</p><p>从普通工作的角度上来说，Python可以实现一些办公自动化操作（自动处理Excel、自动收发邮件、批量给图片加水印等等）。</p><p><a href="https://www.zhihu.com/question/313671299/answer/613206743" target="_blank" rel="noopener">用 Python <em>自动化办公</em>能做到哪些有趣或有用的事情？</a></p><p>对于数据分析师的岗位而言，Python是一个<strong>功能强大的工具</strong>，可以快速的处理数据并进行可视化。</p><p><a href="https://zhuanlan.zhihu.com/p/21799170" target="_blank" rel="noopener">零基础学习<em>Python数据分析</em></a></p><p>展望未来，人工智能正在迅速改变我们周围的一切，而Python提供了很多开箱即用的算法，让普通人也可以通过简单的学习做出一些人工智能的小应用</p><p><a href="https://www.zhihu.com/question/51920544/answer/934308870" target="_blank" rel="noopener">有没有简单一点的 Python 小例子或小项目？</a></p><p>最后，伟大的哲学家鲁迅说过：</p><p><img src="https://i.loli.net/2019/12/25/yHguxDOsLwjUkaX.png" alt="1577109404723.png"></p><h3 id="4-3、Jupyter-Notebook入门"><a href="#4-3、Jupyter-Notebook入门" class="headerlink" title="4.3、Jupyter Notebook入门"></a>4.3、Jupyter Notebook入门</h3><p> Jupyter Notebook 是一个在浏览器中使用的交互式的笔记本，可以实现将代码、文字完美结合起来，它的受众群体大多数是一些从事数据科学领域相关（机器学习、数据分析等）的人员。这里会告诉大家Jupyter Notebook入门时常用功能用法。 </p><h4 id="1）新建Notebook"><a href="#1）新建Notebook" class="headerlink" title="1）新建Notebook"></a>1）新建Notebook</h4><p>打开的界面主要包含了以上的几个菜单，我们点击<code>New</code>-<code>Python3</code>来创建一个Python3的.ipynb文件。</p><p>每一个Notebook主要包含三个区域：文件名菜单栏（工具栏）、内容编辑<img src="https://i.loli.net/2019/12/25/ECDjoJUTWYV692f.png" alt="1577153207427.png"></p><h4 id="2）修改文件名"><a href="#2）修改文件名" class="headerlink" title="2）修改文件名"></a>2）修改文件名</h4><p>直接点击文件名，可以重命名当前Notebook的文件名，这里修改为“demo”。</p><h4 id="3）熟悉菜单栏"><a href="#3）熟悉菜单栏" class="headerlink" title="3）熟悉菜单栏"></a>3）熟悉菜单栏</h4><p>这里介绍下常用的几个菜单栏的作用。</p><p><strong>File</strong></p><p>File 菜单中主要包含了以下功能：创建新的Notebook、打开新的界面、拷贝当前Notebook、重命名Notebook、保存还原点、恢复到指定还原点、查看Notebook预览、下载Notebook、关闭Notebook。</p><p>这里重点强调下<strong>下载Notebook</strong>选项，它可以将当前Notebook转为py文件、html文件、markdown文件、rest文件、latex文件、pdf文件。</p><p><img src="https://i.loli.net/2019/12/25/tQ2Pdpe8NhjK4sT.png" alt="1577153254992.png"></p><p><strong>Insert</strong></p><p>Insert 菜单中包含了在当前位置之下插入一个新的cell（单元格）、在当前位置之上插入一个新的cell（单元格）。</p><p><img src="https://i.loli.net/2019/12/25/pFPjB5LuWIJkYdz.png" alt="1577153283482.png"></p><p><strong>Cell</strong></p><p>Cell 菜单主要包含了运行cells、运行cells后并在之后插入新的cell、运行所有cells、运行当前之上的所有cell、运行当前之下的所有cell、改变cell类型（<strong>code</strong>、<strong>markdown</strong>、raw nbconvert）等。</p><p><img src="https://i.loli.net/2019/12/25/fEdtAa9usvbrHBW.png" alt="1577153334130.png"></p><p><strong>Kernel</strong></p><p>Kernel 菜单主要包含了中断kernel、重启kernel、重启kernel并清除输出、重启kernel并运行所有cell、重连kernel、关闭kernel、改变kernel类型。</p><p><img src="https://i.loli.net/2019/12/25/1xv6ojLgankbHZF.png" alt="1577153356024.png"></p><p><strong>Help</strong></p><p>Help 菜单主要包含了用户交互引导、键盘快捷键、修改键盘快捷键、Notebook帮助、Markdown帮助、Jupyter-notebook-extensions帮助、Python帮助、IPython帮助、Numpy帮助、Scipy帮助、Matplotlib帮助、Sympy帮助、pandas帮助等。</p><p><img src="https://i.loli.net/2019/12/25/EmKfqFIw9QeoWnv.png" alt="1577153384863.png"></p><p>如果能记住一些常用的快捷键，对使用Jupyter Notebook帮助还是很大的。</p><p><img src="https://i.loli.net/2019/12/25/oXj52HDq8adueLh.png" alt="1577155989202.png"></p><h4 id="4）熟悉工具栏"><a href="#4）熟悉工具栏" class="headerlink" title="4）熟悉工具栏"></a>4）熟悉工具栏</h4><p>工具栏上的内容都在下图中：</p><p>依次来介绍下，保存还原点、在当前位置之下添加cell、剪切当前cell、拷贝选择的cell、复制选择的cell、上移选中的cell、下移选中的cell、运行cell、中断kernel、重启kernel、修改cell类型、打开命令行调色板、美化cell代码。</p><p>很明显，工具栏中的功能大多都是菜单栏中的一部分功能的体现，主要是为了方便寻找。</p><h4 id="5）运行Python代码"><a href="#5）运行Python代码" class="headerlink" title="5）运行Python代码"></a>5）运行Python代码</h4><p>想要运行Python代码，其实很简单，因为Python代码最后都在 Cell 中编写的。首先在cell中编写好Python代码，然后点击运行，可以直接在下面看到结果。</p><p><img src="https://i.loli.net/2019/12/25/59SJRZucniflXgT.png" alt="1577153518545.png"></p><p>仔细一点，我们可以发现，第一个cell前面有 “In [1]:”提示符，第二个cell前面有“In[2]:”提示符，同时也有“Out[2]:”输出符，这是因为如果没有print语句的话，Notebook会将当前cell的最后一条语句的结果以“Out[?]:”的方式输出。</p><h4 id="6）编写Markdown"><a href="#6）编写Markdown" class="headerlink" title="6）编写Markdown"></a>6）编写Markdown</h4><p>Notebook最友好的一个功能就是可以在cell中通过Markdown来编写文本。我们首先创建一个cell，然后更改类型为markdown，更改成功后，cell开头没有“In[?]:”的提示符。然后点击cell，按照markdown语法来输入文本。</p><p>除了对markdown语法的支持外，同时也支持html代码，此外，也支持latex公式语法。</p><p>使用latex公式时，如果需要在当前行内插入公式，公式前后分别需要一个<code>$</code>，如果需要在下一行单独插入公式，公式前后分别需要两个<code>$</code>。</p><h3 id="4-4、Markdown的书写方法"><a href="#4-4、Markdown的书写方法" class="headerlink" title="4.4、Markdown的书写方法"></a>4.4、Markdown的书写方法</h3><h4 id="4-4-1、Markdown简介"><a href="#4-4-1、Markdown简介" class="headerlink" title="4.4.1、Markdown简介"></a>4.4.1、Markdown简介</h4><p>上面提到了Markdown，在这里稍微介绍一下。</p><ul><li>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 </li><li>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。 </li></ul><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p><p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书等。很多在线文档编辑软件（腾讯文档、石墨文档、阿里开源的雨雀等等）也都对Markdown有着很好的支持。很多互联网公司也慢慢开始直接使用Markdown来撰写需求文档与演示文稿，大部分程序员都使用Markdown进行文章、博客的写作。大家现在看到的pdf也是我使用Markdown写的。</p><p><strong>优点：</strong><br> 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p><p><strong>缺点：</strong><br> 1、需要记一些语法（当然，是很简单。五分钟学会）。<br> 2、有些平台不支持Markdown编辑模式。</p><h4 id="4-4-2、Markdown语法"><a href="#4-4-2、Markdown语法" class="headerlink" title="4.4.2、Markdown语法"></a>4.4.2、Markdown语法</h4><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 这是一级标题</span><span class="token title important"><span class="token punctuation">##</span> 这是二级标题</span><span class="token title important"><span class="token punctuation">###</span> 这是三级标题</span><span class="token title important"><span class="token punctuation">####</span> 这是四级标题</span><span class="token title important"><span class="token punctuation">#####</span> 这是五级标题</span><span class="token title important"><span class="token punctuation">######</span> 这是六级标题</span></code></pre><p>效果如下：</p><p><img src="https://i.loli.net/2019/12/25/w3ZxEjHJ5lB9auF.png" alt="1577158953996.png"></p><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><ul><li><strong>加粗</strong></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><strong>斜体</strong></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><strong>斜体加粗</strong></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><strong>删除线</strong></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><pre class=" language-markdown"><code class="language-markdown"><span class="token bold"><span class="token punctuation">**</span>这是加粗的文字<span class="token punctuation">**</span></span><span class="token italic"><span class="token punctuation">*</span>这是倾斜的文字<span class="token punctuation">*</span></span>`<span class="token bold"><span class="token punctuation">**</span>*这是斜体加粗的文字<span class="token punctuation">**</span></span>*~~这是加删除线的文字~~</code></pre><p>效果如下：</p><p><img src="https://i.loli.net/2019/12/25/WoyKFQlZvtg4pU2.png" alt="1577159140514.png"></p><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p> 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p><pre class=" language-markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> 这里是引用内容<span class="token blockquote punctuation">>></span> 这里是引用内容</code></pre><p>效果如下：</p><p><img src="https://i.loli.net/2019/12/25/BzSDXRd5T2Ne7lU.png" alt="1577159370249.png"></p><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><pre class=" language-markdown"><code class="language-markdown">![图片名称](图片地址 ''图片title'')图片名称就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>效果如下：</p><p><img src="https://i.loli.net/2019/12/25/J3bYQhkWgnxyeBa.jpg" alt="1576203195960bcae2e5cd2fbba0d11e974dd0e8d3.jpg"></p><h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><pre class=" language-markdown"><code class="language-markdown"><span class="token url">[超链接名](超链接地址 <span class="token string">"超链接title"</span>)</span>title可加可不加</code></pre><p>效果如下：</p><p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener"> Markdown 教程</a></p><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>1、<strong>无序列表</strong></p><pre class=" language-markdown"><code class="language-markdown"><span class="token list punctuation">-</span> 列表内容<span class="token list punctuation">+</span> 列表内容<span class="token list punctuation">*</span> 列表内容注意：- + * 跟内容之间都要有一个空格</code></pre><p>效果如下：</p><ul><li>列表</li></ul><p><strong>2、有序列表</strong></p><pre class=" language-markdown"><code class="language-markdown">1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格</code></pre><p> 效果如下： </p><ol><li>有序列表</li><li>有序列表</li></ol><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><pre class=" language-markdown"><code class="language-markdown">|表头|表头|表头||---|:--:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。<span class="token list punctuation">-</span> 有一个就行，为了对齐，多加了几个文字默认居左<span class="token list punctuation">-</span> 两边加 ：表示文字居中<span class="token list punctuation">-</span> 右边加 ：表示文字居右</code></pre><p> 效果如下： </p><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class=" language-markdown"><code class="language-markdown">​```  代码...  代码...  代码...​```</code></pre><p> 效果如下： </p><pre class=" language-mysql"><code class="language-mysql">select * from dual</code></pre><h5 id="Markdown写作工具推荐"><a href="#Markdown写作工具推荐" class="headerlink" title="Markdown写作工具推荐"></a>Markdown写作工具推荐</h5><p>一个所见即所得的免费Markdown写作神器:<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><h3 id="4-5、解决问题的通用方法-amp-书籍推荐"><a href="#4-5、解决问题的通用方法-amp-书籍推荐" class="headerlink" title="4.5、解决问题的通用方法&amp;书籍推荐"></a>4.5、解决问题的通用方法&amp;书籍推荐</h3><h4 id="4-5-1、“面向搜索引擎编程“"><a href="#4-5-1、“面向搜索引擎编程“" class="headerlink" title="4.5.1、“面向搜索引擎编程“"></a>4.5.1、“面向搜索引擎编程“</h4><p>大家在开始尝试写代码的时候总会遇到各种各样的问题，其中一部分包含程序的错误，对于这方面问题，我更倾向于通过搜索引擎找到答案。Python生态环境十分良好，初学者遇到的99.9%的问题在网上都有现成的解决办法。如果是思路上的问题同样可以通过网络进行查找，也可以寻求他人的帮助。</p><p>另外，在我们的学习过程中，刚开始我们知道怎么用就行了，理解原理固然更好，<strong>但千万不要钻牛角尖</strong>。对数据分析岗位来说，主要是要能了解工具的具体功能，当有需求、有想法时可以知道使用哪种工具可以更好更快的实现。</p><p>最后，如果在工作中，上网复制一段代码，理解后为我所用，这个是可以的，毕竟我们要保证生产力。但我们在刚开始学习的过程中，尽量不要去复制代码，学习编程最大的技巧就是<strong>多敲代码</strong>，敲的这个过程中，会出错，出错了就会去调试，调试的过程中会去思考，在调试和<strong>思考</strong>的过程中就是在不知不觉的进步。</p><h4 id="4-5-2、书籍推荐"><a href="#4-5-2、书籍推荐" class="headerlink" title="4.5.2、书籍推荐"></a>4.5.2、书籍推荐</h4><p>网络上Python的教学课程、书籍、公众号众多，大家可以自行寻找，这里只推荐两本书籍，如果有需要其他的学习资料，也可以直接找我要。</p><p>入门书籍：<a href="https://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="noopener">简明Python教程</a></p><p>数据分析书籍：<a href="https://book.douban.com/subject/30283996/" target="_blank" rel="noopener">利用Python进行数据分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你安装Anaconda3</title>
      <link href="/2019/12/25/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%89%E8%A3%85Anaconda3/"/>
      <url>/2019/12/25/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%89%E8%A3%85Anaconda3/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda3安装过程"><a href="#Anaconda3安装过程" class="headerlink" title="Anaconda3安装过程"></a>Anaconda3安装过程</h1><h2 id="一、Windows版本"><a href="#一、Windows版本" class="headerlink" title="一、Windows版本"></a>一、Windows版本</h2><h3 id="1-1、安装"><a href="#1-1、安装" class="headerlink" title="1.1、安装"></a>1.1、安装</h3><p><code>Anaconda</code>是一个开源的<code>Python</code>发行版本，<strong>包含了180多个科学报以及依赖</strong>，安装后可直接使用它自带的<code>jupyter notebook</code>进行代码编写，以下记录了安装的全过程，<strong>建议大家参照我的步骤安装</strong>。</p><p><img src="https://i.loli.net/2019/12/25/oyspGcCYDMikR1N.png" alt></p><p>点击<code>next</code></p><p><img src="https://i.loli.net/2019/12/25/Cv53qr7LwZg9oFe.png" alt></p><p>点击 <code>I Agree</code></p><p><img src="https://i.loli.net/2019/12/25/uaQNJD9vWVP2n1G.png" alt></p><p><strong>注意</strong>：如果系统只有一个用户选择第一个即可，如果有多个用户选第二个，==一般来说选择第一个==，然后点击<code>next</code>。</p><p><img src="https://i.loli.net/2019/12/25/QJeE3bt7TklxC8S.png" alt></p><p>为了避免之后不必要的麻烦，建议==直接使用默认路径安装==，大概占用3G空间。如果空间不够，再选择其他路径，路径中==尽量不要包含中文==，然后点击<code>next</code>。</p><p><img src="https://i.loli.net/2019/12/25/IowF6k5UNMq3Dh7.png" alt></p><p>将<code>add Anaconda to PATH environment variable</code><strong>选中</strong>，然后点击<code>next</code>，等待安装完成即可。</p><p>安装完成后显示上图点击<code>next</code>。</p><p><img src="https://i.loli.net/2019/12/25/OnWQ5APzL4kT8iH.png" alt></p><p>点击<code>next</code></p><p><img src="https://i.loli.net/2019/12/25/WLrKlnpA2d8ZyYV.png" alt></p><p>取消上图两个勾选，点击<code>finish</code>，安装完成。</p><h3 id="1-2、验证"><a href="#1-2、验证" class="headerlink" title="1.2、验证"></a>1.2、验证</h3><p>安装好之后，点击开始，可以查看到已经安装好的目录</p><p><img src="https://i.loli.net/2019/12/25/FEXYclgZLiO9DMx.png" alt></p><p>双击<img src="https://i.loli.net/2019/12/25/lByuaScALfjC13O.png" alt>)，会显示黑窗口<img src="https://i.loli.net/2019/12/25/7KpCYrkW3NhuUix.png" alt></p><p>然后会自动唤醒你的浏览器，打开<code>jupyter notebook</code>的根目录</p><p><img src="https://i.loli.net/2019/12/25/Q7mfZIcTnW64V5M.png" alt></p><p>点击左上角的<code>new</code>,然后点击<code>Python3</code></p><p><img src="https://i.loli.net/2019/12/25/vErGqeJc7mB5F9z.png" alt></p><p>点击后即可进入以下界面：<img src="https://i.loli.net/2019/12/25/KZgF3zVfRirlbQ9.png" alt></p><p>在上图方框中编写你的第一行<code>Python</code>代码，然后按<code>shift</code>+<code>enter</code>运行</p><p><img src="https://i.loli.net/2019/12/25/SsKz1tdT9JPpjf5.png" alt></p><h3 id="1-3、优化"><a href="#1-3、优化" class="headerlink" title="1.3、优化"></a>1.3、优化</h3><p>大家会发现，默认启动<code>jupyter notebook</code>会出现很多无关的文件，这里通过简单的配置，让大家可以从==指定位置==启动工作台。</p><p>首先大家可以在任意目录下创建一个文件夹，名称可以自己设定，主要用来存放以后所有的代码，文件夹路径==尽量不要出现中文==，下面以我自己的<code>D:\Python_note</code>为例</p><p>win+R调出控制台，输入cmd,点击确定</p><p><img src="https://i.loli.net/2019/12/25/wDqnSPmutdi8zlj.png" alt></p><p><img src="https://i.loli.net/2019/12/25/Eq9iWhPuSs4QADt.png" alt></p><p>在命令行中输入</p><pre class=" language-nginx"><code class="language-nginx">jupyter notebook <span class="token operator">--</span>generate<span class="token operator">-</span>config</code></pre><p><img src="https://i.loli.net/2019/12/25/dTe7QDzCjLKUZ4V.png" alt></p><p>复制红圈中的路径到<code>Windows</code>的资源管理器中并使用记事本打开,找到下面这一行：</p><p><img src="https://i.loli.net/2019/12/25/JFSNhpGZEiWQ8YK.png" alt="image-20191223164741600.png"></p><p>大家的显示样式可能和我不一样，可以忽略，只要改文字即可。将开头的<code>#</code>删掉，将路径填写进去,如下所示：</p><p><img src="https://i.loli.net/2019/12/25/aRfzrH3mcbIDU6e.png" alt="image-20191223164945795.png"></p><p>修改完成后保存退出，然后重新启动<code>jupyter notebook</code>，即可从指定目录启动。</p><p><img src="https://i.loli.net/2019/12/25/THudKFoh8QrCg4q.png" alt="image-20191223170024946"></p><p>如果通过以上修改后==可以启动但配置无效==，通过以下办法解决：</p><p>在开始菜单中右击更多-打开文件位置</p><p><img src="https://i.loli.net/2019/12/25/bntrR9zfgqUSKHL.png" alt="image-20191223170206904"></p><p>将<code>jupyter notebook</code>发送到桌面快捷方式</p><p>右键选择<code>属性</code>，将<code>&quot;%USERPROFILE&quot;</code>删除，然后点==应用==，</p><p><img src="https://i.loli.net/2019/12/25/n9poNARGXWs5PqD.png" alt="image-20191223170625932"></p><p>关闭窗口双击快捷方式打开<code>jupyter notebook</code>，问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN-2-使用python实现完整的KNN算法</title>
      <link href="/2019/12/25/KNN-2-%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E7%9A%84KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/25/KNN-2-%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E7%9A%84KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Python完成一个完整的KNN算法"><a href="#使用Python完成一个完整的KNN算法" class="headerlink" title="使用Python完成一个完整的KNN算法"></a>使用Python完成一个完整的KNN算法</h1><p>本篇文章使用python模拟实现一个简单的KNN算法，并且引入一些机器学习的基本概念。</p><h2 id="1、数据准备"><a href="#1、数据准备" class="headerlink" title="1、数据准备"></a>1、数据准备</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> font_manager<span class="token operator">%</span> matplotlib inline</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># raw_data_x是特征，raw_data_y是标签，0为良性，1为恶性</span>raw_data_X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3.393533211</span><span class="token punctuation">,</span> <span class="token number">2.331273381</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">3.110073483</span><span class="token punctuation">,</span> <span class="token number">1.781539638</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">1.343853454</span><span class="token punctuation">,</span> <span class="token number">3.368312451</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">3.582294121</span><span class="token punctuation">,</span> <span class="token number">4.679917921</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">2.280362211</span><span class="token punctuation">,</span> <span class="token number">2.866990212</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">7.423436752</span><span class="token punctuation">,</span> <span class="token number">4.685324231</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">5.745231231</span><span class="token punctuation">,</span> <span class="token number">3.532131321</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">9.172112222</span><span class="token punctuation">,</span> <span class="token number">2.511113104</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">7.927841231</span><span class="token punctuation">,</span> <span class="token number">3.421455345</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">7.939831414</span><span class="token punctuation">,</span> <span class="token number">0.791631213</span><span class="token punctuation">]</span>             <span class="token punctuation">]</span>raw_data_y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span></code></pre><h2 id="2、设置训练组"><a href="#2、设置训练组" class="headerlink" title="2、设置训练组"></a>2、设置训练组</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设置训练组</span>X_train <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>raw_data_X<span class="token punctuation">)</span>y_train <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>raw_data_y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>y_train<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(y_train.flatten())</span>my_font <span class="token operator">=</span> font_manager<span class="token punctuation">.</span>FontProperties<span class="token punctuation">(</span>fname<span class="token operator">=</span><span class="token string">'C:/Windows/Fonts/simsun.ttc'</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将数据可视化</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X_train<span class="token punctuation">[</span>y_train<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_train<span class="token punctuation">[</span>y_train<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span> label <span class="token operator">=</span> <span class="token string">'良性'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X_train<span class="token punctuation">[</span>y_train<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X_train<span class="token punctuation">[</span>y_train<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> label <span class="token operator">=</span> <span class="token string">'恶性'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token number">8.90933607318</span><span class="token punctuation">,</span><span class="token number">3.365731514</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Tumor Size'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Time'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">,</span>            xy<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">8.90933607318</span><span class="token punctuation">,</span><span class="token number">3.365731514</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xycoords<span class="token operator">=</span><span class="token string">'data'</span><span class="token punctuation">,</span>            xytext<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> textcoords<span class="token operator">=</span><span class="token string">'data'</span><span class="token punctuation">,</span>            arrowprops<span class="token operator">=</span>dict<span class="token punctuation">(</span>arrowstyle<span class="token operator">=</span><span class="token string">"->"</span><span class="token punctuation">,</span>                            connectionstyle<span class="token operator">=</span><span class="token string">"arc3"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc <span class="token operator">=</span><span class="token string">"best"</span><span class="token punctuation">,</span>prop<span class="token operator">=</span>my_font<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>(10, 2)(10,)</code></pre><p><img src="https://i.loli.net/2019/12/25/fQHJnFCVlM4LOvq.png" alt></p><h2 id="3、分类"><a href="#3、分类" class="headerlink" title="3、分类"></a>3、分类</h2><p>那么现在给出一个肿瘤患者的数据（样本点）x：[8.90933607318, 3.365731514]，是良性肿瘤还是恶性肿瘤</p><h3 id="3-1、求距离"><a href="#3-1、求距离" class="headerlink" title="3.1、求距离"></a>3.1、求距离</h3><p>我们要做的是：求点x到数据集中每个点的距离，首先计算距离，使用欧氏距离</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> math <span class="token keyword">import</span> sqrtx<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">8.90933607318</span><span class="token punctuation">,</span> <span class="token number">3.365731514</span><span class="token punctuation">]</span>distances <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 用来记录x到样本数据集中每个点的距离</span><span class="token keyword">for</span> x_train <span class="token keyword">in</span> X_train<span class="token punctuation">:</span>    d <span class="token operator">=</span> sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">(</span>x_train <span class="token operator">-</span> x<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    distances<span class="token punctuation">.</span>append<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用列表生成器，一行就能搞定，对于X_train中的每一个元素x_train都进行前面的运算，</span><span class="token comment" spellcheck="true"># 把结果生成一个列表</span>distances <span class="token operator">=</span> <span class="token punctuation">[</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">(</span>x_train <span class="token operator">-</span> x<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x_train <span class="token keyword">in</span> X_train<span class="token punctuation">]</span>distances</code></pre><pre><code>输出：[5.611968000921151, 6.011747706769277, 7.565483059418645, 5.486753308891268, 6.647709180746875, 1.9872648870854204, 3.168477291709152, 0.8941051007010301, 0.9830754144862234, 2.7506238644678445]</code></pre><h3 id="3-2、对距离排序"><a href="#3-2、对距离排序" class="headerlink" title="3.2、对距离排序"></a>3.2、对距离排序</h3><p>在求出距离列表之后，我们要找到最小的距离，需要进行一次<code>排序操作</code>。其实不是简单的排序，因为我们把只将距离排大小是没有意义的，我们要知道距离最小的k个点是在样本集中的位置。</p><p>这里我们使用函数：<code>np.argsort(array)</code> 对一个数组进行排序，返回的是相应的排序后结果的索引</p><pre class=" language-python"><code class="language-python">nearest <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>distances<span class="token punctuation">)</span>nearest<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span></code></pre><pre><code>输出：array([7, 8, 5, 9, 6, 3], dtype=int64)</code></pre><p>然后我们选择k值，这里暂定为6，那就找出最近的6个点（top 6），并记录他们的标签值（y）</p><pre class=" language-python"><code class="language-python">k <span class="token operator">=</span> <span class="token number">6</span>topK_y <span class="token operator">=</span> <span class="token punctuation">[</span>y_train<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> nearest<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span>topK_y</code></pre><pre><code>输出：[1, 1, 1, 1, 1, 0]</code></pre><h3 id="3-3、决策规则"><a href="#3-3、决策规则" class="headerlink" title="3.3、决策规则"></a>3.3、决策规则</h3><p>下面进入投票环节。找到与测试样本点最近的6个训练样本点的标签y是什么。可以查不同类别的点有多少个。</p><p>将数组中的元素和元素出现的频次进行统计</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> Countervotes <span class="token operator">=</span> Counter<span class="token punctuation">(</span>topK_y<span class="token punctuation">)</span>votes</code></pre><pre><code>输出：Counter({1: 5, 0: 1})</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Counter.most_common(n) </span><span class="token comment" spellcheck="true"># 找出票数最多的n个元素，返回的是一个列表，</span><span class="token comment" spellcheck="true"># 列表中的每个元素是一个元组，元组中第一个元素是对应的元素是谁</span>predict_y <span class="token operator">=</span> votes<span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>predict_y</code></pre><pre><code>输出：1</code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">%</span><span class="token operator">%</span>writefile kNN<span class="token punctuation">.</span>py<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> math <span class="token keyword">as</span> sqrt<span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token keyword">class</span> <span class="token class-name">kNNClassifier</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化分类器"""</span>        <span class="token keyword">assert</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"k must be valid"</span>        self<span class="token punctuation">.</span>k <span class="token operator">=</span> k        self<span class="token punctuation">.</span>_X_train <span class="token operator">=</span> None        self<span class="token punctuation">.</span>_y_train <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""根据训练数据集X_train和y_train训练kNN分类器"""</span>        <span class="token keyword">assert</span> X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> y_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token string">"the size of X_train must be equal to the size of y_train"</span>        <span class="token keyword">assert</span> self<span class="token punctuation">.</span>k <span class="token operator">&lt;=</span> X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token string">"the size of X_train must be at least k"</span>        self<span class="token punctuation">.</span>_X_train <span class="token operator">=</span> X_train        self<span class="token punctuation">.</span>_y_train <span class="token operator">=</span> y_train                <span class="token keyword">return</span> self        <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""给定待预测数据集X_predict，返回表示X_predict结果的向量"""</span>        <span class="token keyword">assert</span> self<span class="token punctuation">.</span>_X_train <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> self<span class="token punctuation">.</span>_y_train <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">,</span>            <span class="token string">"must fit before predict!"</span>        <span class="token keyword">assert</span> X_predict<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>_X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token string">"the feature number of X_predict must be equal to X_train"</span>        y_predict <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_predict<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> X_predict<span class="token punctuation">]</span>                <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>y_predict<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        distances <span class="token operator">=</span> <span class="token punctuation">[</span>sqrt<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">(</span>x_train <span class="token operator">-</span> x<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x_train <span class="token keyword">in</span> self<span class="token punctuation">.</span>_X_train<span class="token punctuation">]</span>        nearest <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>distances<span class="token punctuation">)</span>        topK_y <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_y_train<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> nearest<span class="token punctuation">]</span>        votes <span class="token operator">=</span> Counter<span class="token punctuation">(</span>topK_y<span class="token punctuation">)</span>                <span class="token keyword">return</span> votes<span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"kNN(k=%d)"</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>k</code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">%</span>run kNN<span class="token punctuation">.</span>pyknn_clf <span class="token operator">=</span> kNNClassifier<span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span>knn_clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>x<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">8.90933607318</span><span class="token punctuation">,</span> <span class="token number">3.365731514</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(x.reshape(1,-1))</span>X_predict <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>y_predict <span class="token operator">=</span> knn_clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_predict<span class="token punctuation">)</span>y_predict<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><pre><code>输出：1</code></pre><h2 id="4、在sklearn中使用KNN"><a href="#4、在sklearn中使用KNN" class="headerlink" title="4、在sklearn中使用KNN"></a>4、在sklearn中使用KNN</h2><p>对于机器学习来说，其流程是：训练数据集 -&gt; 机器学习算法 -fit-&gt; 模型 输入样例 -&gt; 模型 -predict-&gt; 输出结果</p><p>我们之前说过，kNN算法没有模型，模型其实就是训练数据集，predict的过程就是求k近邻的过程。</p><p>我们使用sklearn中已经封装好的kNN库。你可以看到使用有多么简单。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier<span class="token comment" spellcheck="true"># 创建kNN_classifier实例</span>kNN_classifier <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># kNN_classifier做一遍fit(拟合)的过程，没有返回值，</span><span class="token comment" spellcheck="true"># 模型就存储在kNN_classifier实例中</span>a <span class="token operator">=</span> kNN_classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># kNN进行预测predict，需要传入一个矩阵，而不能是一个数组。reshape()成一个二维数组，第一个参数是1表示只有一个数据，第二个参数-1，numpy自动决定第二维度有多少</span>y_predict <span class="token operator">=</span> a<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y_predict</code></pre><pre><code>KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=6, p=2,           weights=&#39;uniform&#39;)array([1])</code></pre><p>在<code>kNN_classifier.fit(X_train, y_train)</code>这行代码后其实会有一个输出：</p><pre class=" language-python"><code class="language-python">KNeighborsClassifier<span class="token punctuation">(</span>algorithm<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> leaf_size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">'minkowski'</span><span class="token punctuation">,</span>           metric_params<span class="token operator">=</span>None<span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> n_neighbors<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>           weights<span class="token operator">=</span><span class="token string">'uniform'</span><span class="token punctuation">)</span></code></pre><pre><code>KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=6, p=2,           weights=&#39;uniform&#39;)</code></pre><p>参数：</p><p>class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)</p><p>我们研究一下参数：</p><ul><li><p><code>n_neighbors</code>: int, 可选参数(默认为 5)。用于kneighbors查询的默认邻居的数量</p></li><li><p><code>weights（权重）</code>: str or callable(自定义类型), 可选参数(默认为 ‘uniform’)。用于预测的权重参数，可选参数如下：</p><ul><li><p><code>uniform</code> : 统一的权重. 在每一个邻居区域里的点的权重都是一样的。</p></li><li><p><code>distance</code> : 权重点等于他们距离的倒数。</p><p>使用此函数，更近的邻居对于所预测的点的影响更大。</p></li><li><p><code>[callable]</code> : 一个用户自定义的方法，此方法接收一个距离的数组，然后返回一个相同形状并且包含权重的数组。</p></li></ul></li><li><p>algorithm（算法）: {‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, 可选参数（默认为 ‘auto’）。计算最近邻居用的算法：</p><ul><li><p><code>ball_tree</code> 使用算法BallTree</p></li><li><p><code>kd_tree</code> 使用算法KDTree</p></li><li><p><code>brute</code> 使用暴力搜索</p></li><li><p><code>auto</code> 会基于传入fit方法的内容，选择最合适的算法。</p></li></ul></li></ul><p>注意 : 如果传入fit方法的输入是稀疏的，将会重载参数设置，直接使用暴力搜索。</p><ul><li><p><code>leaf_size（叶子数量）</code>: int, 可选参数(默认为 30)。传入BallTree或者KDTree算法的叶子数量。此参数会影响构建、查询BallTree或者KDTree的速度，以及存储BallTree或者KDTree所需要的内存大小。此可选参数根据是否是问题所需选择性使用。</p></li><li><p><code>p</code>: integer, 可选参数(默认为 2)。用于Minkowski metric（闵可夫斯基空间）的超参数。p = 1, 相当于使用曼哈顿距离，p = 2, 相当于使用欧几里得距离]，对于任何 p ，使用的是闵可夫斯基空间。</p></li><li><p><code>metric（矩阵）</code>: string or callable, 默认为 ‘minkowski’。用于树的距离矩阵。默认为闵可夫斯基空间，如果和p=2一块使用相当于使用标准欧几里得矩阵. 所有可用的矩阵列表请查询 DistanceMetric 的文档。</p></li><li><p><code>metric_params（矩阵参数）</code>: dict, 可选参数(默认为 None)。给矩阵方法使用的其他的关键词参数。</p></li><li><p><code>n_jobs</code>: int, 可选参数(默认为 1)。用于搜索邻居的，可并行运行的任务数量。如果为-1, 任务数量设置为CPU核的数量。不会影响fit</p></li></ul><p>对于<code>KNeighborsClassifier</code>的方法：</p><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>fit(X, y)</td><td>使用X作为训练数据，y作为目标值（类似于标签）来拟合模型。</td></tr><tr><td>get_params([deep])</td><td>获取估值器的参数。</td></tr><tr><td>neighbors([X, n_neighbors, return_distance])</td><td>查找一个或几个点的K个邻居。</td></tr><tr><td>kneighbors_graph([X, n_neighbors, mode])</td><td>计算在X数组中每个点的k邻居的（权重）图。</td></tr><tr><td>predict(X)</td><td>给提供的数据预测对应的标签。</td></tr><tr><td>predict_proba(X)</td><td>返回测试数据X的概率估值</td></tr><tr><td>score(X, y[, sample_weight])</td><td>返回给定测试数据和标签的平均准确值。</td></tr><tr><td>set_params(**params)</td><td>设置估值器的参数。</td></tr></tbody></table><h2 id="5、超参数"><a href="#5、超参数" class="headerlink" title="5、超参数"></a>5、超参数</h2><h3 id="5-1、超参数简介"><a href="#5-1、超参数简介" class="headerlink" title="5.1、超参数简介"></a>5.1、超参数简介</h3><p>之前我们都是为knn算法传一个默认的k值。在具体使用时应该传递什么值合适呢？</p><p>这就涉及了机器学习领域中的一个重要问题：超参数。所谓超参数，就是在机器学习算法模型执行之前需要指定的参数。（调参调的就是超参数） 如kNN算法中的k。</p><p>与之相对的概念是模型参数，即算法过程中学习的属于这个模型的参数（kNN中没有模型参数，回归算法有很多模型参数）</p><p>如何选择最佳的超参数，这是机器学习中的一个永恒的问题。在实际业务场景中，调参的难度大很多，一般我们会业务领域知识、经验数值、实验搜索等方面获得最佳参数。### 4、在sklearn中使用KNN</p><h3 id="5-2、寻找最好的k"><a href="#5-2、寻找最好的k" class="headerlink" title="5.2、寻找最好的k"></a>5.2、寻找最好的k</h3><h4 id="5-2-1、对K进行遍历"><a href="#5-2-1、对K进行遍历" class="headerlink" title="5.2.1、对K进行遍历"></a>5.2.1、对K进行遍历</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdiris <span class="token operator">=</span> datasets<span class="token punctuation">.</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> iris<span class="token punctuation">.</span>datay <span class="token operator">=</span> iris<span class="token punctuation">.</span>target<span class="token keyword">def</span> <span class="token function">train_test_split_temp</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_ratio<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> seed<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""将矩阵X和标签y按照test_ration分割成X_train, X_test, y_train, y_test"""</span>    <span class="token keyword">assert</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token string">"the size of X must be equal to the size of y"</span>    <span class="token keyword">assert</span> <span class="token number">0.0</span> <span class="token operator">&lt;=</span> test_ratio <span class="token operator">&lt;=</span> <span class="token number">1.0</span><span class="token punctuation">,</span>         <span class="token string">"test_train must be valid"</span>    <span class="token keyword">if</span> seed<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 是否使用随机种子，使随机结果相同，方便debug</span>        np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>seed<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># permutation(n) 可直接生成一个随机排列的数组，含有n个元素</span>    shuffle_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>    test_size <span class="token operator">=</span> int<span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">*</span> test_ratio<span class="token punctuation">)</span>    test_index <span class="token operator">=</span> shuffle_index<span class="token punctuation">[</span><span class="token punctuation">:</span>test_size<span class="token punctuation">]</span>    train_index <span class="token operator">=</span> shuffle_index<span class="token punctuation">[</span>test_size<span class="token punctuation">:</span><span class="token punctuation">]</span>    X_train <span class="token operator">=</span> X<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span>    X_test <span class="token operator">=</span> X<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span>    y_train <span class="token operator">=</span> y<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span>    y_test <span class="token operator">=</span> y<span class="token punctuation">[</span>test_index<span class="token punctuation">]</span>        <span class="token keyword">return</span> X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_testX_train1<span class="token punctuation">,</span> X_test1<span class="token punctuation">,</span> y_train1<span class="token punctuation">,</span> y_test1 <span class="token operator">=</span> train_test_split_temp<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 指定最佳值的分数，初始化为0.0；设置最佳值k，初始值为-1</span>best_score <span class="token operator">=</span> <span class="token number">0.0</span>best_k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 暂且设定到1～11的范围内</span>    knn_clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span>k<span class="token punctuation">)</span>    knn_clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train1<span class="token punctuation">,</span> y_train1<span class="token punctuation">)</span>    score <span class="token operator">=</span> knn_clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test1<span class="token punctuation">,</span> y_test1<span class="token punctuation">)</span>        <span class="token keyword">if</span> score <span class="token operator">></span> best_score<span class="token punctuation">:</span>        best_k <span class="token operator">=</span> k        best_score <span class="token operator">=</span> score<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_k = "</span><span class="token punctuation">,</span> best_k<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_score = "</span><span class="token punctuation">,</span> best_score<span class="token punctuation">)</span></code></pre><pre><code>输出：best_k =  3best_score =  0.9666666666666667</code></pre><p>可以看到，最好的k值是3，在我们设定的k的取值范围中间。需要注意的是，如果我们得到的值正好在边界上，我们需要稍微扩展一下取值范围。因为嘛，你懂的！</p><h4 id="5-2-2、K折交叉验证"><a href="#5-2-2、K折交叉验证" class="headerlink" title="5.2.2、K折交叉验证"></a>5.2.2、K折交叉验证</h4><p>常用的交叉验证技术叫做<code>K折交叉验证(K-fold Cross Validation)</code>。 我们先把训练数据再分成训练集和验证集，之后使用训练集来训练模型，然后再验证集上评估模型的准确率。举个例子，比如一个模型有个参数叫$\alpha$，我们一开始不清楚要选择0.1还是1，所以这时候我们进行了交叉验证：把所有训练集分成K块，依次对每一个$\alpha$值评估它的准确率。</p><p>一般情况下数据量较少的时候我们取的K值会更大，为什么呢? 因为数据量较少的时候如果每次留出比较多的验证数据，对于训练模型本身来说是比较吃亏的，所以这时候我们尽可能使用更多的数据来训练模型。由于每次选择的验证数据量较少，这时候K折中的K值也会随之而增大，但到最后可以发现，无论K值如何选择，用来验证的样本个数都是等于总样本个数。</p><p>最极端的情况下，我们可以采用<code>leave_one_out</code>交叉验证，也就是每次只把一个样本当做验证数据，剩下的其他数据都当做是训练样本。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> KFoldiris <span class="token operator">=</span> datasets<span class="token punctuation">.</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span>X <span class="token operator">=</span> iris<span class="token punctuation">.</span>datay <span class="token operator">=</span> iris<span class="token punctuation">.</span>target<span class="token comment" spellcheck="true"># 定义我们想要搜索的K值</span>ks <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 进行5折交叉验证，KFold返回的是每一折中训练数据和验证数据的index</span><span class="token comment" spellcheck="true"># 假设数据样本为： [1,3,5,6,11,12,43,12,44,2], 总共10个样本</span><span class="token comment" spellcheck="true"># 则返回的kf的格式为(前面的是训练数据，后面的是验证集）：</span><span class="token comment" spellcheck="true"># [0,1,3,5,6,7,8,9], [2,4]</span><span class="token comment" spellcheck="true"># [0,1,2,4,6,7,8,9], [3,5]</span><span class="token comment" spellcheck="true"># [1,2,3,4,5,6,7,8], [0,9]</span><span class="token comment" spellcheck="true"># [0,1,2,3,4,5,7,9], [6,8]</span><span class="token comment" spellcheck="true"># [0,2,3,4,5,6,8,9], [1,7]</span>kf <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存当前最好的K值和对应的准确率值</span>best_k <span class="token operator">=</span> ks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>best_score <span class="token operator">=</span> <span class="token number">0.0</span><span class="token comment" spellcheck="true"># 循环每一个K值</span><span class="token keyword">for</span> k <span class="token keyword">in</span> ks<span class="token punctuation">:</span>    cur_score <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> train_index<span class="token punctuation">,</span> valid_index <span class="token keyword">in</span> kf<span class="token punctuation">.</span>split<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#         print(train_index)</span>        <span class="token comment" spellcheck="true"># 每一折的训练以及计算准确率</span>        clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span>k<span class="token punctuation">)</span>        clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>train_index<span class="token punctuation">]</span><span class="token punctuation">)</span>        cur_score <span class="token operator">=</span> cur_score <span class="token operator">+</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X<span class="token punctuation">[</span>valid_index<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>valid_index<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 求一下5折的平均准确率</span>    avg_score <span class="token operator">=</span> cur_score<span class="token operator">/</span><span class="token number">5</span>    <span class="token keyword">if</span> avg_score <span class="token operator">></span> best_score<span class="token punctuation">:</span>        best_score <span class="token operator">=</span> avg_score        best_k <span class="token operator">=</span> k        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"current best score is %f"</span><span class="token operator">%</span>best_score<span class="token punctuation">,</span><span class="token string">"best k is %d"</span><span class="token operator">%</span>best_k<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"after cross validation, the final besk k is %d"</span><span class="token operator">%</span>best_k<span class="token punctuation">)</span></code></pre><pre><code>输出：current best score is 0.960000 best k is 1current best score is 0.973333 best k is 8current best score is 0.986667 best k is 9after cross validation, the final besk k is 9</code></pre><p>sklearn中实现</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#调用网格搜索方法</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCVparam_search <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"n_neighbors"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>knn_clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span>clf <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>knn_clf<span class="token punctuation">,</span> param_search<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best score is %f"</span><span class="token operator">%</span>clf<span class="token punctuation">.</span>best_score_<span class="token punctuation">,</span><span class="token string">"best k is "</span><span class="token punctuation">,</span> clf<span class="token punctuation">.</span>best_params_<span class="token punctuation">)</span></code></pre><pre><code>输出：best score is 0.980000 best k is  {&#39;n_neighbors&#39;: 6}</code></pre><blockquote><p>对于交叉验证，决不能用测试数据来引导模型的训练</p></blockquote><h3 id="5-3、另一个超参数：权重"><a href="#5-3、另一个超参数：权重" class="headerlink" title="5.3、另一个超参数：权重"></a>5.3、另一个超参数：权重</h3><p>在回顾kNN算法思想时，我们应该还记得，对于简单的kNN算法，只需要考虑最近的n个数据是什么即可。但是如果我们考虑距离呢？</p><p>如果我们认为，距离样本数据点最近的节点，对其影响最大，那么我们使用距离的倒数作为权重。假设距离样本点最近的三个节点分别是红色、蓝色、蓝色，距离分别是1、4、3。那么普通的k近邻算法：蓝色获胜。考虑权重（距离的倒数）：红色：1，蓝色：1/3 + 1/4 = 7/12，红色胜。</p><p>在 <code>sklearn.neighbors</code> 的构造函数 <code>KNeighborsClassifier</code> 中有一个参数：<code>weights</code>，默认是<code>uniform</code>即不考虑距离，也可以写<code>distance</code>来考虑距离权重(默认是欧拉距离，如果要是曼哈顿距离，则可以写参数p（明可夫斯基距离的参数），这个也是超参数)</p><p>因为有两个超参数，因此使用双重循环，去查找最合适的两个参数，并打印。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 两种方式进行比较</span>best_method <span class="token operator">=</span> <span class="token string">""</span>best_score <span class="token operator">=</span> <span class="token number">0.0</span>best_k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> method <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"uniform"</span><span class="token punctuation">,</span><span class="token string">"distance"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        knn_clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors<span class="token operator">=</span>k<span class="token punctuation">,</span> weights<span class="token operator">=</span>method<span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        knn_clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train1<span class="token punctuation">,</span> y_train1<span class="token punctuation">)</span>        score <span class="token operator">=</span> knn_clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test1<span class="token punctuation">,</span> y_test1<span class="token punctuation">)</span>                <span class="token keyword">if</span> score <span class="token operator">></span> best_score<span class="token punctuation">:</span>            best_k <span class="token operator">=</span> k            best_score <span class="token operator">=</span> score            best_method <span class="token operator">=</span> method<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_method = "</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_k = "</span><span class="token punctuation">,</span> best_k<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"best_score = "</span><span class="token punctuation">,</span> best_score<span class="token punctuation">)</span></code></pre><pre><code>输出：best_method =  distancebest_k =  3best_score =  0.9666666666666667</code></pre><h3 id="5-4、超参数网格搜索"><a href="#5-4、超参数网格搜索" class="headerlink" title="5.4、超参数网格搜索"></a>5.4、超参数网格搜索</h3><p>在具体的超参数搜索过程中会需要很多问题，超参数过多、超参数之间相互依赖等等。如何一次性地把我们想要得到最好的超参数组合列出来。<code>sklearn</code>中专门封装了一个超参数网格搜索方法<code>Grid Serach</code>。</p><p>在进行网格搜索之前，首先需要定义一个搜索的参数<code>param_search</code>。是一个数组，数组中的每个元素是个字典，字典中的是对应的一组网格搜索，每一组网格搜索是这一组网格搜索每个参数的取值范围。键是参数的名称，值是键所对应的参数的列表。</p><pre class=" language-python"><code class="language-python">param_search <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"weights"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"uniform"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">"n_neighbors"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        <span class="token string">"weights"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"distance"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">"n_neighbors"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">"p"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>可以看到，当<code>weights = uniform</code>即不使用距离时，我们只搜索超参数k，当<code>weights = distance</code>即使用距离时，需要看超参数p使用那个距离公式。下面创建要进行网格搜索所对应的分类算法并调用刚哥搜索：</p><pre class=" language-python"><code class="language-python">knn_clf <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用网格搜索方法</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> GridSearchCV<span class="token comment" spellcheck="true"># 定义网格搜索的对象grid_search，</span><span class="token comment" spellcheck="true"># 其构造函数的第一个参数表示对哪一个分类器进行算法搜索，</span><span class="token comment" spellcheck="true"># 第二个参数表示网格搜索相应的参数</span>grid_search <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>knn_clf<span class="token punctuation">,</span> param_search<span class="token punctuation">)</span></code></pre><p>下面就是针对X_train1, y_train1，使用grid_search在param_search列表中寻找最佳超参数组：</p><pre class=" language-python"><code class="language-python"><span class="token operator">%</span><span class="token operator">%</span>timegrid_search<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train1<span class="token punctuation">,</span> y_train1<span class="token punctuation">)</span></code></pre><pre><code>输出：Wall time: 662 msGridSearchCV(cv=None, error_score=&#39;raise&#39;,       estimator=KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights=&#39;uniform&#39;),       fit_params=None, iid=True, n_jobs=1,       param_grid=[{&#39;weights&#39;: [&#39;uniform&#39;], &#39;n_neighbors&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, {&#39;weights&#39;: [&#39;distance&#39;], &#39;n_neighbors&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], &#39;p&#39;: [1, 2, 3, 4, 5]}],       pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=&#39;warn&#39;,       scoring=None, verbose=0)</code></pre><p>可以使用网格搜索的评估函数来返回最佳分类起所对应的参数</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 返回的是网格搜索搜索到的最佳的分类器对应的参数 </span>grid_search<span class="token punctuation">.</span>best_estimator_</code></pre><pre><code>KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights=&#39;uniform&#39;)</code></pre><p>也可以查看最佳参数的分类器的准确度。</p><p>我们会注意到，<code>best_estimator_</code>和<code>best_score_</code>参数后面有一个<code>_</code>。这是一种常见的语法规范，不是用户传入的参数，而是根据用户传入的规则，自己计算出来的结果，参数名字后面接<code>_</code></p><pre class=" language-python"><code class="language-python">grid_search<span class="token punctuation">.</span>best_score_</code></pre><pre><code>输出：0.9833333333333333</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立博客的初衷</title>
      <link href="/2019/12/10/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/"/>
      <url>/2019/12/10/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊建立博客的初衷与对未来的展望"><a href="#聊聊建立博客的初衷与对未来的展望" class="headerlink" title="聊聊建立博客的初衷与对未来的展望"></a>聊聊建立博客的初衷与对未来的展望</h1><h2 id="一、为什么建立个人博客"><a href="#一、为什么建立个人博客" class="headerlink" title="一、为什么建立个人博客"></a>一、为什么建立个人博客</h2><p>我和大多数人一样，是个平凡而普通的人。在过去的二十多年里，我过着普通的生活、接受着普通的教育，有自己的想法却又不付诸行动，是一条不折不扣的咸鱼🙈。</p><p>在大学中因为种种原因放弃了一些好的机会（对我而言）而去了一家小公司，当时看重的是这家公司的发展前景与创始人的真诚，但是现实还是给我上了一课，其中的酸涩只有经历过的人才能体会。因此如果你是快要毕业的计算机专业学生且打算从事专业对口的工作，我<strong>强烈建议你千万不要去小公司</strong>（也不是绝对，我会专门写一篇博客说说我的理由）！当初是我自己的选择，因此我不后悔，我觉得：</p><ol><li><strong>作为一个成年人，任何的选择都应该做出充分的考虑，是权衡利弊后最终的结果，理应为此做好最坏的打算</strong>；</li><li><strong>我相信任何的经历都是独一无二的，都是你成长过程中宝贵的财富</strong>；</li><li><strong>你的每段经历都会对你的未来产生潜移默化的影响，这种未知的可能性让人妙不可言</strong>。</li></ol><p>19年8月份我裸辞了，及时止损😎。一是因为工作的原因想休息休息，对于二十几岁的我来说，<strong>身体上的劳累尚可接受，心理上的压抑让我寝食难安</strong>；另外一个原因是想换个方向。</p><p>我大学学的是计算机专业（普通二本），我自认为在我们班中专业能力还算靠前，毕业后的第一份工作也是Java开发，但是因为我自己疏于学习，加之这家公司不使用主流的框架、没有任何的代码规范、不适用任何的版本控制工具等等等等的原因，让我觉得这段工作没有让我在技术上有太大的提升，已经显著落后与同龄人。这令我对重新找一份<strong>我满意</strong>的Java开发工作没有太大的信心；另一方面也是因为第一段工作的原因让我对<strong>数据分析</strong>产生了浓厚的兴趣，因此想找一份数据分析方向的工作。</p><p>在家自学了三个月，之前就零零散散的学习了一些数据分析的基础知识，在三个月中每天看看学习视频、写写代码、读读书、刷刷剧、炒炒股、陪朋友打打游戏、做做饭、晒晒太阳、睡睡懒觉，日子过得也还算充实有趣。对于往后的工作职位我并没有太高的要求，只想找一个大公司从头开始。花了半个月的时间收到了两份相对满意数据分析入门offer。经过权衡，19年11月底我加入了其中一家跨境电商公司。<strong>新的工作、新的同事、新的生活</strong>，我觉得我也应该做出些改变。</p><p>我是一个性格比较内敛的人，不喜欢拍照，留下的照片也寥寥无几，但是在过去的二十年，照片绝对是记录生活的一个很好的载体。我现在已经回忆不起我在过去的某个时间段做过什么事情，如果你喜欢写日记，那就坚持下去，如果你害怕日记写成流水账就多拍拍照片/vlog，因为这些<strong>具象化</strong>的东西会快速调起你的回忆，也帮你记录生活。</p><p>我自觉还算是一个<strong>对技术充满渴望</strong>的人，所以个人博客可能对我来说是个不错的选择。博客不仅记录我学习、思考的过程，同时也可以记录一下日常的生活，对于我来说，建立博客的好处有一下几点：</p><ul><li>我有拖延症，博客可以从一方面push我不断学习新的知识</li><li>我自己的理解能力尚可，表达能力欠佳，写作可以锻炼我的思维与表达能力</li><li>能加深自己对知识的理解，形成自己的知识体系</li><li>算是对个人知识、个人生活的归档与记录，方便日后查阅，同时在技术上也可以顺便解决他人类似的问题</li></ul><p>最后，努力奋斗，努力做一个<code>自由而无用</code>的人😆。</p><h2 id="二、对未来的展望"><a href="#二、对未来的展望" class="headerlink" title="二、对未来的展望"></a>二、对未来的展望</h2><h3 id="2-1、工作上"><a href="#2-1、工作上" class="headerlink" title="2.1、工作上"></a>2.1、工作上</h3><p>从<code>短期</code>来看，尽快熟悉新的工作，尽快建立通用的<code>数据分析思维</code>，尽早掌握初级分析师的全部技能</p><p>以<code>2020</code>年来说，希望自己重拾<code>数学</code>知识，在打好<code>数学基础</code>的同时学完<code>统计学</code>与<code>机器学习</code>的基础知识</p><p>从<code>长期</code>来看，先掌握<code>数据采集-数据清洗-数据建模-数据分析</code>整套流程的<strong>思维方式</strong>与<strong>通用技能</strong>，再对每个过程做更深入的了解，包括且不限于<code>数据埋点、数据仓库、机器学习、深度学习、分布式爬虫、算法....</code></p><h3 id="2-2、生活上"><a href="#2-2、生活上" class="headerlink" title="2.2、生活上"></a>2.2、生活上</h3><ul><li>慢慢改掉自己拖延的坏习惯</li><li>减少零碎与娱乐信息的获取</li><li>维护和谐的家庭与社交关系</li><li>保持好奇心，保持身材</li><li>多读上市公司研报，建立自己的经济知识体系</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN-1-KNN简介</title>
      <link href="/2019/12/10/KNN-1-KNN%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/12/10/KNN-1-KNN%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="KNN入门"><a href="#KNN入门" class="headerlink" title="KNN入门"></a>KNN入门</h1><p>最近开始学习机器学习的有关知识，对于初学者来说，KNN算法因朴素的思想其被认为是最适合入门的机器学习算法，没有之一。本篇文章主要介绍KNN算法的基本知识与核心思想。</p><h2 id="1、KNN简介"><a href="#1、KNN简介" class="headerlink" title="1、KNN简介"></a>1、KNN简介</h2><p>kNN (k-NearestNeighbor)，也就是k最近邻算法，这是一种有监督的学习算法，该算法既可以针对离散因变量做分类，又可以对连续因变量做预测</p><h2 id="2、核心思想"><a href="#2、核心思想" class="headerlink" title="2、核心思想"></a>2、核心思想</h2><blockquote><p>近朱者赤，近墨者黑</p></blockquote><p>举个简单的例子，以下是支付宝对<code>芝麻信用分</code>的定义：</p><blockquote><p>依据用户各类消费及行为数据，结合互联网金融借贷信息，运用云计算及机器学习等技术，通过逻辑回归、决策树、随机森林等模型算法，对各维度数据进行综合处理和评估，在用户信用历史、行为偏好、履约能力、身份特质、<strong>人脉关系</strong>五个维度客观呈现个人信用状况的综合分值。</p></blockquote><p>注意<code>人脉关系</code>这个维度，用通俗的话说就是你好友中混的最差的哥们都开玛莎拉蒂，月消费几十万，那么你的消费履约能力应该也不差</p><p><img src="https://i.loli.net/2019/12/15/okjqyCK8fHAne2r.png" alt="KNN原理图片示例"></p><p>如图所示，KNN算法的本质就是寻找𝑘个最近样本，然后基于最近样本做“预测”。对于离散型的因变量来说，从𝑘个最近的已知类别样本中挑选出频率最高的类别用于未知样本的判断；对于连续型的因变量来说，则是将𝑘个最近的已知样本均值用作未知样本的预测。</p><h2 id="3、算法步骤-amp-关键点"><a href="#3、算法步骤-amp-关键点" class="headerlink" title="3、算法步骤&amp;关键点"></a>3、算法步骤&amp;关键点</h2><ul><li>确定未知样本近邻的个数𝑘值。</li></ul><ul><li>根据某种度量样本间相似度的指标（如欧氏距离）将每一个未知类别样本的最近𝑘个已知样本搜寻出来，形成一个个簇。</li></ul><ul><li>对搜寻出来的已知样本进行投票，将各簇下类别最多的分类用作未知样本点的预测。</li></ul><h3 id="3-1、K值的选择"><a href="#3-1、K值的选择" class="headerlink" title="3.1、K值的选择"></a>3.1、K值的选择</h3><p>根据经验发现，不同的𝑘值对模型的预测准确性会有比较大的影响，如果𝑘值过于偏小，可能会导致模型的过拟合；反之，又可能会使模型进入欠拟合状态。</p><p><img src="https://i.loli.net/2019/12/15/UOaQVc6PuwY7k9m.png" alt="不同K值选择导致的结果"></p><p>以芝麻分的例子来说，是选取你所有的好友来推断你的信用呢还是选取经常和你有金钱或信息来往的人进行推断呢？</p><p>目前有两种K值选择方案：</p><ul><li><p>第一种：设置k近邻样本的投票权重，假设读者在使用KNN算法进行分类或预测时设置的k值比较大，担心模型发生欠拟合的现象，一个简单有效的处理办法就是设置近邻样本的投票权重，如果已知样本距离未知样本比较远，则对应的权重就设置得低一些，否则权重就高一些，通常可以将权重设置为距离的倒数。</p></li><li><p>第二种：采用多重交叉验证法，该方法是目前比较流行的方案，其核心就是将k取不同的值，然后在每种值下执行m重的交叉验证，最后选出平均误差最小的k值。</p></li></ul><h3 id="3-2、样本间相似度的度量方法"><a href="#3-2、样本间相似度的度量方法" class="headerlink" title="3.2、样本间相似度的度量方法"></a>3.2、样本间相似度的度量方法</h3><p>前面说到可以根据样本距离的远近设置对应的权重，那么如果计算样本之间的距离呢？一下有三种计算样本间距离的方法：</p><h4 id="3-2-1、欧式距离"><a href="#3-2-1、欧式距离" class="headerlink" title="3.2.1、欧式距离"></a>3.2.1、欧式距离</h4><p><img src="https://i.loli.net/2019/12/15/WlLchdN2BqRgMt4.png" alt="欧氏距离"></p><h4 id="3-2-2、曼哈顿距离"><a href="#3-2-2、曼哈顿距离" class="headerlink" title="3.2.2、曼哈顿距离"></a>3.2.2、曼哈顿距离</h4><p><img src="https://i.loli.net/2019/12/15/jupFbCofr9qhI7e.png" alt="曼哈顿距离"></p><h4 id="3-2-3、余弦相似度"><a href="#3-2-3、余弦相似度" class="headerlink" title="3.2.3、余弦相似度"></a>3.2.3、余弦相似度</h4><p><img src="https://i.loli.net/2019/12/15/KZaG9dCvBTDILfY.png" alt="余弦相似度"></p><h4 id="3-2-4、杰卡德相似系数"><a href="#3-2-4、杰卡德相似系数" class="headerlink" title="3.2.4、杰卡德相似系数"></a>3.2.4、杰卡德相似系数</h4><p>杰卡德相似系数与余弦相似度经常被用于推荐算法，计算用户之间的相似性。例如，A用户购买了10件不同的商品，B用户购买了15件不同的商品，则两者之间的相似系数可以表示为：</p><p>$$J(A,B)=\displaystyle  \frac {|A \cap B|}{|A \cup B|}$$</p><p>其中，|A⋂B|表示两个用户所购买相同商品的数量，|A⋃B|代表两个用户购买所有产品的数量。例如，A用户购买的10件商品中有8件与B用户一致，且两个用户一共购买了17件不同的商品，则它们的杰卡德相似系数为8/17。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
